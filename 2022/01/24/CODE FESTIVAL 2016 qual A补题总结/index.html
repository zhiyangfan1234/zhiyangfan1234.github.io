<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zhiyangfan1234.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="CODE FESTIVAL 2016 qual A补题总结是这样的，我开了 A，B，C ，这题就这？还AGC难度呢？我是不是开了 ABC 啊？然后我看了 D…又看了 E…，对不起，我的问题，这确实是 AGC 中的好题。 题目A - CODEFESTIVAL 2016给一个有 $12$ 个英文字母的字符串，请在前四个字母和后八个字母之间加个空格后输出。 甚至不需要数据范围，感觉比最近 ABC 的 A">
<meta property="og:type" content="article">
<meta property="og:title" content="CODE FESTIVAL 2016 qual A">
<meta property="og:url" content="https://zhiyangfan1234.github.io/2022/01/24/CODE%20FESTIVAL%202016%20qual%20A%E8%A1%A5%E9%A2%98%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="zhiyangfan 的博客小窝">
<meta property="og:description" content="CODE FESTIVAL 2016 qual A补题总结是这样的，我开了 A，B，C ，这题就这？还AGC难度呢？我是不是开了 ABC 啊？然后我看了 D…又看了 E…，对不起，我的问题，这确实是 AGC 中的好题。 题目A - CODEFESTIVAL 2016给一个有 $12$ 个英文字母的字符串，请在前四个字母和后八个字母之间加个空格后输出。 甚至不需要数据范围，感觉比最近 ABC 的 A">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://atcoder.jp/img/other/code_festival_2016_quala/gbanjthabot/D_1.png">
<meta property="article:published_time" content="2022-01-24T09:00:23.000Z">
<meta property="article:modified_time" content="2022-01-24T09:12:56.448Z">
<meta property="article:author" content="zhiyangfan">
<meta property="article:tag" content="AGC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://atcoder.jp/img/other/code_festival_2016_quala/gbanjthabot/D_1.png">

<link rel="canonical" href="https://zhiyangfan1234.github.io/2022/01/24/CODE%20FESTIVAL%202016%20qual%20A%E8%A1%A5%E9%A2%98%E6%80%BB%E7%BB%93/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>CODE FESTIVAL 2016 qual A | zhiyangfan 的博客小窝</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">zhiyangfan 的博客小窝</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhiyangfan1234.github.io/2022/01/24/CODE%20FESTIVAL%202016%20qual%20A%E8%A1%A5%E9%A2%98%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhiyangfan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhiyangfan 的博客小窝">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CODE FESTIVAL 2016 qual A
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-01-24 17:00:23 / 修改时间：17:12:56" itemprop="dateCreated datePublished" datetime="2022-01-24T17:00:23+08:00">2022-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="CODE-FESTIVAL-2016-qual-A补题总结"><a href="#CODE-FESTIVAL-2016-qual-A补题总结" class="headerlink" title="CODE FESTIVAL 2016 qual A补题总结"></a>CODE FESTIVAL 2016 qual A补题总结</h2><p>是这样的，我开了 A，B，C ，这题就这？还AGC难度呢？我是不是开了 ABC 啊？然后我看了 D…又看了 E…，对不起，我的问题，这确实是 AGC 中的好题。</p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="A-CODEFESTIVAL-2016"><a href="#A-CODEFESTIVAL-2016" class="headerlink" title="A - CODEFESTIVAL 2016"></a>A - CODEFESTIVAL 2016</h4><p>给一个有 $12$ 个英文字母的字符串，请在前四个字母和后八个字母之间加个空格后输出。</p>
<p><del>甚至不需要数据范围，感觉比最近 ABC 的 A 还简单。</del> 不多说了，想怎么实现怎么实现，这里就给个 C 风格的吧。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; ++i) <span class="built_in">putchar</span>(str[i]);</span><br><span class="line">	<span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>); <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>; i &lt;= <span class="number">12</span>; ++i) <span class="built_in">putchar</span>(str[i]);</span><br><span class="line">	<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="B-Friendly-Rabbits"><a href="#B-Friendly-Rabbits" class="headerlink" title="B - Friendly Rabbits"></a>B - Friendly Rabbits</h4><p>给出一个长为 $N$ 的序列 $a$ ，其中 $a_i$ 表示第 $i$ 只兔子喜欢第 $a_i$ 只，问有多少对兔子相互喜欢（喜欢关系不能传递）。($2\le N\le10^5,1\le a_i\le N,a_i\ne i$)</p>
<p><del>本来我以为这玩意可以相互传递，已经准备好建图判环了</del> 好吧既然关系不能传递就很简单了，对于任意一只兔子，只有它喜欢的那只才有可能与它相互喜欢，检查一下是不是有 $a_{a_i}=i$ 就好了，因为这样一对兔子会被计算两次，所以最后答案除以要 $2$。时间复杂度 $\mathcal{O}(N)$ 。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>; <span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, cnt = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="keyword">if</span> (a[a[i]] == i) ++cnt;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cnt / <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="C-Next-Letter"><a href="#C-Next-Letter" class="headerlink" title="C - Next Letter"></a>C - Next Letter</h4><p>给出一个只含有小写字母的字符串 $s$ ，对它执行以下操作 <strong>恰好</strong> $K$ 次：</p>
<ul>
<li>从 $s$ 中选择任意一个字符并把它改为它的下一个字母，注意 <code>z</code> 的下一个字母是 <code>a</code> 。</li>
</ul>
<p>找到 $K$ 次操作后能得到的字典序最小的字符串 $s$ 。($1\le |s|\le10^5,1\le K\le 10^9$)</p>
<p>注意到除非能一直对一个位置执行该操作直到把一个非 <code>a</code> 的地方变为 <code>a</code> ，否则还不如不执行，因为只要不转一圈回来这个操作都是会增大字典序的。又因为字典序是以第 $i$ 个位置为第 $i$ 关键字的比较，所以我们优先保证第 $1$ 个位置能变为 <code>a</code> ，之后依次从前往后遍历每个位置，查看剩余次数是否能使它变为 <code>a</code> ，如果能就花费相应的次数操作。最后可能会剩下一些操作，由于前面的过程已经保证剩余次数不能再把新的位置变 <code>a</code> ，所以我们对这剩余次数的最好处理方式就是全部扔到最后一个位置上，这样对字典序的影响最小。时间复杂度 $\mathcal{O}(|s|)$ 。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>; <span class="keyword">char</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> k, n; <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, s + <span class="number">1</span>, &amp;k); n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">	<span class="comment">//注意这里必须判断一下 s[i] 原来不等于 &#x27;a&#x27;，否则可能会浪费 26 次次数转一圈 </span></span><br><span class="line">		<span class="keyword">if</span> (s[i] != <span class="string">&#x27;a&#x27;</span> &amp;&amp; k &gt;= <span class="number">26</span> - s[i] + <span class="string">&#x27;a&#x27;</span>) k -= <span class="number">26</span> - s[i] + <span class="string">&#x27;a&#x27;</span>, s[i] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">	<span class="keyword">if</span> (!k) &#123; <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s + <span class="number">1</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">	s[n] = (s[n] - <span class="string">&#x27;a&#x27;</span> + k) % <span class="number">26</span> + <span class="string">&#x27;a&#x27;</span>; <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><del>前戏结束，比赛正式开始</del></p>
<h4 id="D-Grid-and-Integers"><a href="#D-Grid-and-Integers" class="headerlink" title="D - Grid and Integers"></a>D - Grid and Integers</h4><p>给出一个 $R$ 行 $C$ 列的表格，我们称第 $r$ 行第 $c$ 列为 $(r,c)$ 。在这个表格中写入 $N$ 个数字，也就是 $(r_i,c_i)$ 上有一个非负整数 $a_i$ 。接下来想把剩下的表格填满，但要满足以下条件：</p>
<ul>
<li>条件1：所有的格子中都必须是非负整数</li>
<li>条件2：对于表格中任意的 $2\times 2$ 区域，都要有左上角和右下角中整数的和等于右上角和左下角中整数的和。</li>
</ul>
<p>求是否能找到一种填表格的方式满足以上条件。($2\le R,C\le10^5,1\le N\le10^5,\forall i\ne j,(r_i,c_i)\ne (r_j,c_j),a_i\in\{x\in Z|0\le x\le10^9\}$)</p>
<p>难度骤增，我跟我后面那位 $\rm \color{black}V\color{red}areal$ 讨论了好久也没有什么特别的思路…. 好的，言归正传，这题其实我们讨论出来了一个大概，但是没想到实现这么神仙。首先我们发现原题给出的式子 $a_{i,j}+a_{i+1,j+1}=a_{i+1,j}+a_{i,j+1}$ ，其实可以变一变，变成 $a_{i,j}-a_{i+1,j}=a_{i,j+1}-a_{i+1,j+1}$ ，也就是相邻的两列($j$ 和 $j+1$) 元素差相同($i$ 和 $i+1$) 。同理类似的变化，我们可以得到相邻的两行元素差相同。也就是说，这个题的重要性质是最终填完的表格要满足所有行对应的差分序列相同，所有列对应的差分序列相同。其实这时候就可以大概有个思路的雏形了，比如对于题目中给出的例子:<br><img src="https://atcoder.jp/img/other/code_festival_2016_quala/gbanjthabot/D_1.png" alt=""></p>
<p>就是因为第二列在确定这两个数字的条件下，其差分序列不可能跟第一列的差分序列相同才无法填出。</p>
<p>接下来考虑如何去维护这个奇妙的性质，这用到了一个我之前没听说过的 DS ，带权并查集。具体来说，并查集是一个树形结构，而带权并查集就是在点上加一个权值，注意路径压缩的时候要合并一下权值信息就可以。我们首先考虑如何维护所有行对应的差分序列相同，列的就同理了。我们将已有的数字按照行编号升序遍历，对于同行不同列的两个点，我们设它们的列数为 $c_1,c_2$ 。如果 $c_1,c_2$ 不在一个并查集，说明这俩列之间的差还没有被确定，我们把它们合并到同一个并查集，我们把 $c_1$ 的父亲设为 $c_2$ ，并把 $c_1$ 的权值 $val_{c_1}$ 设为这两个点的差。如果在同一个并查集里，说明已经确定差是多少了，判断一下这俩的差符不符合就可以了($a_{r,c_1}-a_{r,c_2}=val_{c_1}-val_{c_2}$ ，这里直接用 $c_1,c_2$ 是因为刚刚查找过 $c_1,c_2$ 在并查集中的父亲，路径压缩过了，$c_1,c_2$ 直接指向根节点)。</p>
<p>还没完，这只是保证能填出来，不能保证填出来的数就是非负整数。因为带权并查集的权值表示当前节点与父亲节点的差，所以我们只需要枚举行或者列，找到最小的差和最小的权值，如果相加小于 $0$ 就不满足条件，具体实现细节放到代码中，总之时间复杂度 $\mathcal{O}(n\alpha(n))$ ，其中 $\alpha(n)$ 表示并查集的时间复杂度。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>; ll mx1[N], mx2[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span> <span class="keyword">int</span> pos[<span class="number">2</span>], val; &#125;p[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DSU</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> f[N], n; ll dif[N];</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> x)</span> </span></span><br><span class="line"><span class="function">	</span>&#123; n = x; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) f[i] = i; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (x == f[x]) <span class="keyword">return</span> x;</span><br><span class="line">		<span class="comment">//路径压缩时要把权值合并</span></span><br><span class="line">		<span class="keyword">int</span> fa = <span class="built_in">getf</span>(f[x]); dif[x] += dif[f[x]];</span><br><span class="line">		<span class="keyword">return</span> f[x] = fa;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> typ, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> tx = <span class="built_in">getf</span>(p[a].pos[typ]),</span><br><span class="line">		ty = <span class="built_in">getf</span>(p[b].pos[typ]);</span><br><span class="line">		<span class="keyword">if</span> (tx == ty)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (p[a].val - dif[p[a].pos[typ]] == </span><br><span class="line">			p[b].val - dif[p[b].pos[typ]])</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			ll va = p[a].val - dif[p[a].pos[typ]],</span><br><span class="line">			vb = p[b].val - dif[p[b].pos[typ]];</span><br><span class="line">			f[tx] = ty; dif[tx] = va - vb; <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;dsu1, dsu2;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r, c, n; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;r, &amp;c, &amp;n);</span><br><span class="line">	dsu1.<span class="built_in">init</span>(c); dsu2.<span class="built_in">init</span>(r); <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;p[i].pos[<span class="number">0</span>], &amp;p[i].pos[<span class="number">1</span>], &amp;p[i].val);</span><br><span class="line">	<span class="built_in">memset</span>(mx1, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span> (mx1)); <span class="built_in">memset</span>(mx2, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span> (mx2));</span><br><span class="line">	std::<span class="built_in">sort</span>(p + <span class="number">1</span>, p + n + <span class="number">1</span>, </span><br><span class="line">	[&amp;](<span class="keyword">const</span> node&amp; n1, <span class="keyword">const</span> node&amp; n2) &#123; <span class="keyword">return</span> n1.pos[<span class="number">0</span>] &lt; n2.pos[<span class="number">0</span>]; &#125;);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">		<span class="keyword">if</span> (p[i].pos[<span class="number">0</span>] == p[i + <span class="number">1</span>].pos[<span class="number">0</span>])</span><br><span class="line">			<span class="keyword">if</span> (dsu1.<span class="built_in">check</span>(<span class="number">1</span>, i, i + <span class="number">1</span>)) flag = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (flag) &#123; <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">	std::<span class="built_in">sort</span>(p + <span class="number">1</span>, p + n + <span class="number">1</span>,</span><br><span class="line">	[&amp;](<span class="keyword">const</span> node&amp; n1, <span class="keyword">const</span> node&amp; n2) &#123; <span class="keyword">return</span> n1.pos[<span class="number">1</span>] &lt; n2.pos[<span class="number">1</span>]; &#125;);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">		<span class="keyword">if</span> (p[i].pos[<span class="number">1</span>] == p[i + <span class="number">1</span>].pos[<span class="number">1</span>])</span><br><span class="line">			<span class="keyword">if</span> (dsu2.<span class="built_in">check</span>(<span class="number">0</span>, i, i + <span class="number">1</span>)) flag = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (flag) &#123; <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">	<span class="comment">//枚举列父亲找到最小数字</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, fa; i &lt;= n; ++i)</span><br><span class="line">	&#123; </span><br><span class="line">		fa = dsu1.<span class="built_in">getf</span>(p[i].pos[<span class="number">1</span>]); </span><br><span class="line">		mx1[fa] = std::<span class="built_in">min</span>(mx1[fa], p[i].val - dsu1.dif[p[i].pos[<span class="number">1</span>]]); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//枚举列父亲找到最小权值</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, fa; i &lt;= c; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		fa = dsu1.<span class="built_in">getf</span>(i);</span><br><span class="line">		mx2[fa] = std::<span class="built_in">min</span>(mx2[fa], dsu1.dif[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//计算最小值，判断是否合法</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, fa; i &lt;= c; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		fa = dsu1.<span class="built_in">getf</span>(i);</span><br><span class="line">		<span class="keyword">if</span> (fa == i &amp;&amp; mx1[fa] + mx2[fa] &lt; <span class="number">0</span>) flag = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (flag) &#123; <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="E-LRU-Puzzle"><a href="#E-LRU-Puzzle" class="headerlink" title="E - LRU Puzzle"></a>E - LRU Puzzle</h4><p>给出 $N$ 个长为 $M$ 的数组，刚开始每个数组里面都是 $(1,2,3,\cdot\cdot\cdot,M)$ 。给出一个长为 $Q$ 的操作序列 $a$ ，其中 $a_i$ 表示对于一个数组，我们把 $a_i$ 这个数提到第一位。我们要顺次执行完所有的操作，每次操作可以对任意一个数组施加，求能否使操作完后所有的数组都相同。($2\le N,M\le10^5,1\le Q\le10^5,1\le a_i\le M$)</p>
<p>思维神题，洛谷上只有 $3$ 个人通过的神题。我们来形式化解释一下题意，正好方便后续的解释。我们设 $f_M(a)$ 表示对于长为 $M$ 的初始数组依次施加 $a$ 序列操作后得到的序列。比如如果 $M=6,a=(6,3,1,3,6,3)$ ，则 $f_M(a)=(3,6,1,2,4,5)$ （手玩一下应该没啥问题）。有个很简单 <del>(但是挺不好想的方法)</del> 来求解 $f_M(a)$，我们定义一个辅助数组 $b$ ，一开始为空。倒序遍历 $a$ 序列，如果当前正在处理的 $a_i$ 在 $b$ 中没出现过，就把它加到末尾，否则啥也不干。遍历过后，我们把剩下的没有出现过的 $1-M$ 之间的数字以递增的顺序加到 $b$ 末尾，这样之后就满足 $f_M(a)=b$ 。经过这样转化后，原问题就是：</p>
<blockquote>
<p>给一个操作序列 $a$ ，问能不能把 $a$ 分为若干个子序列 $a_1,a_2,a_3,\cdot\cdot\cdot,a_n$ ，使得 $f_M(a_1)=f_M(a_2)=f_M(a_3)=\cdot\cdot\cdot=f_M(a_N)$ 。</p>
</blockquote>
<p>接下来我们注意到，如果 $f_M(a_1)=f_M(a_2)=f_M(a_3)=\cdot\cdot\cdot=f_M(a_N)$ ，则 $f_M(a_1)$ 的第一个元素应该与 $f_M(a)$ 的第一个元素相等，否则因为 $a_i$ 是 $a$ 的子序列，一定存在一个数组第一个元素与 $f_M(a)$ 的相同，与 $f_M(a_i)=f_(a_1)$ 矛盾。按照这个道理，我们可以发现，$f_M(a_1)$ 的第二，第三……个元素都应该与 $f_M(a)$ 的相同。再推广一下，就能得到新的题意：</p>
<blockquote>
<p>给一个操作序列 $a$ ，问能不能把 $a$ 分为若干个子序列 $a_1,a_2,a_3,\cdot\cdot\cdot,a_n$ ，使得 $f_M(a_1)=f_M(a_2)=f_M(a_3)=\cdot\cdot\cdot=f_M(a_N)=f_M(a)$ 。</p>
</blockquote>
<p>比如我们还看刚刚的例子 $M=6,a=(6,3,1,3,6,3)$，我们可以把 $a_1=(6,3,3),a_2=(1,6,3)$ 这样分为两个部分，这样 $f_M(a_1)=f_M(a_2)=f_M(a)$ 。</p>
<p>秉着从简单到复杂的原则，我们先来看 $N=2$ 的情况。首先我们按照上述方法算出 $f_M(a)$ （其实也可以边做边算，之后在代码里面说吧）。然后我们设 $b_1,b_2$ 分别表示 $f_M(a_1),f_M(a_2)$ 计算过程中的辅助数组，我们的算法就是在把 $a$ 分为 $a_1,a_2$ 的过程中同时求出 $b_1,b_2$ 。因为我们想让遍历之后的 $b_1,b_2$ 在满足是 $f_M(a)$ 前缀的条件下，尽可能的长（这样才能尽可能靠近 $f_M(a)$），所以我们可以采取以下贪心做法，依然是倒序遍历 $a$ 。</p>
<ul>
<li>如果当前的 $a_i$ 既不在 $b_1$ 中也不在 $b_2$ 中，就把它加到 $b_1$ 末尾。</li>
<li>不失一般性，我们假设 $a_i$ 在 $b_1$ 中而不在 $b_2$ 中，则如果能满足加到 $b_2$ 里面后不破坏 $b_2$ 是 $f_M(a)$ 前缀的性质，就加到 $b_2$ 末尾。</li>
<li>如果 $a_i$ 既在 $b_1$ 也在 $b_2$ 就啥也不干。</li>
</ul>
<p>这些做完之后，我们把 $b_1,b_2$ 扩展到 $M$ 的长度，然后比较是否存在 $b_1=b_2=f_M(a)$ 。最终可以做到 $\mathcal{O}(M+Q)$ 的复杂度。</p>
<p>接下来考虑把这个算法推广到 $N\ge 2$ 的情况。首先我们还是先计算 $f_M(a)$ ，并设 $b_1,b_2,b_3,\cdot\cdot\cdot,b_N$ 分别表示 $f_M(a_1),f_M(a_2),f_M(a_3),\cdot\cdot\cdot,f_M(a_N)$ 的辅助数组。然后依然是倒序遍历 $a$ ，对于每个 $a_i$ ，找到一个 $b_j$ 满足 $b_j$ 中不含有 $a_i$ 且把 $a_i$ 加到 $b_j$ 末尾不破坏 $b_j$ 的前缀性质，然后把 $a_i$ 加到 $b_j$ 末尾。最后把所有的 $b$ 扩展到 $M$ 的长度，并比较是否存在 $b_1=b_2=b_3=\cdot\cdot\cdot=f_M(a)$ 。但非常遗憾，朴素的实现是 $\mathcal{O}(MN+NQ)$ 的复杂度，显然不能接受。</p>
<p>这里给粗一种可能的优化方式。因为所有的 $b$ 都是前缀，内容不重要，重要的是长度。所以我们设 $freq$ 数组，定义为：</p>
<script type="math/tex; mode=display">freq_k=\text{在所有的}b_i\text{中长度恰好为}k\text{的个数}</script><p>刚开始显然 $freq_0=N,freq_i=0(0<i\le M)$ ，因为所有的 $b$ 都是空的。则当我们遍历到 $a_i$ ，需要把 $a_i$ 加到长度恰好为 $k$ 的 $b_j$ 后面（英语题解这里 $k$ 突然冒出来把我晕了好久，其实就是对着 $f_M(a)$ 看，$a_i$ 该加到哪个位置了，然后就能对应出来 $k$），那如果 $freq_k\ge 1$ ，我们就把 $freq_k$ 减一，$freq_{k+1}$ 加一，否则啥也不干。这样遍历完之后，我们就得到了 $b$ 数组的长度。如果还是朴素的根据前缀扩展每个 $b$ 然后暴力比较，依然会逃不掉 $\mathcal{O}(NM)$ 的瓶颈。注意到如果长度最小的 $b_j$ 都满足 $b_j=f_M(a)$ ，则长度更大的 $b$ 也一定满足，因为 **确定的前缀越多，表示限制越大，与 $f_M(a)$ 相等的可能就更大** 。这样我们只需要把最短的 $b$ 给扩展并比较就好了，最终时间复杂度 $\mathcal{O}(M+Q)$ ，足以通过本题。（题解给的复杂度 $\mathcal{O}(N+M+Q)$，至少我的理解和我的实现里面都没有那个 $N$ ，不太清楚题解的想法）。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//奇短的代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>; <span class="keyword">int</span> q[N], fM[N], sq[N], bk[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m, Q; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;Q);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line">	sq[<span class="number">0</span>] = n; <span class="keyword">int</span> frt = <span class="number">0</span>, minx;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = Q, pos; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//边做边求fM</span></span><br><span class="line">		<span class="keyword">if</span> (!(pos = bk[q[i]])) pos = bk[q[i]] = ++frt, fM[frt] = q[i];</span><br><span class="line">		<span class="keyword">if</span> (sq[pos - <span class="number">1</span>]) --sq[pos - <span class="number">1</span>], ++sq[pos];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="keyword">if</span> (!bk[i]) bk[i] = ++frt, fM[frt] = i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) <span class="keyword">if</span> (sq[i]) &#123; minx = i; <span class="keyword">break</span>; &#125;</span><br><span class="line">	<span class="comment">//没必要求完，其实只需要检验一下需要补的位置是不是严格单调递增就好了</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = minx + <span class="number">2</span>; i &lt;= m; ++i)</span><br><span class="line">		<span class="keyword">if</span> (fM[i] &lt; fM[i - <span class="number">1</span>]) &#123; <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>前三题虚晃一枪，后两题神题。这次比较大的收获是了解了一种新的 DS 带权并查集， <del>和发现了一道冷门好题</del> 。我理解的的带权并查集是给的点权，不过因为这个点权表示的是和父亲节点的关系，其实理解为边权也没啥问题，只不过保存的形式是点权，主要应用场景就是当我们不仅仅需要记录集合关系，还需要记录集合内部元素间的关系（比如固定的差）。 AGC 的题真是不管那一场都能拿出来好好说道说道啊…</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/AGC/" rel="tag"># AGC</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/01/24/abc213/" rel="prev" title="AtCoder Beginner Contest 213">
      <i class="fa fa-chevron-left"></i> AtCoder Beginner Contest 213
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/01/24/CODE%20FESTIVAL%202016%20qual%20B%E8%A1%A5%E9%A2%98%E6%80%BB%E7%BB%93/" rel="next" title="CODE FESTIVAL 2016 qual B">
      CODE FESTIVAL 2016 qual B <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#CODE-FESTIVAL-2016-qual-A%E8%A1%A5%E9%A2%98%E6%80%BB%E7%BB%93"><span class="nav-number">1.</span> <span class="nav-text">CODE FESTIVAL 2016 qual A补题总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE"><span class="nav-number">1.1.</span> <span class="nav-text">题目</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#A-CODEFESTIVAL-2016"><span class="nav-number">1.1.1.</span> <span class="nav-text">A - CODEFESTIVAL 2016</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-Friendly-Rabbits"><span class="nav-number">1.1.2.</span> <span class="nav-text">B - Friendly Rabbits</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-Next-Letter"><span class="nav-number">1.1.3.</span> <span class="nav-text">C - Next Letter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#D-Grid-and-Integers"><span class="nav-number">1.1.4.</span> <span class="nav-text">D - Grid and Integers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#E-LRU-Puzzle"><span class="nav-number">1.1.5.</span> <span class="nav-text">E - LRU Puzzle</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.2.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhiyangfan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhiyangfan</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
