<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zhiyangfan1234.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="zhiyangfan 的博客小窝">
<meta property="og:url" content="https://zhiyangfan1234.github.io/page/2/index.html">
<meta property="og:site_name" content="zhiyangfan 的博客小窝">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="zhiyangfan">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://zhiyangfan1234.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>zhiyangfan 的博客小窝</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">zhiyangfan 的博客小窝</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhiyangfan1234.github.io/2022/01/24/AtCoder%20Grand%20Contest%20005/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhiyangfan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhiyangfan 的博客小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/24/AtCoder%20Grand%20Contest%20005/" class="post-title-link" itemprop="url">AtCoder Grand Contest 005</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-01-24 17:00:23 / 修改时间：17:11:26" itemprop="dateCreated datePublished" datetime="2022-01-24T17:00:23+08:00">2022-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="AtCoder-Grand-Contest-005-补题总结"><a href="#AtCoder-Grand-Contest-005-补题总结" class="headerlink" title="AtCoder Grand Contest 005 补题总结"></a>AtCoder Grand Contest 005 补题总结</h2><p>之前做的，忘了订题写总结，但看到 A 题的 WA 我就瞬间想起来我在 A 题卡了五分钟的痛苦了。</p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="A-STring"><a href="#A-STring" class="headerlink" title="A - STring"></a>A - STring</h4><p>给出一个长度为偶数的字符串 $X$，一般的字符是 <code>S</code>，另一半是 <code>T</code>。现在要进行以下操作 $10^{10000}$ 次：</p>
<ul>
<li>去掉最左端的子串 <code>ST</code>，如果没有 <code>ST</code> 这个子串就什么都不做。</li>
</ul>
<p>问这么多次操作后 $X$ 的最终长度。($2\le |X|\le2\times10^5$)</p>
<p>记录一下当前连续 <code>S</code> 个数（去掉 <code>ST</code> 后的连续也算连续），然后直接匹配即可，时间复杂度 $\mathcal{O}(|X|)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>; <span class="keyword">char</span> s[N]; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>); <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s + <span class="number">1</span>), len = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!len &amp;&amp; s[i] == <span class="string">&#x27;T&#x27;</span>) ++ans;</span><br><span class="line">		<span class="keyword">if</span> (s[i] == <span class="string">&#x27;S&#x27;</span>) ++len;</span><br><span class="line">		<span class="keyword">if</span> (len &amp;&amp; s[i] == <span class="string">&#x27;T&#x27;</span>) --len;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans + len); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="B-Minimum-Sum"><a href="#B-Minimum-Sum" class="headerlink" title="B - Minimum Sum"></a>B - Minimum Sum</h4><p>给出一个长为 $n$ 的排列 $\mathcal{P}_1,\mathcal{P}_2,\cdot\cdot\cdot,\mathcal{P}_n$，求：</p>
<script type="math/tex; mode=display">\sum_{l=1}^n\sum_{r=l}^n \min\{\mathcal{P}_l,\mathcal{P}_{l+1},\cdot\cdot\cdot\mathcal{P}_r\}</script><p>($1\le n\le2\times10^5$)</p>
<p>比较经典的问题了。考虑用单调栈维护 $\mathcal{P}_i$ 作为最小值的区间 $(l_i,r_i)$，然后我们分别考虑每个点的贡献。最终答案即为：</p>
<script type="math/tex; mode=display">\sum_{i=1}^n \mathcal{P}_i\times(i-l_i)\times(r_i-i)</script><p>时间复杂度 $\mathcal{O}(n)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>; </span><br><span class="line"><span class="keyword">int</span> a[N], lef[N], rig[N]; std::stack&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">	st.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; a[st.<span class="built_in">top</span>()] &gt; a[i])</span><br><span class="line">			rig[st.<span class="built_in">top</span>()] = i, st.<span class="built_in">pop</span>();</span><br><span class="line">		st.<span class="built_in">push</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) rig[st.<span class="built_in">top</span>()] = n + <span class="number">1</span>, st.<span class="built_in">pop</span>();</span><br><span class="line">	st.<span class="built_in">push</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; a[st.<span class="built_in">top</span>()] &gt; a[i])</span><br><span class="line">			lef[st.<span class="built_in">top</span>()] = i, st.<span class="built_in">pop</span>();</span><br><span class="line">		st.<span class="built_in">push</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) lef[st.<span class="built_in">top</span>()] = <span class="number">0</span>, st.<span class="built_in">pop</span>();</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		ans += <span class="number">1ll</span> * a[i] * (i - lef[i]) * (rig[i] - i);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="C-Tree-Restoring"><a href="#C-Tree-Restoring" class="headerlink" title="C - Tree Restoring"></a>C - Tree Restoring</h4><p>给出一个长为 $n$ 的序列 $a$，要求构造出一棵树，其中对于第 $i$ 个结点，它和距离它最远结点的距离为 $a_i$。（边权均为 $1$）询问这样的树是否存在。($2\le n\le100,1\le a_i\le n-1$)</p>
<p>约定 $dis_{u,v}$ 表示树上 $u,v$ 两点之间的距离。注意到根据题意，如果存在这样一棵树，则它的直径一定为 $\max\{a_i\}$，我们设直径的端点为 $x,y$，则对于任意结点 $u$，显然有：</p>
<script type="math/tex; mode=display">\max_{i=1}^n\{dis_{i,u}\}=a_u=\max\{dis_{i,x},dis_{i,y}\}</script><p>证明可以参考两遍 $\rm dfs$ 求直径方法正确性的证明。则如果我们设直径的长度为 $k$，直径上有 $k+1$ 个点，则根据上面的性质，对于直径上每个点的 $a$，我们显然有如下结论：</p>
<ul>
<li>如果 $k$ 为偶数，则 $a$ 对应的值应为 $\{k,k-1,\cdot\cdot\cdot,\frac{k}{2}+1,\frac{k}{2},\frac{k}{2}+1,\cdot\cdot\cdot,k-1,k\}$。</li>
<li>如果 $k$ 为奇数，则 $a$ 对应的值应为 $\{k,k-1,\cdot\cdot\cdot,\frac{k+1}{2}+1,\frac{k+1}{2},\frac{k+1}{2},\frac{k+1}{2}+1,\cdot\cdot\cdot,k-1,k\}$。</li>
</ul>
<p>则对于给出的数据，我们可以先去掉满足这些条件的值，也就是直径上的点对应的 $a$，如果无法完成，则不存在这样的树。而对于去掉之后剩余的点 $u$，如果 $k$ 为偶数，则 $a_u$ 应至少为 $\frac{k}{2}+1$，如果为奇数，则至少为 $\frac{k+1}{2}+1$。（可以通过直接接到直径的中点达到最小值，而只需要选路径上一个合适的点加一个相邻的点就能构造出剩下的情况了）我们只需要看一下剩下的 $a_u$ 是否都满足以上条件即可。时间复杂度 $\mathcal{O}(n)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> f[<span class="number">200</span>], a[<span class="number">200</span>], Max, Min = <span class="number">200</span>, n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> Max)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = (Max + <span class="number">1</span>) / <span class="number">2</span> + <span class="number">1</span>; i &lt;= Max; ++i)</span><br><span class="line">		<span class="keyword">if</span> (f[i] &lt; <span class="number">2</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;Impossible\n&quot;</span>); <span class="keyword">return</span> ; &#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Possible\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]); ++f[a[i]];</span><br><span class="line">		Max = std::<span class="built_in">max</span>(Max, a[i]);</span><br><span class="line">		Min = std::<span class="built_in">min</span>(Min, a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (Min &lt; (Max + <span class="number">1</span>) / <span class="number">2</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;Impossible\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">	<span class="keyword">if</span> (Max &amp; <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (f[(Max + <span class="number">1</span>) / <span class="number">2</span>] != <span class="number">2</span>) </span><br><span class="line">		&#123; <span class="built_in">printf</span>(<span class="string">&quot;Impossible\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">		<span class="built_in">check</span>(Max);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (f[Max / <span class="number">2</span>] != <span class="number">1</span>) </span><br><span class="line">		&#123; <span class="built_in">printf</span>(<span class="string">&quot;Impossible\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">		<span class="built_in">check</span>(Max);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="D-K-Perm-Counting"><a href="#D-K-Perm-Counting" class="headerlink" title="D - ~K Perm Counting"></a>D - ~K Perm Counting</h4><p>我们定义一个长度为 $n$ 的排列 $\mathcal{P}$ 是好的，当且仅当对于所有所有 $1\le i\le n$，都有 $|\mathcal{P_i}-i|\ne k$，其中 $k$ 为给定常数。问在所有可能的 $n!$ 个排列中，有多少排列是好的，答案对 $924,844,033$ 取模。($2\le n\le2\times10^3,1\le k\le n-1$)</p>
<p>考虑用一个二分图去对应这个排列，即左部点 $\{L_1,L_2,\cdot\cdot\cdot,L_n\}$ 和右部点 $\{R_1,R_2,\cdot\cdot\cdot,R_n\}$ 组成的二分图，显然图上的一个完美匹配会对应一个排列，具体来讲，排列 $\mathcal{P}$ 会对应边集 $\{(L_i,R_{\mathcal{P}_i})\}$。而本题的目标就是求不用边集 $\{(L_i,R_{i+k})\}$ 和 $\{(L_i,R_{i-k})\}$ 中的边能形成的完美匹配个数。</p>
<p>好了，我们一看「不用」这个字眼已经可以考虑容斥了。考虑设 $M_i$ 表示钦定 $i$ 个 $L_i$ 连出去的边在那两个边集内，则最终答案即为：</p>
<script type="math/tex; mode=display">\sum_{i=0}^n (-1)^iM_i(n-i)!</script><p>其中前面是简单的容斥，$(n-i)!$ 是因为除了那些匹配其他随便选。接下来问题就变为了求出 $M_i$。这个就比较简单了，可以直接 $\mathcal{O}(n^2)$ 递推解决（如果不会了的话去看洛谷题解第一篇，感觉会比我写下来清楚），利用多项式科技还可以达到 $\mathcal{O}(n\log n)$ 的复杂度，但比较复杂。这里实现的是 $\mathcal{O}(n^2)$ 的 $\rm dp$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e3</span> + <span class="number">10</span>, mod = <span class="number">924844033</span>; <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, k, ans, tot, a[N], fac[N], f[N &lt;&lt; <span class="number">1</span>][N][<span class="number">2</span>], vis[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k); fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fac[i] = (ll)fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; <span class="number">2</span>; ++t)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j += k) ++tot, (i != j) ? (vis[tot] = <span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= (n &lt;&lt; <span class="number">1</span>); ++i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; ++j)</span><br><span class="line">		&#123;	</span><br><span class="line">			<span class="keyword">if</span> (vis[i] &amp;&amp; j) f[i][j][<span class="number">1</span>] = f[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">			f[i][j][<span class="number">0</span>] = (f[i - <span class="number">1</span>][j][<span class="number">0</span>] + f[i - <span class="number">1</span>][j][<span class="number">1</span>]) % mod;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (i &amp; <span class="number">1</span>) ans = (ans - (ll)fac[n - i] * (f[n &lt;&lt; <span class="number">1</span>][i][<span class="number">0</span>] + f[n &lt;&lt; <span class="number">1</span>][i][<span class="number">1</span>]) + mod) % mod;</span><br><span class="line">		<span class="keyword">else</span> ans = (ans + (ll)fac[n - i] * (f[n &lt;&lt; <span class="number">1</span>][i][<span class="number">0</span>] + f[n &lt;&lt; <span class="number">1</span>][i][<span class="number">1</span>])) % mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans); <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="E-Sugigma-The-Showdown"><a href="#E-Sugigma-The-Showdown" class="headerlink" title="E - Sugigma: The Showdown"></a>E - Sugigma: The Showdown</h4><p>两个人在一棵 $n$ 个结点的图上做游戏，一开始先手的棋子在 $X$，后手的棋子在 $Y$。这张图上有 $n-1$ 条蓝边和 $n-1$ 条红边。每种颜色的边和图上的 $n$ 个点都构成一棵树。先后手轮流操作，每次操作先手可以把棋子移动到一个由红边连接的相邻结点或选择不动，后手可以把棋子移动到一个由蓝边连接的相邻结点或选择不动，当两个棋子相遇时游戏结束。先手的目标是最大化游戏轮次，后手的目标是最小化游戏轮次，问在二人都采取最优策略的情况下，游戏的轮数是否有限，如果有限，求出游戏轮数。($2\le n\le2\times10^5$)</p>
<p>神仙博弈论Orz。首先我们先来解释一下题意，先后手各有一棵点集相同的树，先手从 $X$ 出发使用红树尝试逃脱后手从 $Y$ 出发使用蓝树的追捕。约定 $dis_r(u,v)$ 表示在红树上 $u,v$ 点之间的距离，$dis_b(u,v)$ 表示在蓝树上 $u,v$ 点之间的距离。如果存在这样的 $u,v$ 满足 $dis_r(u,v)=1$ 且 $dis_b(u,v)\ge3$，则当先手到达 $u,v$ 中的任意一个结点且后手不能在这之后立即抓到他，游戏就可以一直进行下去了，即先手就可以一直逃脱后手的抓捕了。不妨设先手到的是 $u$，则他可以一直在那等直到后手追到一个与 $u$ 在蓝树上相邻的结点 $x$，这时他就会去 $v$，而因为 $dis_b(x,u)=1,dis_b(u,v)\ge3$，所以有 $dis_b(x,v)\ge 2$，后手不能一步追上先手。之后先手就可以一直这样在 $u,v$ 之间反复横跳来逃避抓捕，所以此时游戏轮数是无限的。我们称 $u,v$ 之间的红边为长边。</p>
<p>有了这个结论后，我们再来审视一下原题面给出的树。我们把蓝树考虑为一棵以 $Y$ 为根的有根树，而其中长边两端的点是特殊的，因为如果先手到达这些点且后手不能立即捉到他游戏就会无限进行，除了长边，红边还有短边，满足 $dis_r(u,v)=1,dis_b(u,v)\le 2$。我们可以把这些红边看做一次跳跃，现在问题就变为了在一棵有根树上的问题，先手在这些短边上跳跃尝试去走到特殊点或尝试去逃离后手的抓捕。一个非常重要的发现是，先手永远不会跳过后手，因为跳跃的最远距离是 $2$，所以最后到达的点一定会和后手相邻，下一轮就会被抓到。也就是说，先手一定会一直在后手所在的子树内。显然后手的最优策略是一直朝着先手的方向往下走，而如果这样先手一旦到达一个满足 $dis_b(Y,x)\le t$ 的结点 $x$ 用了 $t$ 步，就会被抓到。反之，如果先手一直尽量保持 $dis_b(Y,x)&gt;t$ 就不会被抓住，这就是他的最优策略。</p>
<p>这样，游戏就可以理解为先手的单人游戏了。他到达的第 $i$ 个结点 $u_i$（$u_0=X$）应满足 $dis_b(u_i,Y)&gt;i$，在这个限制下，如果他能到达某个特殊结点则游戏轮数就为无限，否则答案即为可能的路径中的最长路径长度。这些都可以用一次 $\rm dfs$ 求出，时间复杂度 $\mathcal{O}(n)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>; std::vector&lt;<span class="keyword">int</span>&gt; R[N], B[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span> <span class="keyword">int</span> u, v; &#125;e[N]; <span class="keyword">int</span> n, x, y, ans, depr[N], depb[N], fa[N], vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfsB</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	fa[u] = f;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, v; i &lt; B[u].<span class="built_in">size</span>(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		v = B[u][i]; <span class="keyword">if</span> (v == f) <span class="keyword">continue</span>;</span><br><span class="line">		depb[v] = depb[u] + <span class="number">1</span>; <span class="built_in">dfsB</span>(v, u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfsR</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (vis[u]) <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>), <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	ans = std::<span class="built_in">max</span>(ans, depb[u]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, v; i &lt; R[u].<span class="built_in">size</span>(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		v = R[u][i]; <span class="keyword">if</span> (v == f) <span class="keyword">continue</span>;</span><br><span class="line">		depr[v] = depr[u] + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (depr[v] &lt; depb[v]) <span class="built_in">dfsR</span>(v, u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (depb[u] &lt; depb[v]) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">	<span class="keyword">if</span> (depb[u] == depb[v]) </span><br><span class="line">	&#123;	</span><br><span class="line">		<span class="keyword">if</span> (fa[u] != fa[v]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (depb[u] == depb[v] + <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (fa[u] != v) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (depb[u] == depb[v] + <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (fa[fa[u]] != v) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;x, &amp;y);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">		R[u].<span class="built_in">push_back</span>(v); R[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">		e[i].u = u; e[i].v = v;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">		B[u].<span class="built_in">push_back</span>(v); B[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfsB</span>(y, y);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		u = e[i].u; v = e[i].v;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">check</span>(u, v)) vis[u] = vis[v] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfsR</span>(x, x); <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans &lt;&lt; <span class="number">1</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="F-Many-Easy-Problems"><a href="#F-Many-Easy-Problems" class="headerlink" title="F - Many Easy Problems"></a>F - Many Easy Problems</h4><p>给出一棵 $n$ 个结点的无根树，我们定义 $f_i$ 表示对于所有大小为 $i$ 的点集，能包含住它的最小连通块大小之和。对于 $1\le i\le n$ 求出 $f_i$，答案对 $924,844,033$ 取模。($2\le n\le2\times10^5$)</p>
<p>这题有三处非常神仙的转化。我们要发现直接求是无法求的，要考虑每个结点 $u$ 对 $f_i$ 的贡献，而且还需要一点补集转化。也就是选择的总方案数减去没 $u$ 的事的方案。显然当选中的所有结点均在 $u$ 的一个子树内时没 $u$ 的事，所以 $u$ 对 $f_i$ 的贡献即为 $\binom{n}{i}-\sum_{v\in son_u}\binom{sz_v}{i}$，其中 $sz_v$ 表示以 $v$ 为根的子树大小。则 $f_i$ 就可以表示为：</p>
<script type="math/tex; mode=display">\begin{aligned}f_i&=\sum_{u=1}^n\left(\dbinom{n}{i}-\sum_{v\in son_u}\dbinom{sz_v}{i}\right)\\&=n\dbinom{n}{i}-\sum_{u=1}^n\sum_{v\in son_u}\dbinom{sz_v}{i}\end{aligned}</script><p>前面那一项已经可以 $\mathcal{O}(1)$ 求了，但想求后面那项还得费点功夫。发现后面其实就是统计所有子树的大小，所以我们考虑设 $cnt_i$ 表示大小为 $i$ 的子树数量的个数，注意这里包括上文的 $u$ 的子树意义为以 $u$ 为根时。则 $f_i$ 又可以转化为：</p>
<script type="math/tex; mode=display">\begin{aligned}f_i&=n\dbinom{n}{i}-\sum_{j=i}^n cnt_j\dbinom{j}{i}\\&=n\dbinom{n}{i}-\dfrac{1}{i!}\sum_{j=i}^n \dfrac{cnt_j\times j!}{(j-i)!}\end{aligned}</script><p>这里后面又没法搞了，还是需要一点转化，考虑设 $F_i=cnt_i\times i!,G_i=\dfrac{1}{i!}$，则 $f_i$ 为：</p>
<script type="math/tex; mode=display">\begin{aligned}f_i&=n\dbinom{n}{i}-\dfrac{1}{i!}\sum_{j=i}^n F_jG_{j-i}\\&=n\dbinom{n}{i}-\dfrac{1}{i!}\sum_{j=0}^{n-i}F_{i+j}G_j\end{aligned}</script><p>后面已经非常非常接近卷积了，我们只需要令 $H_i=F_{n-i}$，就有：</p>
<script type="math/tex; mode=display">f_i=n\dbinom{n}{i}-\dfrac{1}{i!}\sum_{j=0}^{n-i} H_{n-i-j}G_j</script><p>搞定，后面已经是卷积的形式了。可以直接上 $\rm NTT$ 了，但注意题目给的质数不是常见的 $998,244,353$ 而是 $924,844,033$，不过差不多，只是要注意题目里的这个原根是 $5$。卷出来之后直接套式子就能得到答案了，时间复杂度 $\mathcal{O}(n\log n)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>, mod = <span class="number">924844033</span>; <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span> <span class="keyword">int</span> v, next; &#125;E[N &lt;&lt; <span class="number">1</span>]; <span class="keyword">int</span> p[N], tot;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(p, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span> (p)); tot = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123; E[tot].v = v; E[tot].next = p[u]; p[u] = tot++; &#125;</span><br><span class="line"><span class="keyword">int</span> cnt[N], size[N], fac[N], ifac[N], rev[N &lt;&lt; <span class="number">2</span>], F[N &lt;&lt; <span class="number">2</span>], G[N &lt;&lt; <span class="number">2</span>], n;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ksm</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = (ll)ret * a % mod;</span><br><span class="line">		a = (ll)a * a % mod; b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	size[u] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = p[u], v; i + <span class="number">1</span>; i = E[i].next)</span><br><span class="line">	&#123;</span><br><span class="line">		v = E[i].v; <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(v, u); size[u] += size[v]; ++cnt[size[v]];</span><br><span class="line">	&#125;</span><br><span class="line">	++cnt[n - size[u]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123; <span class="keyword">return</span> (ll)fac[n] * ifac[m] % mod * ifac[n - m] % mod; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span>* c, <span class="keyword">int</span> len, <span class="keyword">int</span> on)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">		<span class="keyword">if</span> (i &lt; rev[i]) std::<span class="built_in">swap</span>(c[i], c[rev[i]]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">2</span>; h &lt;= len; h &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> gn = <span class="built_in">ksm</span>(<span class="number">5</span>, (mod - <span class="number">1</span>) / h); <span class="keyword">if</span> (on == <span class="number">-1</span>) gn = <span class="built_in">ksm</span>(gn, mod - <span class="number">2</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j += h)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> g = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; j + h / <span class="number">2</span>; ++k, g = (ll)g * gn % mod)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> u = c[k], t = (ll)g * c[k + h / <span class="number">2</span>] % mod;</span><br><span class="line">				c[k] = (u + t) % mod; c[k + h / <span class="number">2</span>] = (u - t + mod) % mod;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (on == <span class="number">-1</span>) &#123; <span class="keyword">int</span> inv = <span class="built_in">ksm</span>(len, mod - <span class="number">2</span>); <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) c[i] = (ll)c[i] * inv % mod; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="built_in">init</span>(); <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y), <span class="built_in">insert</span>(x, y), <span class="built_in">insert</span>(y, x);</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>); fac[<span class="number">0</span>] = ifac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fac[i] = (ll)fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">	ifac[n] = <span class="built_in">ksm</span>(fac[n], mod - <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i) ifac[i] = (ll)ifac[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) F[i] = (ll)cnt[i] * fac[i] % mod;</span><br><span class="line">	std::<span class="built_in">reverse</span>(F, F + n + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) G[i] = ifac[i];</span><br><span class="line">	<span class="keyword">int</span> limit = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (limit &lt;= (n &lt;&lt; <span class="number">1</span>)) limit &lt;&lt;= <span class="number">1</span>, ++l;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; ++i) rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l - <span class="number">1</span>));</span><br><span class="line">	<span class="built_in">NTT</span>(F, limit, <span class="number">1</span>); <span class="built_in">NTT</span>(G, limit, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; ++i) F[i] = (ll)F[i] * G[i] % mod;</span><br><span class="line">	<span class="built_in">NTT</span>(F, limit, <span class="number">-1</span>); std::<span class="built_in">reverse</span>(F, F + n + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (<span class="keyword">int</span>)(((ll)n * <span class="built_in">C</span>(n, i) % mod - (ll)ifac[i] * F[i] % mod + mod) % mod));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhiyangfan1234.github.io/2022/01/24/AtCoder%20Grand%20Contest%20006/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhiyangfan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhiyangfan 的博客小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/24/AtCoder%20Grand%20Contest%20006/" class="post-title-link" itemprop="url">AtCoder Grand Contest 006</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-01-24 17:00:23 / 修改时间：17:11:23" itemprop="dateCreated datePublished" datetime="2022-01-24T17:00:23+08:00">2022-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="AtCoder-Grand-Contest-006补题总结"><a href="#AtCoder-Grand-Contest-006补题总结" class="headerlink" title="AtCoder Grand Contest 006补题总结"></a>AtCoder Grand Contest 006补题总结</h2><p><del>突然发现 AGC004,AGC005 不知道为啥被我跳过去了，还得回头补。</del>  这把的难度就感觉比之前的 CODE FESITIVAL 要大，我只做到 C 题。</p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="A-Prefix-and-Suffix"><a href="#A-Prefix-and-Suffix" class="headerlink" title="A - Prefix and Suffix"></a>A - Prefix and Suffix</h4><p>给出两个长为 $n$ 的字符串 $s,t$，求出满足前 $n$ 个字符为 $s$，后 $n$ 个字符为 $t$ 的字符串中长度最小的字符串长为多少。($1\le n\le100$)</p>
<p>设这个字符串为 $S$，则一定有 $|S|\le 2n$，其中小于的部分是 $s,t$ 共用了一些字符。所以我们只需要求出 $s,t$ 能共用字符的最大值即可。直接枚举长度然后判断即可，时间复杂度 $\mathcal{O}(n^2)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">110</span>], t[<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, flag, cnt; <span class="built_in">scanf</span>(<span class="string">&quot;%d%s%s&quot;</span>, &amp;n, s + <span class="number">1</span>, t + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        flag = <span class="number">1</span>; cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n - i + <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            <span class="keyword">if</span> (s[j] != t[j + i - n]) &#123; flag = <span class="number">0</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123; <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n + n - i); <span class="keyword">break</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="B-Median-Pyramid-Easy"><a href="#B-Median-Pyramid-Easy" class="headerlink" title="B - Median Pyramid Easy"></a>B - Median Pyramid Easy</h4><p>给出一个 $n$ 层的方格金字塔，其中从上到下分别为第 $1$ 到 $n$ 层。第 $i$ 层有 $2i-1$ 个方格，具体形态如下：</p>
<p><img src="https://cdn.luogu.com.cn/upload/vjudge_pic/AT2163/a992c42b0e9b0597f104bf82a0adc1131324bb4f.png" alt=""></p>
<p>第 $n$ 层有一个 $1$ 到 $2n-1$ 的排列，其余位置的数字是它正下方，右下方和左下方方格中的三个数字里排名第二的数。现在给出一个数字 $x$，求出第 $n$ 层一个可能的排列方式，使得第一层的数字是 $x$。($2\le n\le10^5$)</p>
<p>首先能注意到的是，当 $x=1$ 或 $x=2n-1$ 时，显然无解，因为它们是排列里面的极小，极大值，在除了第 $n$ 层之外的地方都不可能出现。而对于有解的 $x$，考虑在这两个位置为 $x$：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/rmo7jvaf.png" alt=""></p>
<p>则画图可以发现，这些位置均为 $x$：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/5wa47hit.png" alt=""></p>
<p>所以如果我们想构造出来最上面一层为 $x$ 的情况，只需要让第 $n-1$ 层的中间和右边一格为 $x$ 即可。这个可以通过令第 $n$ 层的排列为 $(\cdot\cdot\cdot,x-1,x,x+1,x-2,\cdot\cdot\cdot)$ 轻松构造，注意当 $x=2$ 时，排列应为 $(\cdot\cdot\cdot,x-1,x,x+1,x+2,\cdot\cdot\cdot)$。时间复杂度 $\mathcal{O}(n)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>; <span class="keyword">int</span> a[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, x; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;x);</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1</span> || x == <span class="number">2</span> * n - <span class="number">1</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">    a[n] = x; a[n - <span class="number">1</span>] = x - <span class="number">1</span>; a[n + <span class="number">1</span>] = x + <span class="number">1</span>; <span class="keyword">int</span> now = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">2</span>) now = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n - <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i]) <span class="keyword">continue</span>;</span><br><span class="line">        a[i] = now; ++now; </span><br><span class="line">        <span class="keyword">if</span> (now + <span class="number">1</span> == x) now += <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n - <span class="number">1</span>; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="C-Rabbit-Exercise"><a href="#C-Rabbit-Exercise" class="headerlink" title="C - Rabbit Exercise"></a>C - Rabbit Exercise</h4><p>一行上面有 $n$ 只兔子，分别从 $1$ 到 $n$ 编号，编号为 $i$ 的兔子初始位置为 $x_i$。兔子们要执行一段操作。一段操作以一个长为 $m$ 的操作序列 $a$ 描述，其中 $a_i(2\le a_i\le n-1)$ 表示这次操作由兔子 $a_i$ 执行，它会等概率选择兔子 $a_i-1$ 和 $a_i+1$ 中的一个，并跳到以它为对称中心和现在的位置中心对称的位置。现在给出初始位置和兔子们执行这段操作的次数 $k$，求出所有兔子最终的期望位置。($3\le n\le10^5,|x_i|\in\{x\in \mathbf{Z}||x|\le10^9\},1\le m\le10^5,1\le k\le10^{18}$)</p>
<p>首先有一个显然的结论，也就是执行完一个操作后，$a_i$ 号兔子所在期望位置就会变为：</p>
<script type="math/tex; mode=display">E(a_i)=\dfrac{1}{2}(2E(a_i-1)-E(a_i))+\dfrac{1}{2}(2E(a_i+1)-E(a_i))</script><p>但如果直接按照这个式子递推，您将会收获一个 $\tt TLE$ 和 5 分钟的罚时。所以我们考虑变一变这个式子，稍微合并一下有：</p>
<script type="math/tex; mode=display">E(a_i)=E(a_i-1)+E(a_i+1)-E(a_i)</script><p>好了如果你没有灵光乍现这题也就到此为止了，但如果你发现原序列的差分序列在这样一次操作后会有很神奇的变化，这题也就到此为止了，如果我们令 $d_i=E(a_i)-E(a_i-1)$，则有：</p>
<script type="math/tex; mode=display">d_i=E(a_i)-E(a_i-1)=E(a_i+1)-E(a_i)</script><script type="math/tex; mode=display">d_{i+1}=E(a_i+1)-E(a_i)=E(a_i)-E(a_i-1)</script><p>可以观察到，$d_i$ 和 $d_{i+1}$ 在一次操作的前后交换了位置，利用这个性质，我们可以求出一段操作后，差分序列的每个位置会跑到哪去，注意到执行 $k$ 次其实是个循环的过程，所以我们就可以找到循环节直接做了。这个循环节其实可以理解为置换环的大小，比如每次操作有 $1\rightarrow2,2\rightarrow4,4\rightarrow1$，则置换环如下图：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/oult3tr1.png" alt=""></p>
<p>每次操作其实就是在置换环上走一步。求置换环的部分用个栈记录一下就好了，具体实现见代码，时间复杂度 $\mathcal{O}(m+n)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> id[N], vis[N], st[N], tp; <span class="keyword">double</span> x[N], d[N], dd[N]; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;x[i]), d[i] = x[i] - x[i - <span class="number">1</span>], id[i] = i;</span><br><span class="line">    <span class="keyword">int</span> m; <span class="keyword">long</span> <span class="keyword">long</span> k; <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>, &amp;m, &amp;k); <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a; i &lt;= m; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a), std::<span class="built_in">swap</span>(id[a], id[a + <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>; tp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; !vis[j]; j = id[j]) vis[j] = <span class="number">1</span>, st[++tp] = j;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tp; ++j) dd[st[j]] = d[st[(k + j - <span class="number">1</span>) % tp + <span class="number">1</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) dd[i] += dd[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%.1lf\n&quot;</span>, dd[i]); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="D-Median-Pyramid-Hard"><a href="#D-Median-Pyramid-Hard" class="headerlink" title="D - Median Pyramid Hard"></a>D - Median Pyramid Hard</h4><p>题目背景同 B。只不过这一次给出了 $1$ 到 $2n-1$ 的排列，需要求出第 $1$ 层的数 $x$。($2\le n\le10^5$)</p>
<p><del>总觉得最近至少做了三道这种类型的题，但这次还是没做出来</del></p>
<p>非常妙的思想，我甚至不知道怎么才能恰当的引入二分这个思想。只能说朴素的算法是 $\mathcal{O}(n^2)$ 而很难再优化，所以考虑转化为判断性问题，并尝试在 $\mathcal{O}(n)$ 的时间复杂度内判断可行性，这样就可以做到最终 $\mathcal{O}(n\log n)$ 的复杂度了。考虑判断最终答案与 $x$ 的大小关系，注意到题目关心的是数的大小关系而不是实际的数，所以我们把排列中所有小于 $x$ 的数变为 $0$，所有大于等于 $x$ 的数变为 $1$。这样一个格子里面填入的数就是它的下面三格中数量比较多的那个数，具体来讲，见下图：</p>
<p><img src="https://cdn.luogu.com.cn/upload/pic/28097.png" alt=""></p>
<p>我们最终的目标就是判断最上面的数是 $0$ 还是 $1$，通过这个来找到最终答案和 $x$ 的大小关系。注意到图中的连续 $0$ 和连续 $1$ 会把每一层的这一部分变成连续 $0$ 或连续 $1$，而交替 $1,0$ 会形成一个 V 字结构。而当不同的结构两两相遇时，它们就会停下。根据这个性质，我们可以发现第 $1$ 层的元素其实是连续 $0$ 和连续 $1$ “比赛”谁先到顶端的结果，换句话说，也就是哪个离中心近顶端就是哪个。那有没有可能一样近呢，<del>显然没有</del> 因为底端的长度是奇数，如果连续段距离中心一样近，中间的交替段长度一定是奇数，也就是说交替段的两边一定相同，总会有一边和相邻的连续段形成更长的连续段从而导致距离不同的。这样这题就做完了，注意特判两位选手都不在的情况，即底端是全交替的情况，此时顶层的元素即为底层最左右端的元素。最终时间复杂度 $\mathcal{O}(n\log n)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>; <span class="keyword">int</span> a[N &lt;&lt; <span class="number">1</span>], b[N &lt;&lt; <span class="number">1</span>], n;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (n &lt;&lt; <span class="number">1</span>); ++i) b[i] = (a[i] &gt;= x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b[n + i] == b[n + i + <span class="number">1</span>]) <span class="keyword">return</span> b[n + i];</span><br><span class="line">        <span class="keyword">if</span> (b[n - i] == b[n - i - <span class="number">1</span>]) <span class="keyword">return</span> b[n - i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b[(n &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (n &lt;&lt; <span class="number">1</span>); ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = (n &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>, mid, ans;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) ans = mid, l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="E-Rotate-3x3"><a href="#E-Rotate-3x3" class="headerlink" title="E - Rotate 3x3"></a>E - Rotate 3x3</h4><p>给出一个 $3$ 行 $n$ 列的表格，其中 $(i,j)$ 位置的初始值为 $i+3\times j-3$。可以把其中任意的 $3\times 3$ 的格子旋转 $180^\circ$。给出一个 $3\times n$ 的表格，求是否能通过初始表格执行任意上述旋转操作得到这个表格。($5\le n\le10^5$)</p>
<p>思维神题orz，不知道为啥学长之前写的写法比我照着题解写的少一个 $\log$。首先我们把旋转操作转化一下就是交换相隔的两列，并把这两列和它们中间的那一列上下颠倒。我们可以通过这个性质排除掉一些很傻的情况，首先这么交换每一列的数跟初始时不会有变化，只是可能会颠倒顺序，其次因为交换是相隔交换，所以每一列所在的列奇偶性不会变化。具体来讲，对于任意非负整数 $l$，$6l+1,6l+2,6l+3$ 一定一直在奇数列中，$6l+4,6l+5,6l+6$ 一定一直在偶数列中。显然这个条件是必要条件，但它充分吗？打表 <del>（或者随便猜一下这题不可能这么简单）</del> 可以发现，对于 $n=10$ 的情况，通过初始状态一共可以得到 $368,6400$ 种情况，而通过上述过程的计算，我们能得到 $120 \times 120 \times 2^{10} = 1474,5600$ 种情况（数据来自 AT 题解），容易发现多了 $4$ 倍，说明我们刚刚讨论出来的条件只是必要不充分条件。</p>
<p>我们重新审视一下刚刚操作的过程。对于奇数列而言，我们考虑两种操作：交换两个相邻的奇数列，颠倒一个奇数列。显然如果不能通过这两种操作达到最终情况，答案一定是不可能。如果能通过这两种操作达到最终情况，我们就设 $inv_o$ 表示第一种操作操作的次数，$flip_o$ 表示第二种操作操作的次数。注意到我们虽然不能准确确定它们的值，但可以确定奇偶性。考虑第一种操作，如果我们把奇数列按顺序依次从 $1$ 到 $\dfrac{n}{2}$ 编号，则一次操作要么减少一个逆序对，要么增加一个逆序对，均会导致逆序对奇偶性的改变，而同时这一次操作也会改变 $inv_o$ 的奇偶性，所以我们能用最终逆序对的个数奇偶性反映 $inv_o$ 的奇偶性。对于第二种操作，一次操作要么增加一个（与初始状态比较）颠倒的列，要么减少一个颠倒的列，均会导致颠倒列数奇偶性的改变，所以类似地，我们可以用最终颠倒列的数目的奇偶性反映 $flp_o$ 的奇偶性。我们用类似的操作，求出对于偶数列的 $inv_e$ 和 $flp_e$。</p>
<p>求出来之后有什么用呢？注意到每次旋转操作，会导致一下两种结果之一：</p>
<ul>
<li>$inv_o$ 和 $flp_e$ 的奇偶性改变了。</li>
<li>$flp_o$ 和 $inv_e$ 的奇偶性改变了。</li>
</ul>
<p>取决于在哪旋转的。所以最终 $inv_o$ 和 $flp_e$，$flp_o$ 和 $inv_e$ 的奇偶性一定相同。那么这是不是充分条件呢？考虑以下构造（小写字母表示初始顺序，大写字母表示逆序）：</p>
<ul>
<li>$\tt a\ b\ c\ d\ e$ </li>
<li>$\tt c\ B\ a\ d\ e$</li>
<li>$\tt c\ B\ e\ D\ a$</li>
<li>$\tt e\ b\ c\ D\ a$</li>
<li>$\tt e\ b\ a\ d\ c$</li>
<li>$\tt a\ B\ e\ d\ c$</li>
<li>$\color{red}{\tt a\ B\ c\ D\ e}$</li>
<li>$\tt a\ D\ C\ B\ e$</li>
<li>$\tt C\ d\ a\ B\ e$</li>
<li>$\tt C\ B\ A\ d\ e$</li>
<li>$\color{red}{\tt A\ b\ C\ d\ e}$</li>
</ul>
<p>注意到红色的两列，我们可以通过交换和颠倒改变相邻的奇数列或相邻的偶数列的颠倒情况，再加上我们可以交换相邻的两列，所以只要满足以上条件，一定可以构造出相应的方案，充分性得证。最终时间复杂度就是判逆序对的复杂度 $\mathcal{O}(n\log n)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>; <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>][N], b[N], c[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BIT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ll c[N]; <span class="keyword">int</span> len;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>&#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= len; i += <span class="built_in">lowbit</span>(i)) c[i] += v; &#125;</span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; ll ans = <span class="number">0</span>; <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i; i -= <span class="built_in">lowbit</span>(i)) ans += c[i]; <span class="keyword">return</span> ans; &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> lowbit</span></span><br><span class="line">&#125;bit[<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> d[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++i) d[i] = a[i][j] % <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">if</span> (j &amp; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (d[<span class="number">1</span>] == <span class="number">1</span> &amp;&amp; d[<span class="number">2</span>] == <span class="number">2</span> &amp;&amp; d[<span class="number">3</span>] == <span class="number">3</span>)</span><br><span class="line">                b[j] = (a[<span class="number">1</span>][j] - <span class="number">1</span>) / <span class="number">6</span> + <span class="number">1</span>, c[j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (d[<span class="number">1</span>] == <span class="number">3</span> &amp;&amp; d[<span class="number">2</span>] == <span class="number">2</span> &amp;&amp; d[<span class="number">3</span>] == <span class="number">1</span>)</span><br><span class="line">                b[j] = (a[<span class="number">1</span>][j] - <span class="number">3</span>) / <span class="number">6</span> + <span class="number">1</span>, c[j] = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (d[<span class="number">1</span>] == <span class="number">4</span> &amp;&amp; d[<span class="number">2</span>] == <span class="number">5</span> &amp;&amp; d[<span class="number">3</span>] == <span class="number">0</span>)</span><br><span class="line">                b[j] = (a[<span class="number">1</span>][j] - <span class="number">4</span>) / <span class="number">6</span> + <span class="number">1</span>, c[j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (d[<span class="number">1</span>] == <span class="number">0</span> &amp;&amp; d[<span class="number">2</span>] == <span class="number">5</span> &amp;&amp; d[<span class="number">3</span>] == <span class="number">4</span>)</span><br><span class="line">                b[j] = (a[<span class="number">1</span>][j] - <span class="number">6</span>) / <span class="number">6</span> + <span class="number">1</span>, c[j] = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll inv[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;; <span class="keyword">int</span> flp[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;; bit[<span class="number">0</span>].len = bit[<span class="number">1</span>].len = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, d; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        d = i &amp; <span class="number">1</span>; bit[d].<span class="built_in">add</span>(b[i], <span class="number">1</span>);</span><br><span class="line">        inv[d] += bit[d].<span class="built_in">query</span>(n) - bit[d].<span class="built_in">query</span>(b[i]), flp[d] += (c[i] == <span class="number">-1</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    inv[<span class="number">0</span>] %= <span class="number">2</span>; inv[<span class="number">1</span>] %= <span class="number">2</span>; flp[<span class="number">0</span>] %= <span class="number">2</span>; flp[<span class="number">1</span>] %= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (inv[<span class="number">1</span>] == flp[<span class="number">0</span>] &amp;&amp; inv[<span class="number">0</span>] == flp[<span class="number">1</span>]) <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="F-Blackout"><a href="#F-Blackout" class="headerlink" title="F - Blackout"></a>F - Blackout</h4><p>有一个 $n\times n$ 的表格，其中第 $i$ 行第 $j$ 列为 $(i,j)$，其中有 $m$ 个格子为黑色。接下来想根据以下规则把表格里面更多格子涂上黑色：</p>
<ul>
<li>如果格子 $(x,y),(y,z)$ 均为黑色且 $(z,x)$ 为白色，则把 $(z,x)$ 涂上黑色。</li>
</ul>
<p>现在给出初始的 $m$ 个黑色格子，求出最终会有多少格子被涂上黑色。($1\le n,m\le10^5$)</p>
<p>神仙题面，如果直接出图论可能就没这么难了。<del>根据我的吐槽</del>我们考虑把原题面转化成图论问题：</p>
<blockquote>
<p>给出一个 $n$ 个点 $m$ 条边的有向图，如果存在边 $x\rightarrow y,y\rightarrow z$，则加上边 $z\rightarrow x$，可以加边就一直加边，最终图里面会有多少条边？</p>
</blockquote>
<p>显然，不同的弱连通块（也就是不考虑边的方向连通）之间不会相互影响，所以我们可以对每个弱连通块分别统计。以下讨论假设原图弱连通。</p>
<p>（这里是原题解对正解放的引入，虽然我不是很理解为什么要这么引入）我们首先考虑一些特殊情况，比如图是一条链，如果对这张图做上述操作，则我们会发现，最终得到的图上存在一条边 $s\rightarrow t$，当且仅当 $s\equiv t\pmod{3}$。这启发我们这道题肯定跟路径长模 $3$ 有关。</p>
<p>考虑在原图上给每个点打上一个 $\tt A,B,C$ 的其中一个的标记，使得原图满足：</p>
<ul>
<li>对于每一条边 $x\rightarrow y$，对于它端点的标记都有 $\tt A\rightarrow B$，$\tt B\rightarrow C$ 或 $\tt C\rightarrow A$。</li>
</ul>
<p>这样的标记有可能不存在（比如四元环），但一旦存在就是唯一的（排除循环的情况的话）。不管怎么说，我们都可以用 $\rm dfs$ 在 $\mathcal{O}(m)$ 的时间复杂度下打出标记或声明矛盾。接下来根据我们得到的结果会有三种结论，证明下附：</p>
<ul>
<li>当这样的标记不存在时，可以在任意点对直接连边，包括自环</li>
<li>当这样的标记存在，且 $\tt A,B,C$ 标记全部出现了，可以在所有满足 $\tt A\rightarrow B$，$\tt B\rightarrow C$ 和 $\tt C\rightarrow A$ 的点对之间连边，且不能再连其他边。</li>
<li>当这样的标记存在，且 $\tt A,B,C$ 标记没有全部出现，不能在原图的基础上连任何边。</li>
</ul>
<p>根据这些结论我们就可以直接得到结果了，最终时间复杂度即为 $\rm dfs$ 的复杂度 $\mathcal{O}(m)$。</p>
<p>证明（感性理解罢）：</p>
<ol>
<li><strong>当这样的标记存在，且 A,B,C 标记没有全部出现</strong>  如果边 $x\rightarrow y$ 和边 $y\rightarrow z$ 同时存在的话，所有标记应该会全部出现，所以在这种情况下不存在这样的边，你也就无法做任何操作了。</li>
<li><p><strong>当这样的标记存在，且 A,B,C 标记全部出现了</strong>  这种情况下，存在 $x,y,z$ 满足边 $x\rightarrow y$ 和 $y\rightarrow z$ 存在，自然我们可以加 $z\rightarrow x$ 这条边，这样 $x,y,z$ 就会形成一个三角形。假设 $x,y,z$ 的标记分别是 $\tt A,B,C$，则考虑一个点 $v$ 与 $x,y,z$ 中的一个相邻，比如存在边 $v\rightarrow x$，则显然又会形成一个三角形 $v,x,y$。而画图可以发现，$v$ 至少会和 $x,y,z$ 中的两个相邻：</p>
<p> <img src="https://cdn.luogu.com.cn/upload/image_hosting/ihf7ua2y.png" alt=""></p>
<p> 如果我们再考虑一个与 $v$ 相邻的 $w$，我们也能证明 $w$ 至少和 $x,y,z$ 中的两个相邻：</p>
<p> <img src="https://cdn.luogu.com.cn/upload/image_hosting/p2ey80s0.png" alt=""></p>
<p> 一直重复这个过程我们就可以证明任意点都和 $x,y,z$ 中的两个相邻，这样我们就可以在所有满足 $\tt A\rightarrow B$，$\tt B\rightarrow C$ 和 $\tt C\rightarrow A$ 的点对之间连边，且显然不能再连其他边。</p>
</li>
<li><strong>这样的标记不存在时，可以在任意点对直接连边，包括自环</strong>  我们首先证明至少一个自环存在且满足条件，这样剩余的证明跟这个证明就几乎相同了。首先考虑找到一个会引起矛盾的环，这个环一定存在边 $x\rightarrow y$ 和边 $y \rightarrow z$，而我们可以通过加边 $z\rightarrow x$ 来缩小这个环，且这个小的环也会引起矛盾。一直重复这个过程，我们就可以得到一个自环。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span> <span class="keyword">int</span> v, next, w; &#125;E[N &lt;&lt; <span class="number">1</span>]; <span class="keyword">int</span> p[N], cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(p, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span> (p)); cnt = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123; E[cnt].w = w; E[cnt].v = v; E[cnt].next = p[u]; p[u] = cnt++; &#125;</span><br><span class="line"><span class="keyword">int</span> vis[N], tag[N], c[N], col[N], sum, ok, tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[u] = <span class="number">1</span>; ++c[col[u]]; ++sum; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = p[u], v; i + <span class="number">1</span>; i = E[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        v = E[i].v; tot += (E[i].w == <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (!vis[v]) col[v] = (col[u] + E[i].w + <span class="number">3</span>) % <span class="number">3</span>, <span class="built_in">dfs</span>(v);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (col[v] != (col[u] + E[i].w + <span class="number">3</span>) % <span class="number">3</span>) ok = <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>(); <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= m; ++i) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y), <span class="built_in">insert</span>(x, y, <span class="number">1</span>), <span class="built_in">insert</span>(y, x, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>; sum = tot = <span class="number">0</span>; ok = <span class="number">1</span>;</span><br><span class="line">        c[<span class="number">0</span>] = c[<span class="number">1</span>] = c[<span class="number">2</span>] = <span class="number">0</span>; <span class="built_in">dfs</span>(i); </span><br><span class="line">        <span class="keyword">if</span> (!ok) ans += <span class="number">1ll</span> * sum * sum;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c[<span class="number">0</span>] &amp;&amp; c[<span class="number">1</span>] &amp;&amp; c[<span class="number">2</span>]) </span><br><span class="line">            ans += <span class="number">1ll</span> * c[<span class="number">0</span>] * c[<span class="number">1</span>] + <span class="number">1ll</span> * c[<span class="number">0</span>] * c[<span class="number">2</span>] + <span class="number">1ll</span> * c[<span class="number">1</span>] * c[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">else</span> ans += tot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这一把很大程度上运用了转化的思想，比如 C 题中对差分序列的转化（有时候推出来一个式子无从下手可以考虑从差分或前缀和的思想讨论）， D 题中二分后转化为判定性问题的 $0,1$ 转化，E 题中对原操作的转化（对于不熟悉的操作运用这种转化通常是有效的），F 题中对原题目的转化（这种 $10^5\times10^5$ 的表格一看就不是什么应该正常做的题目）。在之后的题目中，如果遇到无从下手的问题，不放发散一下思维，想想有没有熟悉的题目能跟它联系起来或者原题面有没有另一种表述方法 <del>（然后还是不会）</del> ，说不定就茅塞顿开了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhiyangfan1234.github.io/2022/01/24/AtCoder%20Grand%20Contest%20055%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhiyangfan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhiyangfan 的博客小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/24/AtCoder%20Grand%20Contest%20055%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">AtCoder Grand Contest 055</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-01-24 17:00:23 / 修改时间：17:12:05" itemprop="dateCreated datePublished" datetime="2022-01-24T17:00:23+08:00">2022-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="AtCoder-Grand-Contest-055考试总结"><a href="#AtCoder-Grand-Contest-055考试总结" class="headerlink" title="AtCoder Grand Contest 055考试总结"></a>AtCoder Grand Contest 055考试总结</h2><p>有大废物赛时一题没做出来，躺床上不到 20min 想到 $\tt A$ 的正解。然后今天补题，我只有一句感慨：这真的是人类能出出来的题目和做出来的题目吗？？</p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="A-ABC-Identity"><a href="#A-ABC-Identity" class="headerlink" title="A - ABC Identity"></a>A - ABC Identity</h4><p>给出一个长为 $3n$ 的串 $S$，其中恰含有 $n$ 个 <code>A</code>，$n$ 个 <code>B</code> 和 $n$ 个 <code>C</code>。定义一个含有 <code>A</code>，<code>B</code> 和 <code>C</code> 的字符串 $T$ 是好的，当且仅当其满足以下条件：</p>
<ul>
<li>$T$ 的长度是 $3$ 的倍数，记作 $3k$。</li>
<li>$T_1=T_2=\cdot\cdot\cdot=T_k$</li>
<li>$T_{k+1}=T_{k+2}=\cdot\cdot\cdot=T_{2k}$</li>
<li>$T_{2k+1}=T_{2k+2}=\cdot\cdot\cdot=T_{3k}$</li>
<li>$T_1,T_{k+1},T_{2k+1}$ 互不相同。</li>
</ul>
<p>给出一种把 $S$ 划分为至多 $6$ 个子序列的方案，使得每个子序列都是好的，可以证明一定有解。($1\le n\le2\times10^5$)</p>
<p>首先注意到题目里面的限制条件：至多 $6$ 个子序列，可以联想到 $A_3^3=6$，即 <code>A</code>，<code>B</code> 和 <code>C</code> 这三个字符的排列数是 $6$。顺着这个思路，我们发现，如果我们能把 $T_1,T_{k+1},T_{2k+1}$ 分别为 <code>A</code>，<code>B</code> 和 <code>C</code> 的六种排列的六种好的子序列全部取出，则一定能全部取完，即划分为至多 $6$ 个子序列。我最初的思路是二分每种排列的对应的子序列 $k$ 的最长长度，对于二分到的值，完全可以做到 $\mathcal{O}(n)$ 扫一遍判断可行性，顺次取即可。这样取 $6$ 次一定能取完，时间复杂度 $\mathcal{O}(n\log n)$。</p>
<p>当然题解有更优的方法，毕竟六次二分还是太阴间了。题解给出的结论是把串 $S$ 分为 $S_{1..n},S_{n+1..2n},S_{2n+1..3n}$ 三个部分，每次取排列的时候，第一个字符从第一个部分取，以此类推。依然是尽量取最长的，依然能保证取完。题解给的证明没太理解，但我感性理解了一下。其实跟我原来的证明差不多，因为每次取会取尽量多的，取完之后一定不能再取出任何一种排列了，即原串空了。总之，这个方法最终时间复杂度 $\mathcal{O}(n)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">6e5</span> + <span class="number">10</span>, to[<span class="number">6</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>&#125;, &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">char</span> s[N]; <span class="keyword">int</span> col[N], cnt[<span class="number">3</span>], n;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cnt[<span class="number">0</span>] = cnt[<span class="number">1</span>] = cnt[<span class="number">2</span>] = <span class="number">0</span>; <span class="keyword">int</span> now = <span class="number">1</span>; <span class="comment">//cnt 找到每个部分里面对应字符的数量</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; <span class="number">3</span>; ++d, now += n)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = now; i &lt;= now + n - <span class="number">1</span>; ++i) </span><br><span class="line">			<span class="keyword">if</span> (s[i] == to[id][d] + <span class="string">&#x27;A&#x27;</span> &amp;&amp; !col[i]) ++cnt[d];</span><br><span class="line">    <span class="comment">//取个 min 就是要取的长度</span></span><br><span class="line">	<span class="keyword">int</span> len = std::<span class="built_in">min</span>(std::<span class="built_in">min</span>(cnt[<span class="number">0</span>], cnt[<span class="number">1</span>]), cnt[<span class="number">2</span>]); now = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//直接线性找，找到染色</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>, cnt = <span class="number">0</span>; d &lt; <span class="number">3</span>; ++d, now += n, cnt = <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = now; i &lt;= now + n - <span class="number">1</span>; ++i)</span><br><span class="line">			<span class="keyword">if</span> (cnt &lt; len &amp;&amp; !col[i] &amp;&amp; s[i] == to[id][d] + <span class="string">&#x27;A&#x27;</span>) ++cnt, col[i] = id + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>, &amp;n, s + <span class="number">1</span>); <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) <span class="built_in">work</span>(i); </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">3</span>; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, col[i]); </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="B-ABC-Supremacy"><a href="#B-ABC-Supremacy" class="headerlink" title="B - ABC Supremacy"></a>B - ABC Supremacy</h4><p>给出一个只含有 <code>A</code>，<code>B</code> 和 <code>C</code> 的长度为 $n$ 的字符串 $S$ 和 $T$，你可以做任意次以下操作：</p>
<ul>
<li>选择任意满足 $S_iS_{i+1}S_{i+2}(1\le i\le n-2)$ 为 <code>ABC</code>，<code>BCA</code> 或 <code>CAB</code> 的 $i$，把这三个字符换为 <code>ABC</code>，<code>BCA</code> 或 <code>CAB</code>。</li>
</ul>
<p>求是否能通过若干次操作把 $S$ 变为 $T$。($3\le n\le3\times10^5$)</p>
<p>因为 <code>ABC</code>，<code>BCA</code> 和 <code>CAB</code> 这仨形式不是很好看，我们想把它们变整齐一点。考虑对原串中第 $i$ 个字符做 $i$ 次以下变换：</p>
<ul>
<li><code>A</code> $\rightarrow$ <code>B</code> $\rightarrow$ <code>C</code> $\rightarrow$ <code>A</code></li>
</ul>
<p>则容易发现，原来的仨形式会变为 <code>AAA</code>，<code>BBB</code> 和 <code>CCC</code>。这样，我们可以做以下操作：</p>
<ul>
<li><code>YYYX</code> $\rightarrow$ <code>XXXX</code> $\rightarrow$ <code>XZZZ</code></li>
</ul>
<p>也就是说，我们可以删掉任意三个连续相同的字符，然后在任意地方插入任意三个连续的相同字符。由这个性质，我们可以想到比较 $S$ 和 $T$ 删除所有连续三个相同字符剩下的字符串，因为这些是不能被改变的。但随之而来的问题是，删除所有三个连续字符剩下的字符串一定相同吗？或者说，不同的删除顺序或删除方法会不会有不同的结果，这样我们就无法比较了？注意到，对于串 $S$，如果其对应的所有字符不相交，则挨个删除显然不会改变最后剩下来的东西，如果相交，则显然可以通过上述方法改变把相交部分变成一个连续相同字母段，这样不管怎么删除剩下来的东西也一定相同。所以不同的删除顺序并不会影响最终结果。这样，我们就证明完了，求剩下的字符串可以用个栈模拟一下，最终时间复杂度 $\mathcal{O}(n)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">10</span>, nxt[<span class="number">3</span>] = &#123;<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>&#125;; </span><br><span class="line"><span class="keyword">char</span> s[N], t[N]; <span class="keyword">int</span> st1[N], tp1, st2[N], tp2;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d%s%s&quot;</span>, &amp;n, s + <span class="number">1</span>, t + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> flag = <span class="number">1</span>, k = <span class="number">0</span>, c = s[i] - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">		<span class="keyword">while</span> (k &lt; (i % <span class="number">3</span>)) c = nxt[c], ++k; st1[++tp1] = c;</span><br><span class="line">		<span class="keyword">if</span> (tp1 &lt; <span class="number">3</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = tp1; j &gt;= tp1 - <span class="number">1</span> &amp;&amp; flag; --j)</span><br><span class="line">			<span class="keyword">if</span> (st1[j] != st1[j - <span class="number">1</span>]) flag = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (flag) tp1 -= <span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> flag = <span class="number">1</span>, k = <span class="number">0</span>, c = t[i] - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">		<span class="keyword">while</span> (k &lt; (i % <span class="number">3</span>)) c = nxt[c], ++k; st2[++tp2] = c;</span><br><span class="line">;		<span class="keyword">if</span> (tp2 &lt; <span class="number">3</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = tp2; j &gt;= tp2 - <span class="number">1</span> &amp;&amp; flag; --j)</span><br><span class="line">			<span class="keyword">if</span> (st2[j] != st2[j - <span class="number">1</span>]) flag = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (flag) tp2 -= <span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (tp1 != tp2) &#123; <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tp1 &amp;&amp; flag; ++i)</span><br><span class="line">		<span class="keyword">if</span> (st1[i] != st2[i]) flag = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, flag ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="C-Weird-LIS"><a href="#C-Weird-LIS" class="headerlink" title="C - Weird LIS"></a>C - Weird LIS</h4><p>qwq，$\tt \color{black}x\color{red}义x$ 和官方题解讲的我都没看懂，先咕着了。</p>
<h4 id="D-ABC-Ultimatum"><a href="#D-ABC-Ultimatum" class="headerlink" title="D - ABC Ultimatum"></a>D - ABC Ultimatum</h4><p>我们称一个长度为 $3n$ 的含有 $n$ 个 <code>A</code>，$n$ 个 <code>B</code> 和 $n$ 个 <code>C</code> 的字符串 $T$ 是好的，当且仅当它能被分为 $n$ 个长为 $3$ 的子序列，且每个子序列是 <code>ABC</code>，<code>BCA</code> 和 <code>CAB</code> 中的一种。给出一个长为 $3n$ 的含有 <code>A</code>，<code>B</code>，<code>C</code> 和 <code>?</code> 的字符串 $S$，找到有多少种把 <code>?</code> 换为 <code>A</code>，<code>B</code> 或 <code>C</code> 的方案，能使得原串是好的，答案对 $998,244,353$ 取模。</p>
<blockquote>
<p>我不理解，为什么一个正常人类能做出这种题目。</p>
</blockquote>
<p>我不理解，为什么一个正常人类能出出来这种题目。</p>
<p>考虑设 $f_{AB}(i)$ 表示前 $i$ 个数中 <code>B</code> 的个数减去 <code>A</code> 的个数，设 $M_A=\max(f_{AB}(0),f_{AB}(1),\cdot\cdot\cdot,f_{AB}(3n))$，类似地，我们定义出 $f_{BC}(i),f_{CA}(i)$，和 $M_B=\max(f_{BC}(0),f_{BC}(1),\cdot\cdot\cdot,f_{BC}(3n)),M_C=\max(f_{CA}(0),f_{CA}(1),\cdot\cdot\cdot,f_{CA}(3n))$。我们来证明 $T$ 能分成 $n$ 个子序列，当且仅当 $M_A+M_B+M_C\le n$。</p>
<p>必要性：假设我们把原序列分为了 $A_1$ 个 <code>ABC</code>，$B_1$ 个 <code>BCA</code> 和 $C_1$ 个 <code>CAB</code>。则 $M_A\le B_1$，因为只有在 <code>BCA</code> 中 <code>B</code> 在 <code>A</code> 前面，同理可以得到 $M_B\le C_1,M_C\le A_1$，所以我们一定有 $M_A+M_B+M_C\le A_1+B_1+C_1=n$。</p>
<p>充分性：因为 $M_A+M_B+M_C\le n$，则我们可以把原序列分成这样的三元组：$($ 第 $i$ 个 <code>A</code> $,$ 第 $(i+M_A)\bmod n$ 个 <code>B</code> $,$ 第 $(i+M_A+M_B)\bmod n$ 个 <code>C</code> $)$。显然满足条件。</p>
<p>这样我们就能 $\rm dp$ 了。考虑设 $f_{a,b,c,ma,mb,mc}$ 表示当前选了 $a$ 个 <code>A</code>，$b$ 个 <code>B</code> 和 $c$ 个 <code>C</code>，且 $f_{CA}(i)$ 目前最大值为 $ma$，$f_{BC}(i)$ 目前最大值为 $mb$，$f_{AB}(i)$ 目前最大值为 $mc$。直接看过去可能会发现还有一维是当前位置，复杂度为 $\mathcal{O}(n^7)$，但实际上，$a+b+c$ 即为位置，所以还是 $\mathcal{O}(n^6)$ 的，根据这个有转移：</p>
<p>$\begin{cases}f_{a+1,b,c,\max(ma,a+1-c),mb,mc}\leftarrow f_{a,b,c,ma,mb,mc}&amp;S_{a+b+c+1}=\texttt{A}\\f_{a,b+1,c,ma,\max(mb,b+1-a),mc}\leftarrow f_{a,b,c,ma,mb,mc}&amp;S_{a+b+c+1}=\texttt{B}\\f_{a,b,c+1,ma,mb,\max(mc,c+1-a)}\leftarrow f_{a,b,c,ma,mb,mc}&amp;S_{a+b+c+1}=\texttt{C}\end{cases}$</p>
<p>注意如果 $S_i=\texttt{?}$，则这三个条件都满足。边界条件 $f_{0,0,0,0,0,0}=1$，最终答案即为 $\sum_{0\le ma+mb+mc\le n}f_{n,n,n,ma,mb,mc}$。最终时间复杂度 $\mathcal{O}(n^6)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>, mod = <span class="number">998244353</span>; <span class="keyword">int</span> f[N][N][N][N][N][N]; <span class="keyword">char</span> s[N * <span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span>&amp; x)</span> </span>&#123; <span class="keyword">while</span> (x &gt;= mod) x -= mod; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, ans = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>, &amp;n, s + <span class="number">1</span>); f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>, i; a &lt;= n; ++a) <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt;= n; ++b) <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt;= n; ++c)</span><br><span class="line">	&#123;</span><br><span class="line">		i = a + b + c + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (a &lt; n &amp;&amp; (s[i] == <span class="string">&#x27;A&#x27;</span> || s[i] == <span class="string">&#x27;?&#x27;</span>))</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> ma = <span class="number">0</span>; ma &lt;= n; ++ma) <span class="keyword">for</span> (<span class="keyword">int</span> mb = <span class="number">0</span>; ma + mb &lt;= n; ++mb) <span class="keyword">for</span> (<span class="keyword">int</span> mc = <span class="number">0</span>; ma + mb + mc &lt;= n; ++mc)</span><br><span class="line">				<span class="built_in">mo</span>(f[a + <span class="number">1</span>][b][c][std::<span class="built_in">max</span>(ma, a + <span class="number">1</span> - c)][mb][mc] += f[a][b][c][ma][mb][mc]);</span><br><span class="line">		<span class="keyword">if</span> (b &lt; n &amp;&amp; (s[i] == <span class="string">&#x27;B&#x27;</span> || s[i] == <span class="string">&#x27;?&#x27;</span>))</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> ma = <span class="number">0</span>; ma &lt;= n; ++ma) <span class="keyword">for</span> (<span class="keyword">int</span> mb = <span class="number">0</span>; ma + mb &lt;= n; ++mb) <span class="keyword">for</span> (<span class="keyword">int</span> mc = <span class="number">0</span>; ma + mb + mc &lt;= n; ++mc)</span><br><span class="line">				<span class="built_in">mo</span>(f[a][b + <span class="number">1</span>][c][ma][std::<span class="built_in">max</span>(mb, b + <span class="number">1</span> - a)][mc] += f[a][b][c][ma][mb][mc]);</span><br><span class="line">		<span class="keyword">if</span> (c &lt; n &amp;&amp; (s[i] == <span class="string">&#x27;C&#x27;</span> || s[i] == <span class="string">&#x27;?&#x27;</span>))</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> ma = <span class="number">0</span>; ma &lt;= n; ++ma) <span class="keyword">for</span> (<span class="keyword">int</span> mb = <span class="number">0</span>; ma + mb &lt;= n; ++mb) <span class="keyword">for</span> (<span class="keyword">int</span> mc = <span class="number">0</span>; ma + mb + mc &lt;= n; ++mc)</span><br><span class="line">				<span class="built_in">mo</span>(f[a][b][c + <span class="number">1</span>][ma][mb][std::<span class="built_in">max</span>(mc, c + <span class="number">1</span> - b)] += f[a][b][c][ma][mb][mc]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> ma = <span class="number">0</span>; ma &lt;= n; ++ma) <span class="keyword">for</span> (<span class="keyword">int</span> mb = <span class="number">0</span>; ma + mb &lt;= n; ++mb) <span class="keyword">for</span> (<span class="keyword">int</span> mc = <span class="number">0</span>; ma + mb + mc &lt;= n; ++mc)</span><br><span class="line">		<span class="built_in">mo</span>(ans += f[n][n][n][ma][mb][mc]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="E-Set-Merging"><a href="#E-Set-Merging" class="headerlink" title="E - Set Merging"></a>E - Set Merging</h4><p>给出 $n$ 个集合 $S_1,S_2,\cdot\cdot\cdot,S_n$，初始时 $S_i=\{i\}$。你可以进行如下操作：</p>
<ul>
<li>选择任意 $i\in [1,n-1]$，令 $U=S_i\cup S_{i+1}$，把 $S_i,S_{i+1}$ 替换为 $U$。</li>
</ul>
<p>能否通过有限次操作使得 $S_i=\{L_i,L_i+1,\cdot\cdot\cdot,R_i-1,R_i\}$，如果可以，找到最少的操作次数，否则报告无解。($1\le n\le5\times10^5,1\le L_i\le R_i\le n$)</p>
<p>显然，如果我们想让操作次数最少，我们不会对 $S_i=S_{i+1}$ 的 $i$ 做任何操作。我们考虑设一个辅助的 $1\sim n$ 的排列 $\mathcal{P}$，初始时 $\mathcal{P}=(1,2,\cdot\cdot\cdot,n)$。当我们对 $S_i,S_{i+1}$ 做上述操作时，我们交换 $\mathcal{P}_i$ 和 $\mathcal{P}_{i+1}$，则我们可以证明如下结论：</p>
<ul>
<li>在任意时刻，对于任意 $i$，$S_i$ 包含从 $\min_{j=i}^n\{\mathcal{P}_j\}$ 到 $\max_{j=1}^i\{\mathcal{P}_j\}$ 中的全部整数。</li>
</ul>
<p>显然一开始时该结论成立，考虑证明进行一次操作后该结论依然成立。如果 $\mathcal{P}_i&gt;\mathcal{P}_{i+1}$，则显然有 $\max_{j=1}^i\{\mathcal{P}_j\}=\max_{j=1}^{i+1}\{\mathcal{P}_j\}$ 和 $\min_{j=i}^n\{\mathcal{P}_j\}=\min_{j=i+1}^n\{\mathcal{P}_j\}$，即 $S_i=S_{i+1}$，我们不需要做任何操作。所以交换的两个数一定满足 $\mathcal{P}_i&lt;\mathcal{P}_{i+1}$。</p>
<p>则 $S_i\cup S_{i+1}=[\min_{j=i}^n\{\mathcal{P}_j\},\max_{j=1}^{i+1}\{\mathcal{P}_j\}]$（用数轴之类的方式合并一下不等式即得）。而又有，$\min_{j=i}^n\{\mathcal{P}_j\}=\min(\min_{j=i+2}^n\{\mathcal{P}_j\},P_i)$ 和 $\max_{j=1}^{i+1}\{\mathcal{P}_j\}=\max(\max_{j=1}^{i-1}\{\mathcal{P}_j\},\mathcal{P}_{i+1})$。所以交换之后结论依然成立。</p>
<p>通过上面的过程，我们能发现，最终答案的最小次数其实就是最终构造出的 $\mathcal{P}$ 中逆序对的个数。也就是说，我们把问题转化成了：</p>
<blockquote>
<p>是否存在一个 $1\sim n$ 的排列 $\mathcal{P}$，使得对于所有 $i$ 都有 $\max_{j=1}^i\{\mathcal{P}_j\}=R_i,\min_{j=i}^n\{\mathcal{P}_j\}=L_i$？如果存在，找到其中逆序对最少的那个。</p>
</blockquote>
<p>因为前缀 $\max$ 和后缀 $\min$ 都是不降的，所以我们一定要有 $L_i\le L_{i+1}$ 和 $R_i\le R_{i+1}$。且如果 $L_i\ne L_{i+1}$，我们一定有 $\mathcal{P}_i=L_i$，特别地，一定有 $\mathcal{P}_n=L_n$。类似地，如果 $R_i\ne R_{i+1}$，则一定有 $\mathcal{P}_{i+1}=R_{i+1}$，且一定有 $\mathcal{P}_1=R_1$。这样，我们就能确定 $\mathcal{P}$ 中一些元素了，如果在确定的过程中出现了矛盾或破坏了排列的性质，直接报告无解即可。</p>
<p>考虑如何插入剩下的的元素，可以把它们按照递增的顺序插入进来。因为如果任意插入不破坏前后缀的性质的话，排序后插入也不会破坏，且这样会产生最小的逆序对，所以自然可以且必须这样插。最终在最终的 $\mathcal{P}$ 上用树状数组之类的找逆序对即可，时间复杂度 $\mathcal{O}(n\log n)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">10</span>; <span class="keyword">int</span> P[N], L[N], R[N], vis[N], res[N], tp;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BIT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ll c[N]; <span class="keyword">int</span> len;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>&#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= len; i += <span class="built_in">lowbit</span>(i)) c[i] += v; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; ll ans = <span class="number">0</span>; <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i; i -= <span class="built_in">lowbit</span>(i)) ans += c[i]; <span class="keyword">return</span> ans; &#125;</span><br><span class="line">&#125;bit;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;L[i], &amp;R[i]);</span><br><span class="line">	P[n] = L[n]; P[<span class="number">1</span>] = R[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">		<span class="keyword">if</span> (L[i] &gt; L[i + <span class="number">1</span>]) &#123; <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (L[i] != L[i + <span class="number">1</span>] &amp;&amp; !P[i]) P[i] = L[i];</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (L[i] != L[i + <span class="number">1</span>] &amp;&amp; P[i] != L[i]) &#123; <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="keyword">if</span> (R[i - <span class="number">1</span>] &gt; R[i]) &#123; <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (R[i - <span class="number">1</span>] != R[i] &amp;&amp; !P[i]) P[i] = R[i];</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (R[i - <span class="number">1</span>] != R[i] &amp;&amp; P[i] != R[i]) &#123; <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">	<span class="keyword">int</span> tot = <span class="number">0</span>, now = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) vis[P[i]] = <span class="number">1</span>, tot += !!P[i]; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (!vis[i]) res[++tp] = i;</span><br><span class="line">	<span class="keyword">if</span> (tp + tot &gt; n) &#123; <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (!P[i]) P[i] = res[now], ++now;</span><br><span class="line">	<span class="keyword">int</span> maxn = <span class="number">-1</span>, minx = n + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (maxn &lt; P[i]) maxn = P[i];</span><br><span class="line">		<span class="keyword">if</span> (maxn != R[i]) &#123; <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (minx &gt; P[i]) minx = P[i];</span><br><span class="line">		<span class="keyword">if</span> (minx != L[i]) &#123; <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	bit.len = n; ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		ans += bit.<span class="built_in">query</span>(bit.len) - bit.<span class="built_in">query</span>(P[i]), bit.<span class="built_in">add</span>(P[i], <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans); <span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="F-Creative-Splitting"><a href="#F-Creative-Splitting" class="headerlink" title="F - Creative Splitting"></a>F - Creative Splitting</h4><p>这道题大概可能也许看懂了，但是还没太理清楚思路，只是把参考着 $\text{\color{black}B\color{red}enq}$ 的代码敲了一遍，等到明天理清楚了再写吧。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>不知道写啥，那就先放着吧，明天写。</p>
<p>我是不是还有个 CSP-S 的 $\tt T4$ 要 <strong>明天</strong> 写来着（</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhiyangfan1234.github.io/2022/01/24/AtCoder%20Regular%20Contest%20125/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhiyangfan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhiyangfan 的博客小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/24/AtCoder%20Regular%20Contest%20125/" class="post-title-link" itemprop="url">AtCoder Regular Contest 125</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-01-24 17:00:23 / 修改时间：17:12:13" itemprop="dateCreated datePublished" datetime="2022-01-24T17:00:23+08:00">2022-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="AtCoder-Regular-Contest-125"><a href="#AtCoder-Regular-Contest-125" class="headerlink" title="AtCoder Regular Contest 125"></a>AtCoder Regular Contest 125</h2><p>xs 第一次打ARC，直接垫底，然后Rating直接回到最低值。代码下午再写了，至于为啥 A 题有代码，是因为我赛时只写出来第一题qwq</p>
<p>upd: 代码已经全部放上去啦。</p>
<h4 id="A-Dial-Up"><a href="#A-Dial-Up" class="headerlink" title="A - Dial Up"></a>A - Dial Up</h4><p>给出一个有 $n$ 个整数的序列 $a$ ，和一个空整数序列 $b$ ，初始时给出 $S_i$ ，$a_i=S_i$ 。现在有以下三种操作: </p>
<ul>
<li>把 $a$ 向右调整，即把 $a$ 换为 $(a_n,a_1,a_2,\cdot\cdot\cdot,a_{n-1})$ ；</li>
<li>把 $a$ 向左调整，即把 $a$ 换为 $(a_2,a_3,\cdot\cdot\cdot a_n,a_1)$ ；</li>
<li>把 $a_1$ 的值加入 $b$ 的末尾。</li>
</ul>
<p>再给出一个有 $m$ 个整数的序列 $T$ 。如果能通过以上操作使得 $b=T$ ，输出最少操作次数，否则输出 $-1$ 。( $1\le n,m\le2\times10^5,0\le S_i,T_i\le1$ )</p>
<p>首先注意到，无解条件是 $S$ 中出现的整数集和 $T$ 中出现的整数集不一致，这个可以在输入时就处理出来。然后我们发现，如果找到一个 $0,1$ 相邻的位置，那么一旦失配，可以通过向左或者向右调整一次就可以再次匹配上。接下来就可以贪心找了，首先预处理出来离 $S_1$ 最近的（向左找和向右找取 $\min$ ）的和它不一样的数所在的位置，然后让 $S_1$ 去和 $T_i$ 匹配，失配时跳到那个不一样的位置，这样就找到了一个 $0,1$ 相邻的位置。之后如果再失配只需要 $1$ 步调整就可以再次匹配上了。最后总复杂度 $\mathcal{O}(n+m)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> S[N], T[N], h1, h0;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, minx = <span class="number">2e9</span>, flag = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m); <span class="keyword">long</span> <span class="keyword">long</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;S[i]), h1 |= S[i], h0 |= !(S[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T[i]), flag |= ((!h1 &amp;&amp; T[i]) || (!h0 &amp;&amp; !T[i]));</span><br><span class="line">    <span class="keyword">if</span> (flag)  &#123; <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">int</span> val = S[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (val != S[i]) &#123; minx = std::<span class="built_in">min</span>(minx, i - <span class="number">1</span>); <span class="keyword">break</span>; &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">2</span>; --i)</span><br><span class="line">        <span class="keyword">if</span> (val != S[i]) &#123; minx = std::<span class="built_in">min</span>(minx, n - i + <span class="number">1</span>); <span class="keyword">break</span>; &#125;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (T[i] == S[<span class="number">1</span>]) ++cnt;</span><br><span class="line">        <span class="keyword">else</span> &#123; ++cnt; cnt += minx; pos = i; <span class="keyword">break</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pos == <span class="number">-1</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, cnt); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    val = (<span class="number">1</span> - S[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = pos + <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (T[i] == val) ++cnt;</span><br><span class="line">        <span class="keyword">else</span> &#123; cnt += <span class="number">2</span>; val = (<span class="number">1</span> - val); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="B-Squares"><a href="#B-Squares" class="headerlink" title="B - Squares"></a><strong>B - Squares</strong></h4><p>给出一个整数 $n$ ，找出满足以下条件的整数二元组 $(x,y)$ 的个数，答案对 $998244353$ 取模：</p>
<ul>
<li>$1\le x,y\le n$</li>
<li>$x^2-y$ 是平方数（ $0$ 也是平方数 ）</li>
</ul>
<p>( $1\le n\le10^{12}$ )</p>
<p>注意到如果 $x^2-y$ 是平方数，则它应该满足 $x^2-y=z^2$ ，稍微变一变就是 $x^2-z^2=(x+z)(x-z)=y$ 。我们令 $p=x+z,q=x-z$ 。我们不去找 $x,y$ 的有几对，转而去找满足以下条件的 $p,q$ 对数：</p>
<ul>
<li>$p\ge q$ ；</li>
<li>$x=\dfrac{p+q}{2}$ 是个整数；</li>
<li>$1\le x=\dfrac{p+q}{2}\le n$ </li>
<li>$1\le y=pq\le n$</li>
</ul>
<p>从这些条件中，我们首先可以注意到的是 $p$ 和 $q$ 都是正整数，且只要满足 $pq\le n$ ，就一定有 $\dfrac{p+q}{2}\le n$ 。那我们就可以先枚举 $q$ 的所有取值（感觉 $p$ 也可以，毕竟他们都 $\le \sqrt{n}$） 。一旦确定 $q$ 的取值，$p$ 一定满足  $q\le p\le \left\lfloor\dfrac{n}{q}\right\rfloor$ ，且 $p\equiv q\pmod{2}$ ，这样的 $p$ 的个数就可以 $\mathcal{O}(1)$ 计算了。所以最终复杂度 $\mathcal{O}(\sqrt{n})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n, ans = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">    <span class="comment">//[l,r] 之间与 l 模 2 同余的数为 (r - l + 1 + 1) / 2 个</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> q = <span class="number">1</span>; q * q &lt;= n; ++q)</span><br><span class="line">        ans = (ans + (n / q - q + <span class="number">2</span>) / <span class="number">2</span>) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="C-LIS-to-Original-Sequence"><a href="#C-LIS-to-Original-Sequence" class="headerlink" title="C - LIS to Original Sequence"></a>C - LIS to Original Sequence</h4><p>给一个整数 $n$ 和一个有 $k$ 个整数的单调递增的序列 $A$ 。找到字典序最小的满足以下条件的 $1$ 到 $n$ 的排列 $\mathcal{P}$ ：</p>
<ul>
<li>$A$ 是 $\mathcal{P}$ 的LIS（最长上升子序列）。如果 $\mathcal{P}$ 有多个LIS，其中一个是 $A$ 也是合法的。</li>
</ul>
<p>可以证明一定存在一个 $\mathcal{P}$ 满足条件。( $1\le k\le n\le2\times10^5,1\le A_1&lt;A_2&lt;\cdot\cdot\cdot&lt;A_k\le n$ )</p>
<p>我们通过对 $n$ 做归纳，可以证明一定存在一个 $\mathcal{P}$ 满足条件，并同时给出字典序最小 $\mathcal{P}$ 的构造方法。考虑从左至右确定这个序列。</p>
<p>首先如果 $k=1$ ，则只存在一个唯一解 $\mathcal{P}=(n,n-1,n-2,\cdot\cdot\cdot,1)$ 。考虑对于 $k\ge2$ 的情况，当 $A_1=1$ 时，我们可以选 $\mathcal{P}_1=1$ 。对于剩余的值 $(\mathcal{P}_2,\mathcal{P}_3,\cdot\cdot\cdot,\mathcal{P}_n)$ ，我们递归选取就好，也就是我们要找到对于 $(A_2-1,A_3-1,\cdot\cdot\cdot,A_k-1)$ 这样的 $A$ 的答案（根据归纳法，一定有解），然后在合并的时候把每个 $\mathcal{P}_i$ 加 $1$ 就好。</p>
<p>当 $A_1&gt;1$ 时，我们发现会要选的是 $\mathcal{P}_1=A_1$ 。注意到如果 $\mathcal{P}_1&lt;A_1$ ，则 $\mathcal{P}_1&lt;A_1&lt;A_2&lt;\cdot\cdot\cdot&lt;A_k$ 才会是 LIS ，导出矛盾。而另一方面，下面会说明的是 $\mathcal{P}_1=A_1$ 的解一定存在，所以 $\mathcal{P}_1=A_1$ 是一定成立的，这样才能让 $\mathcal{P}$  字典序最小。接着我们发现 $\mathcal{P}_2=1$ ，因为一定存在满足 $\mathcal{P}_2=1$ 的解，而它会是字典序最小的选择。现在，我们来证明 $\mathcal{P}_1=A_1,\mathcal{P}_2=1$ 的解一定存在。</p>
<p>我们用归纳法来证明。考虑一个 LIS 为 $(A_2,A_3,\cdot\cdot\cdot,A_k)$ 的排列 $(\mathcal{P}_3,\mathcal{P}_4,\cdot\cdot\cdot,\mathcal{P}_n)=(2,3,\cdot\cdot\cdot,A_1-1,A_1+1,\cdot\cdot\cdot,n)$ 。首先整个 $\mathcal{P}$ 的 LIS 一定是 $k$ ，因为 $\mathcal{P}_1&gt;\mathcal{P}_2$ ，而用上了 $\mathcal{P}_2$ 的 上升子序列长度为 $1+(k-1)=k$ ，也就是 LIS 的长度。容易发现， $A$ 是 $\mathcal{P}$ 的一个子序列，这是满足题意的。不仅如此，只要选择了字典序最小的 $(\mathcal{P}_3,\mathcal{P}_4,\cdot\cdot\cdot,\mathcal{P}_n)$ ，整个的 $\mathcal{P}$ 就一定也是字典序最小。这样问题就缩小为对于序列 $(A_2,A_3,\cdot\cdot\cdot,A_k)$ 求一个长度为 $n-2$ 的字典序最小的排列 $\mathcal{P}$ 使得它的 LIS 为 $A$ 。这样就可以递归求解了。时间复杂度 $\mathcal{O}(n)$ ，注意实现的时候我们可以记录一下那些数没有被选然后模拟，而不是直接调用递归函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], P[N], used[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">1</span>, cnt = <span class="number">0</span>, lef = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (pos &lt; k)</span><br><span class="line">        <span class="keyword">if</span> (a[pos] == lef)</span><br><span class="line">        &#123;</span><br><span class="line">            P[++cnt] = lef;</span><br><span class="line">            used[lef] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (used[lef]) ++lef;</span><br><span class="line">            ++pos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            P[++cnt] = a[pos];</span><br><span class="line">            P[++cnt] = lef;</span><br><span class="line">            used[a[pos]] = <span class="number">1</span>; used[lef] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (used[lef]) ++lef;</span><br><span class="line">            ++pos;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        <span class="keyword">if</span> (!used[i]) P[++cnt] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, P[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="D-Unique-Subsequence"><a href="#D-Unique-Subsequence" class="headerlink" title="D - Unique Subsequence"></a>D - Unique Subsequence</h4><p>给出一个有 $n$ 个整数的序列 $A$ 。找到 $A$ 满足以下条件的非空子序列 $s$ 的个数，答案对 $998244353$ 取模：</p>
<ul>
<li>只有一种方式把 $s$ 从 $A$ 中取出来。形式化讲，只存在唯一一种下标子序列满足 $1\le idx_1&lt;idx_2&lt;\cdot\cdot\cdot&lt;idx_k\le n$ ，满足 $A_{idx_I}=s_i(1\le i\le k)$ 。</li>
</ul>
<p>( $1\le n\le 2\times10^5,1\le A_i\le n$ )</p>
<p>方便起见，我们令 $A_0=0,A_{n+1}=n+1$ ，然后我们来统计包含 $A_0$ 和 $A_{n+1}$ 的子序列。我们假设对于 $0=x_0&lt;x_1&lt;\cdot\cdot\cdot&lt;x_k&lt;x_{k+1}=n+1$ ，存在一个唯一的方法取出子序列 $s=(A_{x_0},A_{x_1},\cdot\cdot\cdot,A_{x_{k+1}})$  。接着我们就发现对于 $0\le i\le k$ 它们一定满足下面这个重要的性质：</p>
<ul>
<li>$A_{x_i+1},A_{x_i+2},\cdot\cdot\cdot,A_{x_{i+1}-1}$ 中的任何一个值都不等于 $A_{x_i}$ 或 $A_{x_{i+1}}$ 。</li>
</ul>
<p>否则就会有其他方法取出相同的子序列了，必要性得证。另一方面，我们来证明充分性，即当这个条件满足时，取出 $s$ 的方式一定是唯一的。我们可以通过贪心地从 $A$ 的开头取出 $s$ （这样可以让下标字典序最小）， 和贪心地从 $A$ 的结尾取出 $s$ （这样可以让下表字典序最大），而二者一定会相遇来证明。</p>
<p>这样答案就可以通过找到满足以上条件的下标子序列数量来找出。这个可以用树状数组实现，时间复杂度 $\mathcal{O}(n\log n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>, mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BIT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ll c[N]; <span class="keyword">int</span> maxn;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, ll v)</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= maxn; i += <span class="built_in">lowbit</span>(i)) </span><br><span class="line">            c[i] = (c[i] + v) % mod; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        ll ans = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i; i -= <span class="built_in">lowbit</span>(i)) </span><br><span class="line">            ans = (ans + c[i]) % mod; </span><br><span class="line">        <span class="keyword">return</span> ans; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;bit;</span><br><span class="line"><span class="keyword">int</span> a[N], las[N], pre[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">0</span>; a[n + <span class="number">1</span>] = n + <span class="number">1</span>; bit.maxn = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        pre[i] = las[a[i]];</span><br><span class="line">        <span class="keyword">if</span> (pre[i] == <span class="number">0</span>) bit.<span class="built_in">add</span>(i, <span class="number">1</span>);</span><br><span class="line">        las[a[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    ll a, b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n + <span class="number">1</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span> (pre[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a = bit.<span class="built_in">query</span>(i - <span class="number">1</span>);</span><br><span class="line">            bit.<span class="built_in">add</span>(i, a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            a = bit.<span class="built_in">query</span>(i - <span class="number">1</span>) - bit.<span class="built_in">query</span>(pre[i] - <span class="number">1</span>);</span><br><span class="line">            a = (a % mod + mod) % mod;</span><br><span class="line">            bit.<span class="built_in">add</span>(i, a);</span><br><span class="line">            b = bit.<span class="built_in">query</span>(pre[i]) - bit.<span class="built_in">query</span>(pre[i] - <span class="number">1</span>);</span><br><span class="line">            b = (b % mod + mod) % mod;</span><br><span class="line">            bit.<span class="built_in">add</span>(pre[i], -b);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ((bit.<span class="built_in">query</span>(n + <span class="number">1</span>) - bit.<span class="built_in">query</span>(n)) % mod + mod) % mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="E-Snack"><a href="#E-Snack" class="headerlink" title="E - Snack"></a>E - Snack</h4><p>有 $n$ 种零食，分别标号为 $1$ 到 $n$ ，第 $i$ 种有 $A_i$ 个。有 $m$ 个孩子，分别标号为 $1$ 到 $m$ 。我们现在想把零食分给孩子，但要满足以下要求：</p>
<ul>
<li>对于每种零食，第 $i$ 个孩子最多拿到 $B_i$ 个;</li>
<li>第 $i$ 个孩子总共拿最多 $C_i$ 个零食。</li>
</ul>
<p>找到在以上要求下，能分给孩子们的零食的最大值。( $1\le n\le 2\times10^5,1\le m\le2\times1065,1\le A_i\le10^{12},1\le B_i\le10^7,1\le C_i\le10^{12}$ )</p>
<p>考虑把原问题抽象为最大流模型，也就是：</p>
<ul>
<li>图的点集为 $S,T,L_1,L_2,\cdot\cdot\cdot,L_n,R_1,R_2,\cdot\cdot\cdot,R_m$ ;</li>
<li>对于所有的 $1\le i\le n$ ，都有一条从 $S$ 到 $L_i$ 的边，最大流量为 $A_i$ ;</li>
<li>对于所有的 $1\le i\le n,1\le j\le m$ ，都有一条从 $L_i$ 到 $R_j$  的边，最大流量为 $B_j$ ;</li>
<li>对于所有的 $1\le j\le m$ ，都有一条从 $R_j$ 到 $T$ 的边，最大流量为 $C_j$ ;</li>
<li>答案就是从 $S$ 到 $T$ 的最大流。</li>
</ul>
<p>注意到这个图的点集边集都很大，不好直接求最大流，所以我们可以转而求最小割，毕竟最大流等于最小割。首先假设我们已经把 $L_i$ 节点分为两个集合，$S$ 集 $X$ （就是在最小割中与 $S$ 相连的点集）和 $T$ 集 $Y$ （就是在最小割中与 $T$ 相连的点集），接着对于每一个 $R_j$ 节点，我们可以单独看它是与 $S$ 连还是与 $T$ 连——也就是比较两种情况的权值，如果与 $S$ 连，权值就是断 $R_j$ 到 $T$ 的边，也就是 $C_j$ ；如果与 $T$ 连，权值就是断所有与 $X$ 中的 $L_i$ 的边，也就是 $|X|B_j$ 。</p>
<p>我们发现一旦选取了 $X,Y$ ，在划分 $R_j$ 时，只有 $|X|$ 对结果有影响，所以我们可以先枚举 $|X|$ 的值（从 $0$ 到 $n$），然后贪心按 $A_i$  递减的顺序从 $L_i$ 中选取节点加入 $X$ ，接着计算当前情况下的最小割就可以了（对于 $S$ 到 $L_i$ 的边，产生的代价是 $Y$ 中所有$L_i$ 与 $S$ 断开的权值；对于 $L_i$ 到 $R_j$ 的边就是断开 $Y$ 中所有 $R_j$ 到  $X$ 中所有 $L_i$ 边的权值；对于 $R_j$ 到 $T$ 的边，就是 $X$ 中所有 $R_j$ 到 $T$ 的边断开的权值），最终答案就是所有情况取 $\min$ 。 时间复杂度是枚举 $|X|$ 的 $\mathcal{O}(n)$ 和决定 $R_j$ 归属集合的 $\mathcal{O}(m)$ ，算上 $A_i$ 排序的复杂度，总复杂度就是 $\mathcal{O}(n\log n+m)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>; <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll a[N], b[N], c[N], ans = <span class="number">1e18</span>, sumB, sum; std::vector&lt;<span class="keyword">int</span>&gt; vec[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> ll&amp; x, <span class="keyword">const</span> ll&amp; y)</span> </span>&#123; <span class="keyword">return</span> x &gt; y; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)   </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]), sum += a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;b[i]), sumB += b[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;c[i]);</span><br><span class="line">    std::<span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        vec[std::<span class="built_in">min</span>(c[i] / b[i], (ll)n)].<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i) sum -= a[i]; ans = std::<span class="built_in">min</span>(ans, sum);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vec[i].<span class="built_in">size</span>(); ++j)</span><br><span class="line">            sum -= i * b[vec[i][j]], </span><br><span class="line">            sum += c[vec[i][j]], sumB -= b[vec[i][j]];</span><br><span class="line">        sum += sumB; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="F-Tree-Degree-Subset-Sum"><a href="#F-Tree-Degree-Subset-Sum" class="headerlink" title="F - Tree Degree Subset Sum"></a>F - Tree Degree Subset Sum</h4><p>给出一个有 $n$ 个节点的树，找到满足以下条件的整数二元组 $(x,y)$ 个数：</p>
<ul>
<li>$0\le x\le n$</li>
<li>可以从树上选出 $x$ 个节点满足它们的度数和为 $y$ 。</li>
</ul>
<p>( $2\le n\le 2\times 10^5$ )</p>
<p>我们定义一个序列 $d$ ，其中 $d_i=D_i-1$ ( $D_i$ 是 $i$ 号节点的度数 )。对于所有 $0\le s\le n-2$ ，我们令 $m_s$ 和 $M_s$ 分别表示 $d$ 的最小和最大的和是 $s$ 的子集，特别地，如果不存在这样的子集，为了方便令 $m_s=\infty,M_s=-\infty$ 。接着就有以下结论：</p>
<ul>
<li>对于每个 $m_s\le c\le M_s$ ，从 $d$ 中取 $c$ 个值和为 $s$ 是可能的。</li>
</ul>
<p>证明后附。如果我们现在假设它成立，那问题就简单了。考虑 $\rm dp$ 计算 $m_s$ 。因为 $d$ 中至多有 $\mathcal{O}(\sqrt{n})$ 个不同的值，所以我们可以把所有元素按值分类，这样得到一个转移方程 $m_s=\min_{i=0}^s(m_i+1)$，然后用滑动窗口加速转移，计算 $m_s$时间复杂度为 $\mathcal{O}(n\sqrt{n})$ 。然后 $M_s$ 就可以通过 $m_s$ 直接求出。这样我们就做完了这道题，枚举每个 $s$ ，$\mathcal{O}(1)$ 计算就好。最终时间复杂度 $\mathcal{O}(n\sqrt{n})$ 。这里给的实现和题解不太一样（个人感觉比单调队列求要好理解的一点），是二进制分解做背包，时间复杂度为 $\mathcal{O}(n\log n\sqrt{n})$ ，状态都一样，只不过转移的时候用的二进制分解做。 </p>
<p>结论的证明：我们设 $z$ 是 $d$ 中 $0$ 的个数，那结论就等价于 $M_s-m_s\le 2z$ 。这是因为一个达到 $m_s$ 的解总不用 $0$ ，一个达到 $M_s$ 的解总会用 $z$ 个 $0$ 。而对于$d$ 的每个子集 $x$ ，我们都有 $-z\le s-c\le z-2$ ，其中 $c$  是 $x$ 的大小，$s$ 是 $x$ 中元素和。注意到 $s-c$ 其实就是 $d_i-1$ 的和，而对于整个 $d$ ， $d_i-1<0$ 的和为 $-z$ ，而 $d_i-1>0$ 的和是 $z-2$ 。这样就推导出来了，$-z\le s-M_s\le s-m_s\le z-s$ ，即 $M_s-m_s\le 2z$ ，结论得证。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>, inf = <span class="number">2e9</span>;</span><br><span class="line"><span class="keyword">int</span> deg[N], d[N], ms[N], Ms[N], cnt[N], q[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> a &gt; b ? a : b; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> a &lt; b ? a : b; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, t; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n); <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b), ++deg[a], ++deg[b];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        d[i] = deg[i] - <span class="number">1</span>;</span><br><span class="line">        ++cnt[d[i]]; ms[i] = inf; Ms[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ms[<span class="number">0</span>] = <span class="number">0</span>; Ms[<span class="number">0</span>] = cnt[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">2</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!cnt[i]) <span class="keyword">continue</span>; t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; (<span class="number">1</span> &lt;&lt; j) &lt;= cnt[i]; ++j)</span><br><span class="line">            cnt[i] -= (<span class="number">1</span> &lt;&lt; j), q[++t] = (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">        <span class="keyword">if</span> (cnt[i]) q[++t] = cnt[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= t; ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = n - <span class="number">2</span>; k &gt;= i * q[j]; --k)</span><br><span class="line">            &#123;</span><br><span class="line">                ms[k] = <span class="built_in">min</span>(ms[k], ms[k - i * q[j]] + q[j]);</span><br><span class="line">                Ms[k] = <span class="built_in">max</span>(Ms[k], Ms[k - i * q[j]] + q[j]);</span><br><span class="line">            &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)</span><br><span class="line">        ans += <span class="built_in">max</span>(<span class="number">0</span>, Ms[i] - ms[i] + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="知识经验总结"><a href="#知识经验总结" class="headerlink" title="知识经验总结"></a>知识经验总结</h3><ol>
<li>对于构造题可以考虑先确定部分解，再根据归纳法推广至整个解；</li>
<li>对于无法直接求最大流的题，可以考虑转化为最小割后用非网络流算法求解，一个比较常见的思路是将点分为与最小割种与 $S$ 相连的和与 $T$ 相连的两个部分，然后分别统计贡献；</li>
<li>对于不好直接统计的计数题，考虑推式子后转化成更小范围内统计，或者找到另一种等价条件使得统计变得简单；</li>
<li>如果一道题想了很久都没有出路，一定要相信自己智商没有问题，不会想那么久都不出正解，一定是方法错了，果断转弯换方法吧。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhiyangfan1234.github.io/2022/01/24/AtCoder%20Grand%20Contest%20012/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhiyangfan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhiyangfan 的博客小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/24/AtCoder%20Grand%20Contest%20012/" class="post-title-link" itemprop="url">AtCoder Grand Contest 012</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-01-24 17:00:23 / 修改时间：17:11:58" itemprop="dateCreated datePublished" datetime="2022-01-24T17:00:23+08:00">2022-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="AtCoder-Grand-Contest-012"><a href="#AtCoder-Grand-Contest-012" class="headerlink" title="AtCoder Grand Contest 012"></a>AtCoder Grand Contest 012</h2><p>大鸽子发现自己从 007 开始就没写了，然后选择先写 012。</p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="A-AtCoder-Group-Contest"><a href="#A-AtCoder-Group-Contest" class="headerlink" title="A - AtCoder Group Contest"></a>A - AtCoder Group Contest</h4><p>给出一个有 $3n$ 个数的序列 $a$，把它分割为 $n$ 个序列，每个序列里恰有 $3$ 个元素。定义一种分割方法的权值是所有序列中元素中位数之和，求所有分割方法中权值的最大值。($1\le n\le10^5,1\le a_i\le10^9$)</p>
<p>无论如何当前情况下最大值和最小值不能对答案造成任何贡献，所以我们把它分到一个序列里后，这个序列下一个选的元素就会是中位数，显然我们会贪心选第二大的元素进来。之后就变为了另一个相同的子问题，每次贪心求解即可（其实就是第 $2i(1\le i\le n)$ 大之和。）。时间复杂度 $\mathcal{O}(n\log n)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>; <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll; <span class="keyword">int</span> a[N * <span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; ll ans = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n); n *= <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    std::<span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= n - n / <span class="number">3</span> * <span class="number">2</span>; i -= <span class="number">2</span>) ans += a[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="B-Splatter-Painting"><a href="#B-Splatter-Painting" class="headerlink" title="B - Splatter Painting"></a>B - Splatter Painting</h4><p>给出一张 $n$ 个结点 $m$ 条边的简单无向图，初始时每个结点颜色均为 $0$。接下来有 $q$ 次操作，每个操作用三元组 $(d_i,c_i,v_i)$ 描述，表示把距离结点 $v_i$ 不超过 $d_i$ 的结点全部涂成 $c_i$ 的颜色。问所有操作后每个点的颜色。($1\le n,m,q\le10^5,0\le d_i\le10,1\le c_i\le n$)</p>
<p>注意到，对于某个结点 $v$ 来说，如果存在两个操作 $i,j$ 满足 $i&lt;j$，$d_i&lt;d_j$，则 $i$ 操作就完全没有必要了。另注意到，对于某个结点 $u$ 来说，一次操作 $(d,c,u)$ 对于 $u$ 的相邻结点 $v$ 相当于一次操作 $(d-1,c,v)$。有了这两个观察，之后的问题就迎刃而解了。</p>
<p>考虑设 $f_{u,d}$ 表示对于结点 $u$，在它上面 $d_i=d$ 的所有操作中编号最大操作的编号。这可以在读入时预处理出来。接着根据第二个结论，我们有以下转移：</p>
<script type="math/tex; mode=display">f_{u,d}=\max\left(\max_{(u,v)\in E}\{f_{v,d+1}\},f_{u,d}\right)</script><p>其中 $E$ 表示原图的边集。所有东西都处理完之后，最终 $u$ 上真正生效的操作编号为：</p>
<script type="math/tex; mode=display">\max_{d=0}^{10}\{f_{u,d}\}</script><p>记录一下每个操作对应的颜色即可直接求解。时间复杂度 $\mathcal{O}(d(n+m))$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>; <span class="keyword">int</span> f[N][<span class="number">20</span>], col[N], ans[N]; </span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; vec[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, q; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= m; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y), vec[x].<span class="built_in">push_back</span>(y), vec[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, v, d; i &lt;= q; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;v, &amp;d, &amp;col[i]);</span><br><span class="line">        f[v][d] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">10</span>; d; --d)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; ++u)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> v : vec[u]) f[v][d - <span class="number">1</span>] = std::<span class="built_in">max</span>(f[v][d - <span class="number">1</span>], f[u][d]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; ++u)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">10</span>; d &gt;= <span class="number">0</span>; --d) mx = std::<span class="built_in">max</span>(f[u][d], mx);</span><br><span class="line">        ans[u] = col[mx];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; ++u) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[u]); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="C-Tautonym-Puzzle"><a href="#C-Tautonym-Puzzle" class="headerlink" title="C - Tautonym Puzzle"></a>C - Tautonym Puzzle</h4><p>我们称一个字符串 $S$ 是「好的」，当且仅当其满足以下条件：</p>
<ul>
<li>$S$ 能被表示为 $TT$ 的形式，$T$ 为一个非空字符串（比如 $S=\tt abcabc$ 是「好的」，因为存在一个 $T=\tt abc$）。</li>
</ul>
<p>给出 $n$，构造出一个字符串 $s$ 满足以下条件：</p>
<ul>
<li>$1\le |s|\le 200$。</li>
<li>$|\sum|\le 100$，其中 $\sum$ 表示 $s$ 的字符集。为了方便，我们用数字 $1\sim 100$ 代替这些字符。</li>
<li>在 $s$ 的 $2^{|s|}$ 个子序列中，恰有 $n$ 个是「好的」。</li>
</ul>
<p>可以证明一定有解。($1\le n\le10^{12}$)</p>
<p>因为直接考虑这个「好的」子序列限制并不好考虑，所以我们考虑把「好的」这个限制转化成其他我们熟悉的，针对子序列的限制。<del>不难</del> 想到上升子序列。具体来讲，我们定义 $\mathcal{P}$ 为 $(1,2,3,\cdot\cdot\cdot,n)$ 的一个排列，令 $s=(\mathcal{P}_1,\mathcal{P}_2,\mathcal{P}_3,\cdot\cdot\cdot,\mathcal{P}_n,1,2,3,\cdot\cdot\cdot,n)$。不难发现，$\mathcal{P}$ 中的非空上升子序列数量其实就是 $s$ 中「好的」子序列的数量。（有且仅有上升子序列能和后面一半组成一个「好的」字符串）接下来问题就转化为了求出一个长度不超过 $100$ 的排列 $\mathcal{P}$，使它的上升子序列个数（可能为空）恰为 $n+1$ 个。</p>
<p>设 $f_S$ 表示 $S$ 的上升子序列数量，则有如下结论：</p>
<ul>
<li>$f_{\emptyset}=1$。（什么都没有也算一个，毕竟可以为空）</li>
<li>$f_{\{\mathcal{P}_1,\mathcal{P}_2,\cdot\cdot\cdot,\mathcal{P}_k,k+1\}}=2f_{\{\mathcal{P}_1,\mathcal{P}_2,\cdot\cdot\cdot,\mathcal{P}_k\}}$。（每个原来的上升子序列都可以选择接上或者不接上 $k+1$）</li>
<li>$f_{\{k+1,\mathcal{P}_1,\mathcal{P}_2,\cdot\cdot\cdot,\mathcal{P}_k\}}=f_{\{\mathcal{P}_1,\mathcal{P}_2,\cdot\cdot\cdot,\mathcal{P}_k\}}+1$。（只是多了一个 $(k+1)$ 的上升子序列）</li>
</ul>
<p>根据上面的结论，我们可以按指数级别缩小问题的规模，最终排列数目约有 $2\log_2 n<100$。再加上后面的排列，最终长度显然小于 $200$。时间复杂度 $\mathcal{O}(\log n)$。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">work</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1</span>) <span class="keyword">return</span> std::vector&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">if</span> (x &amp; <span class="number">1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        v = <span class="built_in">work</span>(x - <span class="number">1</span>);</span><br><span class="line">        v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        v = <span class="built_in">work</span>(x / <span class="number">2</span>);</span><br><span class="line">        v.<span class="built_in">push_back</span>(v.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n; <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; ret = <span class="built_in">work</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ret.<span class="built_in">size</span>() * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : ret) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ret.<span class="built_in">size</span>(); ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="D-Colorful-Balls"><a href="#D-Colorful-Balls" class="headerlink" title="D - Colorful Balls"></a>D - Colorful Balls</h4><p>有一个长为 $n$ 的数组，第 $i$ 个元素是一个二元组 $(c_i,w_i)$，分别表示颜色和权值。共有以下两种操作可以执行：</p>
<ol>
<li>选择两个元素 $i,j$ 满足 $c_i=c_j,w_i+w_j\le x$，并把它们交换。</li>
<li>选择两个元素 $i,j$ 满足 $c_i\ne c_j,w_i+w_j\le y$，并把它们交换。</li>
</ol>
<p>其中 $x,y$ 为给定常数。求一共能产生多少种不同的最终序列，答案对 $10^9+7$ 取模。($1\le n\le 2\times10^5,1\le x,y,w_i\le10^9,1\le c_i\le n$)</p>
<p>注意到这个「可交换」的性质是可以传递的，即如果 $A,B$ 可以交换，$B,C$ 可以交换，那么 $A,C$ 也可以交换。（手玩一下就知道惹）那「可交换」其实就可以抽象为图上的边了，如果我们把所有「可交换」关系都用边表示出来，那么最终答案即为得到的无向图中所有连通块里可重集排列数之积。（因为一个连通块里面可以任意交换）但这样的话，边的数量就达到了 $\mathcal{O}(n^2)$ 级别，显然无法接受。如果我们画几组小数据，可以发现这么多条边其实有很多都是重复的，所以我们考虑删去一些边使得图上的连通性不变。</p>
<p>首先考虑操作1，这个是在 $c_i$ 相同的元素中进行的，我们设 $x_i$ 表示第 $i$ 种颜色中权值最小的，设 $y_i,z_i$ 表示 $i$ 种颜色中任意的其他两个元素。则如果 $y_i+z_i\le x$，即它们两个之间能连边，则一定有 $y_i+x_i\le x,z_i+x_i\le x$，即它们两个都可以和 $x_i$ 连边。所以如果我们去掉 $(y_i,z_i)$ 这条边对连通性是没有影响的。所以对于每种颜色，我们只需要考虑其中所有元素和 $x_i$ 的连边即可，连出的边数仅为 $\mathcal{O}(n)$ 级别。</p>
<p>再来考虑操作2，这个是在 $c_i$ 不同的元素中进行的。依然延续上述思路，不失一般性，我们假设有：</p>
<ul>
<li>颜色从 $1$ 到 $c$ 编号。</li>
<li>$\forall 1\le i\le c$，我们设 $a_i$ 表示第 $i$ 种颜色中权值最小的。</li>
<li>$a_1\le a_2\le\cdot\cdot\cdot\le a_c$。</li>
</ul>
<p>则对于任意两个颜色不同的元素 $s,t$，如果有 $w_s+w_y\le y$，则有：</p>
<ul>
<li>如果 $c_s\ne 1,c_t\ne 1$，则存在边 $(s,a_1),(t,a_1)$，可以删去 $(s,t)$。</li>
<li>如果 $c_s\ne 2,c_t\ne 2$，则存在边 $(s,a_2),(t,a_2)$，可以删去 $(s,t)$。</li>
<li>如果 $c_s=1,c_t=2$，则存在边 $(s,a_2),(a_1,t)$，因为 $w_s+w_y\le y$，所以一定有边 $(a_1,a_2)$，可以删去 $(s,t)$。</li>
</ul>
<p>注意这里还涉及到了次小值，是考虑到颜色可能和最小值相同无法连边的情况。这样只需要考虑所有元素和 $a_1,a_2$ 的连边即可，连出的边数仅为 $\mathcal{O}(n)$ 级别。</p>
<p>这样我们就成功在连通性不变的前提下减少边数到了 $\mathcal{O}(n)$ 可以通过本题。时间复杂度 $\mathcal{O}(n)$，注意一点小细节。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写丑了，并查集就够了的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e6</span> + <span class="number">10</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>, inf = <span class="number">1e9</span>; </span><br><span class="line">std::vector&lt;std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; vec[N]; <span class="keyword">int</span> size[N], col[N], ww[N], d[N], tp;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span> <span class="keyword">int</span> v, next; &#125;E[N &lt;&lt; <span class="number">1</span>]; <span class="keyword">int</span> p[N], vis[N], fac[N], st[N], top, cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(p, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span> (p)); cnt = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123; E[cnt].v = v; E[cnt].next = p[u]; p[u] = cnt++; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123; <span class="keyword">if</span> (u == v) <span class="keyword">return</span> ; <span class="built_in">insert</span>(u, v); <span class="built_in">insert</span>(v, u); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[u] = <span class="number">1</span>; ++size[tp]; st[++top] = u;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = p[u], v; i + <span class="number">1</span>; i = E[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        v = E[i].v; <span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>; </span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ksm</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="number">1ll</span> * ret * a % mod;</span><br><span class="line">        a = <span class="number">1ll</span> * a * a % mod; b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>(); <span class="keyword">int</span> n, x, y, ans = <span class="number">1</span>; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;x, &amp;y);</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fac[i] = <span class="number">1ll</span> * fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) d[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, c, w; i &lt;= n; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;c, &amp;w); ww[i] = w; col[i] = c;</span><br><span class="line">        vec[c].<span class="built_in">emplace_back</span>(w, i);</span><br><span class="line">    &#125;      </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        std::<span class="built_in">sort</span>(vec[i].<span class="built_in">begin</span>(), vec[i].<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : vec[i])</span><br><span class="line">            <span class="keyword">if</span> (v.first + vec[i][<span class="number">0</span>].first &lt;= x) <span class="built_in">addedge</span>(v.second, vec[i][<span class="number">0</span>].second); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(inf, <span class="number">0</span>)</span>, <span class="title">b</span><span class="params">(inf, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">if</span> (vec[i].<span class="built_in">empty</span>()) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (vec[i][<span class="number">0</span>].first &lt; a.first) b = a, a = vec[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (vec[i][<span class="number">0</span>].first &lt; b.first) b = vec[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (col[i] == col[a.second])</span><br><span class="line">            &#123; <span class="keyword">if</span> (b.second &amp;&amp; ww[i] + b.first &lt;= y) <span class="built_in">addedge</span>(b.second, i); &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ww[i] + a.first &lt;= y) <span class="built_in">addedge</span>(a.second, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">vec</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) </span><br><span class="line">        &#123;</span><br><span class="line">            ++tp; top = <span class="number">0</span>; <span class="built_in">dfs</span>(i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= top; ++j)</span><br><span class="line">                ++vec[col[st[j]]], d[tp] = <span class="number">1ll</span> * d[tp] * vec[col[st[j]]] % mod;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= top; ++j) vec[col[st[j]]] = <span class="number">0</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tp; ++i) </span><br><span class="line">        ans = <span class="number">1ll</span> * ans * fac[size[i]] % mod * <span class="built_in">ksm</span>(d[i], mod - <span class="number">2</span>) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans); <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="E-Camel-and-Oases"><a href="#E-Camel-and-Oases" class="headerlink" title="E - Camel and Oases"></a>E - Camel and Oases</h4><p>一个骆驼在一个可以看做数轴的沙漠上行走，沙漠里有 $n$ 个绿洲，第 $i$ 个绿洲的坐标为 $x_i$，骆驼想要到达所有的绿洲。初始时骆驼驼峰的容量为 $V$，水只能从绿洲获取且储存总量不能超过驼峰容量。绿洲提供的水量没有限制，且一个绿洲可以到达多次，每次均能获得水。</p>
<p>骆驼有以下两种移动方式：</p>
<ul>
<li>走路，走 $d$ 的距离消耗 $d$ 体积的水，注意水的体积不能是负数。</li>
<li>跳跃，设当前驼峰容量为 $v$，则骆驼可以跳到沙漠上的任意一点，之后驼峰容量变为 $\frac{v}{2}$，且水量清空。</li>
</ul>
<p>对于所有的绿洲，求出能否从它出发到达所有的绿洲。($2\le n,v\le2\times10^5,-10^9\le x_1&lt;x_2\cdot\cdot\cdot&lt;x_n\le 10^9$)</p>
<p>首先我们不考虑跳跃，则从每个绿洲出发能到达的绿洲一定是原绿洲序列上的一个线段，且相邻两个绿洲之间的距离小于等于 $V$。而再考虑跳跃对应的容量变化，对于这种变化，我们通常可以考虑分层的思想。即设当前层数表示当前容量，则每个绿洲出发能到达的绿洲依然是线段，只不过距离限制是小于等于 $v$。有了这两个结论后，我们可以把原问题变为如下形式：</p>
<blockquote>
<p>共有 $\log n$ 层数轴，从每层选出不超过 $1$ 个线段，能否覆盖所有点。对每个点询问它能否被包含在第一层的线段中。</p>
</blockquote>
<p>因为层数很少，每层选线段也只有选或者不选两种情况，所以可以考虑状压 $\rm dp$。设 $dpl_S$ 表示当前选择线段情况为 $S$ 时，能覆盖最长前缀的右端点，$dpr_S$ 表示当前选择线段情况为 $S$ 时，能覆盖最长后缀的左端点。转移 $dpl$ 时，考虑加入当前线段，因为要和前面的前缀接上，所以要找到本层线段中第一个 $&gt;dpl_S$ 的右端点。同理，转移 $dpr$ 时，选择本层中第一个 $&lt;dpr_S$ 的左端点。这样转移的复杂度即为 $\mathcal{O}(2^{\log n}\log^2 n)=\mathcal{O}(n\log^2n)$。</p>
<p>求答案的时候，我们对于每个第一层的线段，枚举最终选择线段的情况，看看左端点和右端点能不能接上就好了。发现这样做的复杂度是 $\mathcal{O}(n2^{\log n})=\mathcal{O}(n^2)$ 的无法接受。但注意到，如果第一层有超过 $\log n$ 个线段，那么我们不管怎么跳都不能在 $\log n$ 层内访问完所有的点，所以此时对于所有的点均为无解。排除掉这种情况后，复杂度就变为了 $\mathcal{O}(\log n2^{\log n})=\mathcal{O}(n\log n)$。最终时间复杂度 $\mathcal{O}(n\log^2 n)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>, B = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> n, v, a[N], dpr[<span class="number">1</span> &lt;&lt; B], dpl[<span class="number">1</span> &lt;&lt; B];</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; vl, segl[B + <span class="number">10</span>], segr[B + <span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">linkL</span><span class="params">(<span class="keyword">int</span> tv, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> idx = std::<span class="built_in">upper_bound</span>(segr[tv].<span class="built_in">begin</span>(), segr[tv].<span class="built_in">end</span>(), len) - segr[tv].<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">return</span> segr[tv][idx];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">linkR</span><span class="params">(<span class="keyword">int</span> tv, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> idx = std::<span class="built_in">lower_bound</span>(segl[tv].<span class="built_in">begin</span>(), segl[tv].<span class="built_in">end</span>(), len) - segl[tv].<span class="built_in">begin</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> segl[tv][idx];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;v);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">int</span> tv = v;</span><br><span class="line">    <span class="keyword">while</span> (tv)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> l = i;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; a[i + <span class="number">1</span>] - a[i] &lt;= tv) ++i;</span><br><span class="line">            segl[vl.<span class="built_in">size</span>()].<span class="built_in">push_back</span>(l); segr[vl.<span class="built_in">size</span>()].<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        vl.<span class="built_in">push_back</span>(tv); tv &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l = i;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; a[i + <span class="number">1</span>] - a[i] &lt;= tv) ++i;</span><br><span class="line">        segl[vl.<span class="built_in">size</span>()].<span class="built_in">push_back</span>(l); segr[vl.<span class="built_in">size</span>()].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    vl.<span class="built_in">push_back</span>(tv);</span><br><span class="line">    <span class="keyword">if</span> (segl[<span class="number">0</span>].<span class="built_in">size</span>() &gt; vl.<span class="built_in">size</span>()) &#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">puts</span>(<span class="string">&quot;Impossible&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dpr, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span> (dpr));</span><br><span class="line">    <span class="keyword">int</span> all = (<span class="number">1</span> &lt;&lt; vl.<span class="built_in">size</span>()) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= all; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; vl.<span class="built_in">size</span>(); ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; j)) <span class="keyword">continue</span>;</span><br><span class="line">            dpl[i | (<span class="number">1</span> &lt;&lt; j)] = std::<span class="built_in">max</span>(dpl[i | (<span class="number">1</span> &lt;&lt; j)], <span class="built_in">linkL</span>(j, dpl[i]));</span><br><span class="line">            dpr[i | (<span class="number">1</span> &lt;&lt; j)] = std::<span class="built_in">min</span>(dpr[i | (<span class="number">1</span> &lt;&lt; j)], <span class="built_in">linkR</span>(j, dpr[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; segl[<span class="number">0</span>].<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l = segl[<span class="number">0</span>][i], r = segr[<span class="number">0</span>][i];</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= all; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dpl[j] &gt;= dpr[all ^ j] || (dpl[j] &gt;= l - <span class="number">1</span> &amp;&amp; dpr[all ^ j] &lt;= r + <span class="number">1</span>)) &#123; flag = <span class="number">1</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">            <span class="keyword">if</span> (l == <span class="number">1</span> &amp;&amp; dpr[all ^ j] &lt;= r + <span class="number">1</span>) &#123; flag = <span class="number">1</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">            <span class="keyword">if</span> (r == n &amp;&amp; dpl[j] &gt;= l - <span class="number">1</span>) &#123; flag = <span class="number">1</span>; <span class="keyword">break</span>; &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = l; j &lt;= r; ++j) <span class="built_in">puts</span>(flag ? <span class="string">&quot;Possible&quot;</span> : <span class="string">&quot;Impossible&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="F-Prefix-Median"><a href="#F-Prefix-Median" class="headerlink" title="F - Prefix Median"></a>F - Prefix Median</h4><p>给出一个长为 $2n-1$ 的数组 $a$。能对它任意重排，且对于重排后的数组 $a$，我们按照如下规则生成一个数组 $b$：</p>
<ul>
<li>$b_1$ 为 $(a_1)$ 的中位数。</li>
<li>$b_2$ 为 $(a_1,a_2,a_3)$ 的中位数。</li>
<li>$b_3$ 为 $(a_1,a_2,a_3,a_4,a_5)$ 的中位数。</li>
<li>:</li>
<li>$b_n$ 为 $(a_1,a_2,a_3,\cdot\cdot\cdot,a_{2n-1})$ 的中位数。</li>
</ul>
<p>求能得到多少个不同的 $b$ 数组。($1\le n\le50,1\le a_i\le 2n-1$)</p>
<p>在考虑更复杂的情况前，我们先考虑一下 $a_i=i$ 的情况。首先有 $i\le b_i\le2n-i$。（因为前 $i$ 个数字和后 $2n-i$ 个数字都一定不会成为中位数）然后我们能证明，对于 $b_i,b_{i+1}$，它们要么相邻，要么相同，考虑下图（来自 AT 题解）：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/y458mipv.png" alt=""></p>
<p>所以 $b$ 一定满足下列条件：</p>
<ul>
<li>$i\le b_i\le 2n-i$。</li>
<li>不存在 $(i,j)(i&lt;j)$ 满足 $b_i&lt;b_j&lt;b_{i+1}$。</li>
<li>不存在 $(i,j)(i<j)$ 满足 $b_j>b_i&gt;b_{j+1}$。</li>
</ul>
<p>必要性显然。可以证明这是充分条件，不过比较复杂，有兴趣的可以去看 AT 原题解。</p>
<p>而对于一般情况，也就是 $a_i$ 不一定互不相同的情况，假设 $a_1\le a_2\le a_3\le\cdot\cdot\cdot\le a_{2n-1}$，则有：</p>
<ul>
<li>$b_i\in\{a_i,a_{i+1},a_{i+2},\cdot\cdot\cdot,a_{2n-i}\}$</li>
<li>不存在 $(i,j)(i&lt;j)$ 满足 $b_i&lt;b_j&lt;b_{i+1}$。</li>
<li>不存在 $(i,j)(i<j)$ 满足 $b_j>b_i&gt;b_{j+1}$。</li>
</ul>
<p>接下来的问题就变为了数出满足以上条件的序列个数了，考虑倒序考虑 $b$。（因为 $b_n$ 的限制最强）对于第二三条限制，其实它们相当于当我们决定跳过一个数 $x$ 不用时，我们以后就再也用不到它了。根据这个，我们能发现 $b_i$ 能选的区间其实是 $[a_i,\min\{b_j\}]\cup[\max\{b_j\},a_{2n-i}]$。这样就可以设计出线性 $\rm dp$，考虑设 $f_{i,l,r}$ 表示当前考虑到第 $i$ 为，在区间 $[a_i,\min\{b_j\}]$ 上有 $l$ 种选择，在区间 $[\max\{b_j\},a_{2n-i}]$ 上有 $j$ 种选择的方案数。则每次转移时枚举 $b_i$ 在 $b_{i+1}$ 的左边，右边还是重合，其中 $dl=[a_{i+1}\ne a_i],dr=[a_{2n-i}\ne a_{2n-i-1}]$：</p>
<ul>
<li>$f_{i+1,j,k}\rightarrow f_{i+1,j+dl,k+dr}$。表示与 $b_{i+1}$ 重合，此时 $\min\{b_j\},\max\{b_j\}$ 不变，而 $a_i,a_{2n-i}$ 分别向左向右移动了一格，所以选择方案会多，但要去掉重复的情况。</li>
<li>$f_{i+1,j,k}\rightarrow f_{i,l,k+dr+1}(0\le l\le j+dl-1)$。表示在 $b_{i+1}$ 左边，此时右边会多一个可选的，也就是 $k+dr+1$，左边可选择的我们分别钦定，但最大到 $j+dl-1$。</li>
<li>$f_{i+1,j,k}\rightarrow f_{i,j+dl+1,l}(0\le l\le k+dr-1)$。表示在 $b_{i+1}$ 右边，与上一种情况同理。</li>
</ul>
<p>转移完后，答案即为 $\sum_{j=0}^{2n-1}\sum_{k=0}^{2n-1}f_{1,j,k}$。时间复杂度 $\mathcal{O}(n^4)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>; <span class="keyword">int</span> a[N], dp[N][N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n - <span class="number">1</span>; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    std::<span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">2</span> * n); dp[n][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> nxtl = i, nxtr = <span class="number">2</span> * n - i, v,</span><br><span class="line">        dl = a[nxtl] != a[nxtl + <span class="number">1</span>], dr = a[nxtr] != a[nxtr - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= <span class="number">2</span> * n; ++l) <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt;= <span class="number">2</span> * n; ++r)</span><br><span class="line">        &#123;</span><br><span class="line">            v = dp[i + <span class="number">1</span>][l][r]; <span class="keyword">if</span> (!v) <span class="keyword">continue</span>;</span><br><span class="line">            (dp[i][l + dl][r + dr] += v) %= mod; <span class="comment">//b_i 与 b_&#123;i+1&#125; 重合</span></span><br><span class="line">            <span class="comment">//b_i 在 b_&#123;i+1&#125; 左边</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= l + dl - <span class="number">1</span>; ++k) (dp[i][k][r + dr + <span class="number">1</span>] += v) %= mod; </span><br><span class="line">            <span class="comment">//b_i 在 b_&#123;i+1&#125; 右边</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= r + dr - <span class="number">1</span>; ++k) (dp[i][l + dl + <span class="number">1</span>][k] += v) %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= <span class="number">2</span> * n - <span class="number">1</span>; ++l) <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt;= <span class="number">2</span> * n - <span class="number">1</span>; ++r)</span><br><span class="line">        (ans += dp[<span class="number">1</span>][l][r]) %= mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhiyangfan1234.github.io/2022/01/24/AtCoder%20Regular%20Contest%20131%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhiyangfan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhiyangfan 的博客小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/24/AtCoder%20Regular%20Contest%20131%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">AtCoder Regular Contest 131</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-01-24 17:00:23 / 修改时间：17:12:26" itemprop="dateCreated datePublished" datetime="2022-01-24T17:00:23+08:00">2022-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><del>开始前说一下（虽然估计也没人关心），我应该不会写 NOIp 游记了，因为马上期末时间紧张加上也没什么可写的，没考好就是单纯的菜。</del></p>
<p>upd: 发现 F 有日文题解，订完了，把总结放上。</p>
<h2 id="AtCoder-Regular-Contest-131做题总结"><a href="#AtCoder-Regular-Contest-131做题总结" class="headerlink" title="AtCoder Regular Contest 131做题总结"></a>AtCoder Regular Contest 131做题总结</h2><p>感觉我会做的题全是结论题，而且都是瞎猜中的（</p>
<h3 id="A-Two-Lucky-Numbers"><a href="#A-Two-Lucky-Numbers" class="headerlink" title="A - Two Lucky Numbers"></a>A - Two Lucky Numbers</h3><p>给出 $A,B$，构造出一个 $x$ 满足 $x\le 10^{18}$，且在十进制表示下 $A$ 是 $x$ 的子串，$B$ 是 $2x$ 的子串。($1\le A,B&lt;10^8$) </p>
<p>考虑把 $x$ 分成两部分考虑，前一半是 $A$，后一半是 $\dfrac{B}{2}$，中间用 $0$ 相连保证不会相互打扰。这样 $x$ 就一定有 $A$ 作为子串，$2x$ 一定有 $B$ 作为子串。当然要考虑 $B\equiv1\pmod{2}$ 的情况，这不成问题，我们让后一半是 $5B$ 就好。时间复杂度 $\mathcal{O}(1)$，且能保证这个数最多 $17$ 位。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a, b; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d0&quot;</span>, a); <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, b * <span class="number">5</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="B-Grid-Repainting-4"><a href="#B-Grid-Repainting-4" class="headerlink" title="B - Grid Repainting 4"></a>B - Grid Repainting 4</h3><p>给出一个 $h\times w$ 的表格，其中一些格子已经被染好 $\tt 1\sim 5$ 颜色的其中一个，剩下的为空格子。在空格子里填上 $\tt 1\sim 5$ 的颜色使得任意水平或竖直相邻的格子颜色不同，数据保证一定有解。($1\le h,w\le700$)</p>
<p>既然一定有解，我们暴力填就好了，这玩意没有后效性。非常 naive 的实现，时间复杂度 $\mathcal{O}(hw)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">10</span>; <span class="keyword">char</span> mp[N][N];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> nxt[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, mp[i] + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (mp[i][j] != <span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">vec</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">5</span>; ++k) vec[k] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> tx = i + nxt[k][<span class="number">0</span>], ty = j + nxt[k][<span class="number">1</span>];</span><br><span class="line">				<span class="keyword">if</span> (tx &lt; <span class="number">1</span> || tx &gt; n || ty &lt; <span class="number">1</span> || ty &gt; m || mp[tx][ty] == <span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">				vec[mp[tx][ty] - <span class="string">&#x27;0&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">5</span>; ++k) <span class="keyword">if</span> (!vec[k]) mp[i][j] = k + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, mp[i] + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="C-Zero-XOR"><a href="#C-Zero-XOR" class="headerlink" title="C - Zero XOR"></a>C - Zero XOR</h3><p>给出一个长为 $n$ 的序列 $a$，有两个人在这个序列上进行游戏。先手先拿后手后拿，如果拿完一个数字后剩下的数字异或和为 $0$ 则拿的人获胜游戏结束。问如果两个人足够聪明，先手是否能获胜。($1\le n\le4\times10^5,1\le a_i\le10^9,\bigoplus_{i=1}^n a_i\ne 0,\forall i\ne j$，都有 $a_i\ne a_j$)</p>
<p>先扔结论，如果 $\exist k$，满足 $\bigoplus_{i=1}^n a_i=a_k$，则先手获胜，否则 $n$ 为奇数先手获胜，$n$ 为偶数先手必败。这个结论的前一部分是显然的，而对于后一部分，我们可以概括为如果先手不能一步获胜，则后手可以一直避免先手获胜，直到取完最后一个。考虑 $a$ 序列中的其中一个极大地满足异或和为 $0$ 的子序列 $a_{i_1},a_{i_2},a_{i_3},\cdot\cdot\cdot,a_{i_k}$，后手只需要破坏掉这个序列，也就是任取 $a_{i_d},1\le d\le k$，就可以保证先手一定构造不出来异或和为 $0$ 的子序列（因为保证了 $\forall i\ne j$，都有 $a_i\ne a_j$），反之亦然，这样一直进行下去游戏就不会结束直到序列为空。这样就可以直接实现了，时间复杂度 $\mathcal{O}(n)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e5</span> + <span class="number">10</span>; <span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, sum = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]), sum ^= a[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="keyword">if</span> (sum == a[i]) &#123; <span class="built_in">puts</span>(<span class="string">&quot;Win&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">	n &amp; <span class="number">1</span> ? <span class="built_in">puts</span>(<span class="string">&quot;Win&quot;</span>) : <span class="built_in">puts</span>(<span class="string">&quot;Lose&quot;</span>); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="D-AtArcher"><a href="#D-AtArcher" class="headerlink" title="D - AtArcher"></a>D - AtArcher</h3><p>有一个数轴上的靶场，用长为 $m+1$ 的序列 $r$ 和长为 $m$ 的序列 $s$（$r$ 下标从 $0$ 开始，$s$ 下标从 $1$ 开始），其中 $r_0=0$。表示如果箭射到 $(r_{i-1},r_i]\cup[-r_{i},-r_{i-1})$ 区间中将会获得 $s_i$ 的分数，如果射的箭位于 $(-\infty,-r_m)\cup(r_m,\infty)$ 则得 $0$ 分。现在一共要射 $n$ 箭，问在箭与箭之间间隔至少为 $d$ 的情况下最多能获得多少分数。($1\le n,m\le10^5,1\le d\le10^6,0=r_0<r_1<r_2<\cdot\cdot\cdot<r_m<10^{11},10^{11}\ge s_0>s_1&gt;s_2&gt;\cdot\cdot\cdot s_m$)</p>
<p>在这个模型，显然我们的目标是尽量让箭都靠近中心部分，这样才能尽可能最大化得分。也就是说，箭与箭之间的间隔要小，即卡到最小值 $d$。原问题就变为了在数轴上扎 $n$ 支间隔为 $d$ 的箭使得分最大。显然一共只有 $d$ 种情况（因为 $[0,d)$ 里必然有一支箭，否则得分一定不优，那剩下的情况就只有 $d$ 种了），一个 naive 的想法就是去枚举这些情况分别计算，但这样时间复杂度 $\mathcal{O}(nd)$，显然无法接受。发现其实不同种情况之间区别不大，所以考虑只算一种情况，然后其他情况就在这种情况上加加减减就好了。注意到对于每种得分，它对 $d$ 种情况的贡献区间是连续的（因为每次只走一步），所以做的时候统计一下贡献就好了，前缀和一下就可以做到 $\mathcal{O}(n+m+d)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>; <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll s[N], r[N], ans[N]; <span class="keyword">int</span> n, m, d;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(ll x, ll y, ll w, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (y &lt; x) <span class="keyword">return</span> ;</span><br><span class="line">	ans[x] += w; ans[y + <span class="number">1</span>] -= w;</span><br><span class="line">    <span class="comment">//这里的判断是因为当是最后一支箭的时候显然给正数更优，所以就不给负数了</span></span><br><span class="line">	<span class="keyword">if</span> (p &lt;= n / <span class="number">2</span>) ans[d - y] += w, ans[d - x + <span class="number">1</span>] -= w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;d);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;r[i]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;s[i]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, now = <span class="number">1</span>; i &lt;= (n - <span class="number">1</span>) / <span class="number">2</span> + <span class="number">1</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		ll lst = (ll)d * (i - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">while</span> (now &lt;= m &amp;&amp; r[now] &lt; (ll)d * i)</span><br><span class="line">			<span class="built_in">add</span>(lst - (ll)d * (i - <span class="number">1</span>), r[now] - (ll)d * (i - <span class="number">1</span>), s[now], i),</span><br><span class="line">			lst = r[now] + <span class="number">1</span>, ++now;</span><br><span class="line">		<span class="built_in">add</span>(lst - (ll)d * (i - <span class="number">1</span>), d, s[now], i);</span><br><span class="line">	&#125;</span><br><span class="line">	ll maxn = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= d; ++i) ans[i] += ans[i - <span class="number">1</span>], maxn = std::<span class="built_in">max</span>(maxn, ans[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, std::<span class="built_in">max</span>(ans[<span class="number">0</span>], maxn));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="E-Christmas-Wreath"><a href="#E-Christmas-Wreath" class="headerlink" title="E - Christmas Wreath"></a>E - Christmas Wreath</h3><p>有一张 $n$ 个结点的完全图，给它的边三元染色，使得不存在异色三元环，且每种颜色出现次数相同。构造方案或报告无解。($3\le n\le50$)</p>
<p>一个重要的想法是，只要所有点出边都相同就一定没有异色三元环。所以我们的问题就变为了给每个点分配一种颜色给它连向所有编号比它大的结点的边，使得最后所有颜色出现次数相同。首先一个必要条件是 $\dfrac{n(n-1)}{2}\equiv0\pmod{3}$，证明显然。然后对于每个未被分配颜色的点，我们把它分配一种新颜色，然后求出一种 $\frac{n(n-1)}{6}-x$ 的用剩余的数对应边数划分的方式（其中 $x$ 表示当前结点贡献的对应颜色边的个数），并把划分出来的数全部打上同一种颜色。分配完三种颜色后如果存在方案就有解，反之无解。（其实这里应该证一下如果不存在这样的构造方式就一定无解，但我实在不会了/kk）这里我不是很确定是不是只要满足 $\dfrac{n(n-1)}{2}\equiv0\pmod{3},n\ne3,4$ 就一定能构造，反之我的代码加上了 $3,4$ 特判最后不判断是否有解就能直接过去了。划分数的复杂度我一直不是很清楚，但对于 $n\le 50$ 肯定是稳的。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">60</span>; <span class="keyword">int</span> col[N], vis[N], n, ok;</span><br><span class="line"><span class="keyword">char</span> to[<span class="number">4</span>] = &#123;<span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;W&#x27;</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> aim, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!aim) <span class="keyword">return</span> ok = <span class="number">1</span>, <span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span> &amp;&amp; !ok; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (vis[i] || aim - i &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">		col[i] = c; vis[i] = <span class="number">1</span>; <span class="built_in">work</span>(aim - i, c);</span><br><span class="line">		<span class="keyword">if</span> (!ok) vis[i] = <span class="number">0</span>, col[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n); <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (((n * (n - <span class="number">1</span>) / <span class="number">2</span>) % <span class="number">3</span>) || n == <span class="number">3</span> || n == <span class="number">4</span>) &#123; <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>); <span class="keyword">int</span> d = n * (n - <span class="number">1</span>) / <span class="number">6</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">		vis[i] = <span class="number">1</span>; col[i] = ++cnt; ok = <span class="number">0</span>; <span class="built_in">work</span>(d - i, cnt);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i, <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) <span class="built_in">putchar</span>(to[col[i]]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="F-ARC-Stamp"><a href="#F-ARC-Stamp" class="headerlink" title="F - ARC Stamp"></a>F - ARC Stamp</h3><p>在仅有 <code>A</code>，<code>R</code>，<code>C</code> 组成的字符串 $S$ 上定义如下操作：</p>
<ul>
<li>将一段连续的三个字符替换为 <code>ARC</code>。</li>
</ul>
<p>现在在某个 $S$ 上执行了上述操作至多 $k$ 次得到了一个字符串 $T$。给出字符串 $T$，求对应的字符串 $S$ 有多少种，答案对 $998,244,353$ 取模。($3\le|T|\le5\times10^3,0\le k\le10^4$)</p>
<p>有个很显然的切入点是 $T$ 中本来就有的 <code>ARC</code> 子串，它们在原来的 $S$ 上显然可以被表示为 $3$ 个任意的字符，这也是对应 $S$ 可能极多的原因。为了方便，我们把能表示为任意字符的位置替换为 <code>?</code>。比如样例 1 中，如果只考虑连续的 <code>ARC</code>，$T$ 对应的 $S$ 即为 <code>???C???</code>。但只知道这些是不够的，除了 <code>ARC</code> 可以被替换外，它的前后缀也是有可能被替换的。比如对于 <code>AR?</code> 或者 <code>??C</code> 之类的子串，我们也能找到一种方式使得它变为 <code>???</code>。想到这里其实本题的思路就比较明朗了，就是根据题目中的规定一步步扩大 <code>?</code> 的范围，并在这个过程中数数。</p>
<p>计数题，且有明显过程划分（即操作了多少次，现在操作完的序列）我们考虑 $\rm dp$。一个比较 naive 的状态是设 $f_{i,j}$ 表示对于 $T$ 的前 $i$ 位，操作了 $j$ 次能对应的 $S$ 个数。但从这种状态设计切入时，我们发现每次只增加一个字符跟我们上文分析的不太对应，因为我们要知道的时这个字符对应的前后关系。所以考虑把原 $T$ 分为若干个块，我们的操作就是在这个块上进行转移。</p>
<p>具体来讲，一个块指的就是具有完整意义的上下文，共有 <code>[A]</code>，<code>[AR]</code>，<code>[ARC]</code>，<code>[C]</code>，<code>[RC]</code>，<code>[R]</code>，<code>[X]</code> 这么几种形式。其中前几种比较好理解，就是我们刚刚说的 <code>ARC</code> 及其前后缀，但对于 <code>[R]</code> 和 <code>[X]</code> 可能就比较令人困惑了。事实上，考虑这样的一个串 <code>???R???</code>，即使 <code>R</code> 不是前后缀也有可能被 <code>?</code> 代替，需要特殊处理。<code>[X]</code> 表示这里不可能被 <code>?</code> 替代，是个占位符。</p>
<p>把原串分为上述若干块后就可以重新设计 $\rm dp$ 状态了。考虑设 $f_{i,j}$ 表示对于 $T$ 的前 $i$ 个块，操作了 $j$ 次（其实就是把 $j$ 个块变为 <code>?</code>）对应的 $S$ 个数。但我们发现这是不够的，想知道 <code>[AR]</code> 之类的块能不能变为 <code>?</code> 需要上下文，所我们还需要一维 $0/1$ 表示 $i,i+1$ 是否全部变成 <code>?</code> 了，具体作用会在转移中说明。</p>
<p>接下来就考虑转移了，根据块种类不一样一共有 $7$ 种情况（下文 $v_i$ 表示第 $i$ 个块）。</p>
<ol>
<li><p>$v_{i+1}=$  <code>[ARC]</code>，则有五种可能的转移：</p>
<ul>
<li>$f_{i+1,j,0}=f_{i+1,j,0}+f_{i,j,0}$ 表示不变。</li>
<li>$f_{i+1,j+1,0}=f_{i+1,j+1,0}+27f_{i,j,1}$ 表示把 $i+1$ 块变为 <code>?</code>，则这个块有 $3^3=27$ 种取法。</li>
<li>$f_{i+1,j+1,0}=f_{i+1,j+1,0}+26f_{i,j,0}$ 表示把 $i+1$ 块变为 <code>?</code>，因为 $i+1$ 上一个没变为 <code>?</code> 且下一个也没变为 <code>?</code>，所以原来的不能是 <code>ARC</code>（不然不等于没变嘛，之后类似的情况解释同这个），除此之外有 $3^3-1=26$ 种。</li>
<li>$f_{i+1,j+1,1}=f_{i+1,j+1,1}+27f_{i,j,0}$ 解释同 2。</li>
<li>$f_{i+1,j+1,1}=f_{i+1,j+1,1}+27f_{i,j,1}$ 解释同 2.</li>
</ul>
</li>
<li><p>$v_{i+1}=$  <code>[AR]</code>，则有三种可能的转移（后面那个块必须是 <code>?</code>）：</p>
<ul>
<li>$f_{i+1,j,0}=f_{i+1,j,0}+f_{i,j,0}$ 表示不变。</li>
<li>$f_{i+1,j,1}=f_{i+1,j,1}+8f_{i,j,0}$ 表示把 $i+1$ 块变为 <code>?</code>，$i+1$ 上一个没变 <code>?</code>，后面的 <code>?</code> 确定了，所以原来的不能是 <code>AR</code>，除此之外有 $3^2-1=8$ 种。</li>
<li>$f_{i+1,j,1}=f_{i+1,j,1}+9f_{i,j,1}$ 表示把 $i+1$ 块变为 <code>?</code>，共有 $3^2=9$ 种取法。</li>
</ul>
</li>
<li><p>$v_{i+1}=$  <code>[A]</code>，则有三种可能的转移（后面的块必须是 <code>?</code>）：</p>
<ul>
<li>$f_{i+1,j,0}=f_{i+1,j,0}+f_{i,j,0}$ 表示不变。</li>
<li>$f_{i+1,j,1}=f_{i+1,j,1}+2f_{i,j,0}$ 表示把 $i+1$ 块变为 <code>?</code>，$i+1$ 上一个没变 <code>?</code>，后面的 <code>?</code> 确定了，所以原来的不能是 <code>A</code>，除此之外有 $3^1-1=2$ 种。</li>
<li>$f_{i+1,j,1}=f_{i+1,j,1}+3f_{i,j,1}$ 表示把 $i+1$ 块变为 <code>?</code>，共有 $3^1=3$ 种取法。</li>
</ul>
</li>
<li><p>$v_{i+1}=$  <code>[C]</code>，则有三种可能的转移（上一块必须是 <code>?</code>）：</p>
<ul>
<li>$f_{i+1,j,0}=f_{i+1,j,0}+f_{i,j,0}$ 表示不变。</li>
<li>$f_{i+1,j,0}=f_{i+1,j,0}+2f_{i,j,1}$ 表示把 $i+1$ 块变为 <code>?</code>，$i+1$ 下一个没变 <code>?</code>，前面的 <code>?</code> 确定了，所以原来的不能是 <code>C</code>，除此之外有 $3^1-1=2$ 种。</li>
<li>$f_{i+1,j,1}=f_{i+1,j,1}+3f_{i,j,1}$ 表示把 $i+1$ 块变为 <code>?</code>，共有 $3^1=3$ 种取法。</li>
</ul>
</li>
<li><p>$v_{i+1}=$  <code>[RC]</code>，则有三种可能的转移（上一块必须是 <code>?</code>）：</p>
<ul>
<li>$f_{i+1,j,0}=f_{i+1,j,0}+f_{i,j,0}$ 表示不变。</li>
<li>$f_{i+1,j,0}=f_{i+1,j,0}+8f_{i,j,1}$ 表示把 $i+1$ 块变为 <code>?</code>，$i+1$ 下一个没变 <code>?</code>，前面的 <code>?</code> 确定了，所以原来的不能是 <code>RC</code>，除此之外有 $3^2-1=8$ 种。</li>
<li>$f_{i+1,j,1}=f_{i+1,j,1}+9f_{i,j,1}$ 表示把 $i+1$ 块变为 <code>?</code>，共有 $3^2=9$ 种取法。</li>
</ul>
</li>
<li><p>$v_{i+1}=$  <code>[R]</code>，则有两种可能的转移（上一块和下一块都必须是 <code>?</code>）：</p>
<ul>
<li>$f_{i+1,j,0}=f_{i+1,j,0}+f_{i,j,0}$ 表示不变。</li>
<li>$f_{i+1,j,1}=f_{i+1,j,1}+2f_{i,j,1}$ 表示把 $i+1$ 块变为 <code>?</code>，前后的 <code>?</code> 都确定了，所以原来的不能是 <code>R</code>，除此之外有 $3^1-1=2$ 种。</li>
</ul>
</li>
<li><p>$v_{i+1}=$  <code>[X]</code>，则有一种可能的转移（无论怎样都不能变成 <code>?</code>）：</p>
<ul>
<li>$f_{i+1,j,0}=f_{i+1,j,0}+f_{i,j,0}$ 表示不变。</li>
</ul>
</li>
</ol>
<p>分好块后直接跑上述 $\rm dp$ 即可（分块的方法可以参考代码），时间复杂度 $\mathcal{O}(|T|K)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e3</span> + <span class="number">10</span>, mod = <span class="number">998244353</span>;</span><br><span class="line">std::string s; <span class="keyword">int</span> k;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> std::vector&lt;std::string&gt; <span class="title">getSec</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;std::vector&lt;std::string&gt;&gt; a; <span class="keyword">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; sl, sr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="number">2</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">substr</span>(i, <span class="number">3</span>) == <span class="string">&quot;ARC&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> l = i, r = i + <span class="number">3</span>; std::vector&lt;std::string&gt; b;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;   </span><br><span class="line">                <span class="keyword">if</span> (l &gt;= <span class="number">1</span> &amp;&amp; s.<span class="built_in">substr</span>(l - <span class="number">1</span>, <span class="number">1</span>) == <span class="string">&quot;A&quot;</span>)</span><br><span class="line">                    b.<span class="built_in">push_back</span>(<span class="string">&quot;A&quot;</span>), --l; </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (l &gt;= <span class="number">2</span> &amp;&amp; s.<span class="built_in">substr</span>(l - <span class="number">2</span>, <span class="number">2</span>) == <span class="string">&quot;AR&quot;</span>)</span><br><span class="line">                    b.<span class="built_in">push_back</span>(<span class="string">&quot;AR&quot;</span>), --l, --l;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            std::<span class="built_in">reverse</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>()); b.<span class="built_in">push_back</span>(<span class="string">&quot;ARC&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (r &lt;= n - <span class="number">1</span> &amp;&amp; s.<span class="built_in">substr</span>(r, <span class="number">1</span>) == <span class="string">&quot;C&quot;</span>)</span><br><span class="line">                    b.<span class="built_in">push_back</span>(<span class="string">&quot;C&quot;</span>), ++r;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (r &lt;= n - <span class="number">2</span> &amp;&amp; s.<span class="built_in">substr</span>(r, <span class="number">2</span>) == <span class="string">&quot;RC&quot;</span>)</span><br><span class="line">                    b.<span class="built_in">push_back</span>(<span class="string">&quot;RC&quot;</span>), ++r, ++r;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sl.<span class="built_in">push_back</span>(l); sr.<span class="built_in">push_back</span>(r); a.<span class="built_in">push_back</span>(b);</span><br><span class="line">        &#125;</span><br><span class="line">    std::vector&lt;std::string&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)a.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">1</span>) </span><br><span class="line">            res.<span class="built_in">push_back</span>(sl[i] - sr[i - <span class="number">1</span>] == <span class="number">1</span> &amp;&amp; s[sr[i - <span class="number">1</span>]] == <span class="string">&#x27;R&#x27;</span> ? <span class="string">&quot;R&quot;</span> : <span class="string">&quot;X&quot;</span>);</span><br><span class="line">        res.<span class="built_in">insert</span>(res.<span class="built_in">end</span>(), a[i].<span class="built_in">begin</span>(), a[i].<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(std::vector&lt;std::string&gt; sect)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = sect.<span class="built_in">size</span>(); std::vector&lt;<span class="keyword">int</span>&gt; dp[<span class="number">2</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = std::vector&lt;<span class="keyword">int</span>&gt;(k + <span class="number">1</span>, <span class="number">0</span>); dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        std::vector&lt;<span class="keyword">int</span>&gt; ndp[<span class="number">2</span>]; ndp[<span class="number">0</span>] = ndp[<span class="number">1</span>] = std::vector&lt;<span class="keyword">int</span>&gt;(k + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            (ndp[<span class="number">0</span>][j] += dp[<span class="number">0</span>][j]) %= mod; <span class="keyword">if</span> (j == k) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (sect[i] == <span class="string">&quot;ARC&quot;</span>)</span><br><span class="line">                ndp[<span class="number">0</span>][j + <span class="number">1</span>] = (ndp[<span class="number">0</span>][j + <span class="number">1</span>] + <span class="number">26ll</span> * dp[<span class="number">0</span>][j] + <span class="number">27ll</span> * dp[<span class="number">1</span>][j]) % mod,</span><br><span class="line">                ndp[<span class="number">1</span>][j + <span class="number">1</span>] = (ndp[<span class="number">1</span>][j + <span class="number">1</span>] + <span class="number">27ll</span> * dp[<span class="number">0</span>][j] + <span class="number">27ll</span> * dp[<span class="number">1</span>][j]) % mod;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sect[i] == <span class="string">&quot;A&quot;</span>)</span><br><span class="line">                ndp[<span class="number">1</span>][j + <span class="number">1</span>] = (ndp[<span class="number">1</span>][j + <span class="number">1</span>] + <span class="number">2ll</span> * dp[<span class="number">0</span>][j] + <span class="number">3ll</span> * dp[<span class="number">1</span>][j]) % mod;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sect[i] == <span class="string">&quot;AR&quot;</span>)</span><br><span class="line">                ndp[<span class="number">1</span>][j + <span class="number">1</span>] = (ndp[<span class="number">1</span>][j + <span class="number">1</span>] + <span class="number">8ll</span> * dp[<span class="number">0</span>][j] + <span class="number">9ll</span> * dp[<span class="number">1</span>][j]) % mod;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sect[i] == <span class="string">&quot;C&quot;</span>)</span><br><span class="line">                ndp[<span class="number">0</span>][j + <span class="number">1</span>] = (ndp[<span class="number">0</span>][j + <span class="number">1</span>] + <span class="number">2ll</span> * dp[<span class="number">1</span>][j]) % mod,</span><br><span class="line">                ndp[<span class="number">1</span>][j + <span class="number">1</span>] = (ndp[<span class="number">1</span>][j + <span class="number">1</span>] + <span class="number">3ll</span> * dp[<span class="number">1</span>][j]) % mod;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sect[i] == <span class="string">&quot;RC&quot;</span>)</span><br><span class="line">                ndp[<span class="number">0</span>][j + <span class="number">1</span>] = (ndp[<span class="number">0</span>][j + <span class="number">1</span>] + <span class="number">8ll</span> * dp[<span class="number">1</span>][j]) % mod,</span><br><span class="line">                ndp[<span class="number">1</span>][j + <span class="number">1</span>] = (ndp[<span class="number">1</span>][j + <span class="number">1</span>] + <span class="number">9ll</span> * dp[<span class="number">1</span>][j]) % mod;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sect[i] == <span class="string">&quot;R&quot;</span>)</span><br><span class="line">                ndp[<span class="number">1</span>][j + <span class="number">1</span>] = (ndp[<span class="number">1</span>][j + <span class="number">1</span>] + <span class="number">2ll</span> * dp[<span class="number">1</span>][j]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>] = ndp[<span class="number">0</span>]; dp[<span class="number">1</span>] = ndp[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; ++i) (ans += dp[<span class="number">0</span>][i]) %= mod;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); std::cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    std::cin &gt;&gt; s &gt;&gt; k;</span><br><span class="line">    std::vector&lt;std::string&gt; sect = <span class="built_in">getSec</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">solve</span>(sect)); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhiyangfan1234.github.io/2022/01/24/AtCoder%20Regular%20Contest%20132/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhiyangfan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhiyangfan 的博客小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/24/AtCoder%20Regular%20Contest%20132/" class="post-title-link" itemprop="url">AtCoder Regular Contest 132</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-01-24 17:00:23 / 修改时间：17:12:33" itemprop="dateCreated datePublished" datetime="2022-01-24T17:00:23+08:00">2022-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="AtCoder-Regular-Contest-132"><a href="#AtCoder-Regular-Contest-132" class="headerlink" title="AtCoder Regular Contest 132"></a>AtCoder Regular Contest 132</h2><p>因为没看出来 D 的贪心思路痛失 2021 年的最后一场比赛上蓝的机会/ll</p>
<h3 id="A-Permutation-Grid"><a href="#A-Permutation-Grid" class="headerlink" title="A - Permutation Grid"></a>A - Permutation Grid</h3><p>给出两个 $1\sim n$ 的排列 $\mathcal{R,C}$。构造出一组满足如下条件的网格：</p>
<ul>
<li>网格的第 $i$ 行有 $\mathcal{R}_i$ 个黑格子。</li>
<li>网格的第 $j$ 列有 $\mathcal{C}_j$ 个黑格子。</li>
</ul>
<p>$q$ 次询问 $(r_i,c_i)$ 是否为黑色的。($1\le n,q\le 10^5$)</p>
<p>这道题的结论是，当且仅当 $\mathcal{R}_i+\mathcal{C}_j&gt; n$ 时，$(i,j)$ 是黑色格子。证明如下：</p>
<p>首先考虑小的，特殊的情况。简单起见，下面的情况我们先假设 $\mathcal{R}_i=\mathcal{C}_i=i$。比如当 $n=4$ 时，我们可以构造出如下网格（<code>#</code> 表示黑色）：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...#</span><br><span class="line">..##</span><br><span class="line">.###</span><br><span class="line">####</span><br></pre></td></tr></table></figure><br>这个显然满足上述条件，更小的情况也亦然。接下来考虑归纳法，如果命题对于 $n-1$ 的网格成立，我们能不能推出对于 $n$ 的网格其成立呢？显然可以。我们考虑两个图像之间的联系，所有黑格子向右走一格，在每一行的最上面增加一个黑格子。也就是说，对于原来的点 $(i,j)$ 会变为 $(i,j+1)$。因为 $i+j&gt; n-1$，所以 $i+j+1&gt;n$。而新的格子满足 $(i,n-i+1)$，而 $i+n-i+1=n+1&gt;n$。所以我们能证明 $n$ 的网格内所有黑色格子满足横纵坐标之和大于 $n$。这样通过归纳法，我们就能证明，当 $\mathcal{R}_i=\mathcal{C}_i=i$ 时，对于所有的 $n$，都有黑格子 $(i,j)$ 满足 $\mathcal{R}_i+\mathcal{C}_j&gt;n$。现在考虑一般情况，我们需要的是任意交换两个排列元素的想法。其实很简单，我们假设交换的是 $\mathcal{R}$，则只需要交换对应的两行即可。发现列不被影响，而行达到了要求。$\mathcal{C}$ 的情况同理。这样我们就把情况推向了一般情况，得到原命题成立。</p>
<p>接下来的问题就是套公式了，时间复杂度 $\mathcal{O}(n+q)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>; <span class="keyword">int</span> r[N], c[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;r[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> q; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= q; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span> (r[x] + c[y] &lt;= n) <span class="built_in">putchar</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">putchar</span>(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="B-Shift-and-Reverse"><a href="#B-Shift-and-Reverse" class="headerlink" title="B - Shift and Reverse"></a>B - Shift and Reverse</h3><p>给出一个 $1\sim n$ 的排列 $\mathcal{P}$，可以进行以下操作若干次：</p>
<ol>
<li>整体交换排列，也就是令 $\mathcal{P}_i(i&lt;n-i+1)$ 与 $\mathcal{P}_{n-i+1}$ 交换。</li>
<li>把第一项扔到最后。</li>
</ol>
<p>找出使原排列按升序排列的最小操作次数，数据保证有解。($2\le n\le10^5$)</p>
<p>注意到按 $2\rightarrow 1\rightarrow 2$ 的顺序进行操作等于只操作 $1$，按 $1\rightarrow 1$ 的顺序进行操作等于啥都没干。所以有在最优策略下操作 $1$ 仅能在操作序列的末尾出现。这样就简单了，我们只需要考虑开头交换不交换的情况。（末尾交换在下文阐述）不管是否交换，我们接下来要对得到的序列进行 $2$ 操作直到满足它是倒序或升序。而因为数据保证有解，所以只可能是以下两种情况（以 $n=6$ 为例）：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 6</span><br></pre></td></tr></table></figure><br>此时已经有序。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 4 5 6 1 2</span><br></pre></td></tr></table></figure><br>此时只是把有序序列分成两部分并交换一下而已。</p>
<p>显然前者不需要任何操作。而后者理论上讲需要分讨最后一步是否交换来决定操作 $2$ 是扔到 $n$ 停止还是 $1$ 停止。不过注意到 $1$ 显然在 $n$ 后面，所以这两种操作最终涉及到的操作次数均为 $x+1$，其中 $x$ 为扔到 $n$ 停需要的操作 $2$ 次数。</p>
<p>这样简单按照上述过程模拟一下就可以了，时间复杂度 $\mathcal{O}(n)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; p; ll ans; <span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> r)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y, flg = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (p[i] != i + <span class="number">1</span>) &#123; flg = <span class="number">0</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (flg) ans = std::<span class="built_in">min</span>(ans, (ll)r);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p[y] != n) ++y;</span><br><span class="line">        ans = std::<span class="built_in">min</span>(ans, r + y + <span class="number">1ll</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x), p.<span class="built_in">push_back</span>(x);</span><br><span class="line">    ans = <span class="number">1e18</span>; <span class="built_in">work</span>(<span class="number">0</span>); std::<span class="built_in">reverse</span>(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>()); <span class="built_in">work</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="C-Almost-Sorted"><a href="#C-Almost-Sorted" class="headerlink" title="C - Almost Sorted"></a>C - Almost Sorted</h3><p>给出一个由 $1\sim n,-1$ 组成的长为 $n$ 的序列 $a$ 和一个整数 $d$。求出满足以下条件的 $1\sim n$ 的排列 $\mathcal{P}$ 个数：</p>
<ul>
<li>$\forall 1\le i\le n,a_i\ne -1$，都有 $\mathcal{P}_i=a_i$，也即 $\mathcal{P}$ 可以由填充 $a$ 中的 $-1$ 得到。</li>
<li>$\forall 1\le i\le n$，都有 $|\mathcal{P}_i-i|\le d$。</li>
</ul>
<p>答案对 $998,244,353$ 取模。($1\le d\le 5,d\le n\le 500,\forall i\ne j,a_i,a_j\ne -1$，都有 $a_i\ne a_j$)</p>
<p>这个计数问题具有明显的阶段性，所以考虑 $\rm dp$ 求解。但如果只用当前填到第几个数来描述状态的话，显然具有后效性，因为 $-1$ 填啥是会对之后有影响的。但注意到 $d$ 是一个非常小的数，所以我们考虑把 $d$ 也加入状态的描述中，即在所有可能的 $2d+1$ 个数中，哪些已经被选过了。这样 $\rm dp$ 状态的设计就比较完备了。具体来讲，我们设 $f_{i,S}$ 表示对于第 $i$ 个数，所有可选的范围内已经被选的情况是 $S$。则每次转移时，我们枚举所有可能出现的数字，如果符合当前的 $S$ 可以转移，就累积上。最终答案即为 $\sum_Sf_{n,S}$。这里在代码中为了方便，我开的状态是拉满到 $d=5$ 的，不过如果 $d<5$ 时不应该存在的位为 $0$ 所以不影响。时间复杂度 $\mathcal{O}(n2^d)$。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, B = <span class="number">1</span> &lt;&lt; <span class="number">12</span>, mod = <span class="number">998244353</span>; <span class="keyword">int</span> f[N][B], p[N], hve[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, d; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;d);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (p[i] != <span class="number">-1</span>) hve[p[i]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> all = (<span class="number">1</span> &lt;&lt; <span class="number">11</span>) - <span class="number">1</span>; f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> S = <span class="number">0</span>; S &lt;= all; ++S)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[i] != <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//v 表示当前选的数对应到 S 上，S &gt;&gt; 1 表示可选的区间变化</span></span><br><span class="line">                <span class="keyword">int</span> k = p[i], v = k - i + <span class="number">5</span>, nxt = (S &gt;&gt; <span class="number">1</span>) | (<span class="number">1</span> &lt;&lt; v);</span><br><span class="line">                <span class="keyword">if</span> (((S &gt;&gt; (v + <span class="number">1</span>)) &amp; <span class="number">1</span>) == <span class="number">0</span>) (f[i][nxt] += f[i - <span class="number">1</span>][S]) %= mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = std::<span class="built_in">max</span>(<span class="number">1</span>, i - d); k &lt;= std::<span class="built_in">min</span>(n, i + d); ++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (hve[k]) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">int</span> v = k - i + <span class="number">5</span>, nxt = (S &gt;&gt; <span class="number">1</span>) | (<span class="number">1</span> &lt;&lt; v);</span><br><span class="line">                    <span class="keyword">if</span> (((S &gt;&gt; (v + <span class="number">1</span>)) &amp; <span class="number">1</span>) == <span class="number">0</span>) (f[i][nxt] += f[i - <span class="number">1</span>][S]) %= mod;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> S = <span class="number">0</span>; S &lt;= all; ++S) (ans += f[n][S]) %= mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="D-Between-Two-Binary-Strings"><a href="#D-Between-Two-Binary-Strings" class="headerlink" title="D - Between Two Binary Strings"></a>D - Between Two Binary Strings</h3><p>对于 $\tt 01$ 串 $s$ 我们定义它的美丽值为满足 $s_i=s_{i+1},1\le i&lt;|s|$ 的 $i$ 个数。定义集合 $S_{n,m}$ 表示有 $n$ 个 $\tt 0$ 和 $m$ 个 $\tt 1$ 的 $\tt 01$ 串集合。对于 $s_1,s_2\in S_{n,m}$，我们定义 $s_1,s_2$ 之间的距离 $\mathrm{dis}(s_1,s_2)$ 为通过交换相邻字符使 $s_1=s_2$ 的最小交换次数。此外，对于 $s_1,s_2,s_3\in S_{n,m}$，如果 $\mathrm{dis}(s_1,s_3)=\mathrm{dis}(s_1,s_2)+\mathrm{dis}(s_2,s_3)$ 则称 $s_2$ 在 $s_1,s_3$ 中间。给出 $s,t\in S_{n,m}$，求出在 $s,t$ 中间的 $\tt 01$ 串中美丽值的最大值。($2\le n+m\le 3\times10^5,0\le n,m$)</p>
<p>这一看就很结论题，我先按照我当时的思路粗略推一遍结论，再按照题解的思路较为严格的证明它。首先我们需要搞清楚所谓的 $\rm dis$ 到底是什么。因为这是 $\tt 01$ 串，所以 $\mathrm{dis}(s_1,s_2)$ 其实就是 $s_1$ 中的所有 $\tt 0$ 和其在 $s_2$ 中对应的 $\tt 0$ 之间的距离和。因为无论如何你都要把这些 $\tt 0$ 交换到一起，而且因为对应关系，交换这个不会影响那个。所以我们能得出在 $s,t$ 之间的字符具有的性质：它的所有 $\tt 0$ 只能在 $s$ 对应的 $\tt 0$ 和 $t$ 对应的 $\tt 0$ 中间。更进一步，我们有在 $s,t$ 之间的字符要满足前 $i$ 个字符中的 $\tt 0$ 个数要在 $s,t$ 之间。这样，我们就能贪心去做了。具体来讲，只要我们决定了首位是什么，之后每次在合法的前提下，尽量选的和上一次选的相同就好了。</p>
<p>刚刚上面是我没怎么经过特别验证的粗略证明，接下来我们来看看题解的证明。考虑把 $\tt 01$ 串看成一个 $n+m$ 步从 $(0,0)$ 走到 $(n,m)$ 的路径。生成这路径的方法是：</p>
<ul>
<li>当我们在 $(x,y)$ 的时候，如果 $s_i=\tt 0$，则我们去 $(x+1,y)$，否则去 $(x,y+1)$。</li>
</ul>
<p>这样我们考虑交换两个相邻的字符会发生什么事，比如对于 $s=\tt0100$，我们交换 $s_2,s_3$（图片来自 AT 题解）：</p>
<p><img src="https://img.atcoder.jp/arc132/c7f5a1fd6f001164d8c46f5f63c51a46.png" alt=""></p>
<p>这相当于把一角翻过去。这样我们就能用这个新的模型来描述 $s_1$ 在 $s,t$ 之间了：$s_1$ 对应的路径位于 $s,t$ 对应的路径之间！不仅如此，最大化美丽值其实相当于最少的拐弯次数！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhiyangfan1234.github.io/2022/01/24/AtCoder%20Grand%20Contest%20011/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhiyangfan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhiyangfan 的博客小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/24/AtCoder%20Grand%20Contest%20011/" class="post-title-link" itemprop="url">AtCoder Grand Contest 011</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-01-24 17:00:23 / 修改时间：17:11:51" itemprop="dateCreated datePublished" datetime="2022-01-24T17:00:23+08:00">2022-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="AtCoder-Grand-Contest-011"><a href="#AtCoder-Grand-Contest-011" class="headerlink" title="AtCoder Grand Contest 011"></a>AtCoder Grand Contest 011</h2><p>不得不说，这场的 A 让我回想起 CSP2021 的廊桥分配了，于是啥也没写先打了个 <code>std::sort</code> /cy。</p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="A-Airport-Bus"><a href="#A-Airport-Bus" class="headerlink" title="A - Airport Bus"></a>A - Airport Bus</h4><p>有 $n$ 个人来到机场，其中第 $i$ 个人将会在 $t_i$ 时刻到达。他们都想从机场乘坐公交车前往市区，其中每辆公交车可以载 $c$ 个人。如果一个人等待的时间超过 $k$ 时刻，他就会生气。形式化讲，$\forall 1\le i\le n$，都应该在 $[t_i,t_i+k]$ 时刻至少有一辆公交车出发。问至少需要几辆公交车才能满足需求，公交车的出发时间可以不为整数，可以相同。($2\le n\le10^5,1\le c,k,t_i\le10^9$)</p>
<p><strong>首先注意到题目并没有保证 $t_i$ 单调递增，我们先写上一个 <code>std::sort</code> 排一下序。</strong></p>
<p>排序过后其实原问题就很简单了，考虑一个在 $r$ 时刻出发的公交车能载的乘客在 $t_i$ 上一定是一段区间 $[l,r]$ 满足 $r-l+1\le c,t_r-t_l\le k$。这样我们用一个指针，初始为 $1$，将它作为 $l$，并用它用二分去找能对应到的最大的 $r$，之后把指针指向 $r+1$ 就好了。找到几段区间对应的答案就是多少，时间复杂度 $\mathcal{O}(n\log n)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>; <span class="keyword">int</span> T[N], n, c, k, ans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> l = pos, r = n, mid, ans = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">	&#123;</span><br><span class="line">		mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (mid - pos + <span class="number">1</span> &gt; c) r = mid - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (T[mid] - T[pos] &lt;= k) ans = mid, l = mid + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (T[mid] - T[pos] &gt; k) r = mid - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;c, &amp;k); </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T[i]);</span><br><span class="line">	std::<span class="built_in">sort</span>(T + <span class="number">1</span>, T + n + <span class="number">1</span>); </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j; i &lt;= n; i = j + <span class="number">1</span>, ++ans) j = <span class="built_in">find</span>(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="B-Colorful-Creatures"><a href="#B-Colorful-Creatures" class="headerlink" title="B - Colorful Creatures"></a>B - Colorful Creatures</h4><p>有 $n$ 种奇怪的生物，每种生物均有大小和颜色，分别用 $a_i,i$ 来表示。每个生物能吃掉至多两倍于它大小的生物，如果一个大小为 $a$ 颜色为 $b$ 的生物吃掉了大小为 $c$ 颜色为 $d$ 的生物（$c\le 2a$）那么它们就会合并为一个颜色为 $b$，大小为 $a+c$ 的生物。问这 $n$ 种生物相互吃对方直到只剩一个生物时剩下的那个颜色有几种可能。($2\le n\le10^5,1\le a_i\le10^9$)</p>
<p>每种颜色想要最终留下来的最优策略应该是先把所有大小小于它的生物都吃掉，再从小到大吃比大小它大的生物，这样每次吃一个生物之前它已经达到了当前状态下可能达到的最大大小，如果这样还吃不掉就一定吃不掉了。所以我们考虑对 $a$ 序列排个序再求个前缀和，记为 $s$。则一种颜色 $i$（这里的下标为排序之后的下标）可能留下来的充要条件为：</p>
<script type="math/tex; mode=display">\forall{i\le j\le n-1},都有\;2s_j\ge a_{j+1}</script><p>原因显然。直接朴素计算是 $\mathcal{O}(n^2)$ 的，但优化也很简单。我们从后往前计算上述条件，找到第一个不满足的位置，前面所有的颜色都不会满足，这样就得到了符合条件的颜色数目了。时间复杂度 $\mathcal{O}(n\log n)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>; <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll; </span><br><span class="line"><span class="keyword">int</span> a[N]; ll sum[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, pos = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">	std::<span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i) <span class="keyword">if</span> (sum[i] * <span class="number">2</span> &lt; a[i + <span class="number">1</span>]) &#123; pos = i; <span class="keyword">break</span>; &#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n - pos); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="C-Squared-Graph"><a href="#C-Squared-Graph" class="headerlink" title="C - Squared Graph"></a>C - Squared Graph</h4><p>给出一张 $n$ 个点 $m$ 条边的简单无向图 $G=(V,E)$。想通过这张图构造出一张新的无向图 $G’=(V’,E’)$。其中 $|V’|=|V|^2$，且 $V’$ 中的每个元素可以用一个二元组 $(a,b)(a,b\in V)$ 来表示。新图的 $E’$ 集合按照如下规则生成：</p>
<ul>
<li>$((a,b),(a’,b’))\in E’$ 当且仅当 $(a,a’)\in E,(b,b’)\in E$。</li>
</ul>
<p>求 $G’$ 中有多少连通块。($2\le n\le10^5,0\le m\le10^5$)</p>
<p>以下讨论先假设原图连通。对于原条件的一个重要 Observation 是其相当于如下条件：</p>
<ul>
<li>$((a,b),(a’,b’))\in E’$ 当且仅当 $G$ 中存在一条从 $a$ 到 $a’$ 的路径，存在一条从 $b$ 到 $b’$ 的路径，且它们长度相同。</li>
</ul>
<p>当然，因为只要求了路径，我可以通过在某两个点之间来回跳随便给路径加上 $2$ 的长度。所以上述条件又可以改为：</p>
<ul>
<li>$((a,b),(a’,b’))\in E’$ 当且仅当 $G$ 中存在一条从 $a$ 到 $a’$ 的路径，存在一条从 $b$ 到 $b’$ 的 <strong>简单</strong> 路径，且它们 <strong>奇偶性</strong> 相同。</li>
</ul>
<p>想到奇偶性，我们可以想到奇环，这个环可以改变奇偶性，所以如果原图不是二分图，则两点之间既存在奇路径也存在偶路径，这样 $G’$ 就连通了。而如果是二分图，则我们可以黑白染色，相同颜色点之间路径为偶数，不同颜色点之间路径为奇数，这样 $G’$ 有两个连通块。</p>
<p>那原图如果不连通呢？从连通图到不连通图的转化显然是对每个连通块分别处理。但这里会涉及到一个问题，如果某个连通块是孤立点，则虽然它是二分图但无法进行黑白染色，需要特殊处理。为了方便，我们设 $G$ 中点的数量大于 $1$ 的二分图数量有 $a$ 个，非二分图数量有 $b$ 个，孤立点有 $c$ 个。</p>
<p>则答案应该为 $2a^2+2ab+b^2+c^2+2c(n-c)$。我们一项项来看，首先是 $2a^2$，相当于 $2a+4\times\dfrac{a(a-1)}{2}$，$2a$ 表示一个二分图连通块内部会贡献 $2$ 个连通块，$4\times\dfrac{a(a-1)}{2}$ 表示每个二分图连通块会和 <strong>其他</strong> 二分图连通块贡献 $4$ 个连通块。（两个连通块选择奇还是偶，在第一维还是第二维）然后是 $b^2$，相当于 $b+2\times\dfrac{b(b-1)}{2}$，$b$ 表示一个非二分图连通块内部会贡献 $1$ 个连通块，$2\times\dfrac{b(b-1)}{2}$ 表示每个非二分图连通块会和 <strong>其他</strong> 二分图连通块贡献 $2$ 个连通块。（在第一维还是第二维）然后是 $2ab$，表示每个二分图连通块会和其他非二分图造成 $2$ 的贡献。（在第一维还是第二维，选择的奇偶性固定了）最后是 $c^2+2c(n-c)$，因为孤立点之间不可能有边，所以 $c^2$ 表示第一二维相同的情况，$2c(n-c)$ 表示一二维不同的情况，$\times 2$ 是因为一二维可以交换。</p>
<p>有了结论之后，$\rm dfs$ 一遍求出 $a,b,c$ 套式子求解即可。时间复杂度 $\mathcal{O}(n)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>; <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span> <span class="keyword">int</span> v, next; &#125;E[N &lt;&lt; <span class="number">1</span>]; <span class="keyword">int</span> p[N], cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(p, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span> (p)); cnt = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123; E[cnt].v = v; E[cnt].next = p[u]; p[u] = cnt++; &#125;</span><br><span class="line"><span class="keyword">int</span> vis[N], tot, flag;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vis[u] = col; ++tot;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = p[u], v; i + <span class="number">1</span>; i = E[i].next)</span><br><span class="line">	&#123;</span><br><span class="line">		v = E[i].v; <span class="keyword">if</span> (vis[v]) &#123; <span class="keyword">if</span> (vis[v] != col * <span class="number">-1</span>) flag = <span class="number">1</span>; <span class="keyword">continue</span>; &#125;</span><br><span class="line">		<span class="built_in">dfs</span>(v, col * <span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">init</span>(); <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; ++i) </span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v), <span class="built_in">insert</span>(u, v), <span class="built_in">insert</span>(v, u);</span><br><span class="line">	<span class="comment">//cnt0:二分图连通块个数，cnt1:孤立点个数，cnt2:非二分图连通块个数</span></span><br><span class="line">	ll cnt0 = <span class="number">0</span>, cnt1 = <span class="number">0</span>, cnt2 = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="keyword">if</span> (!vis[i])</span><br><span class="line">		&#123;</span><br><span class="line">			tot = flag = <span class="number">0</span>; <span class="built_in">dfs</span>(i, <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span> (tot == <span class="number">1</span>) &#123; ++cnt1; <span class="keyword">continue</span>; &#125;</span><br><span class="line">			<span class="keyword">if</span> (flag) ++cnt2; <span class="keyword">else</span> ++cnt0;</span><br><span class="line">		&#125;</span><br><span class="line">	ans = cnt1 * cnt1 + <span class="number">2</span> * cnt1 * (n - cnt1) + </span><br><span class="line">	cnt2 * cnt2 + <span class="number">2</span> * cnt0 * cnt0 + <span class="number">2</span> * cnt0 * cnt2;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="D-Half-Reflector"><a href="#D-Half-Reflector" class="headerlink" title="D - Half Reflector"></a>D - Half Reflector</h4><p>有一些奇怪的水管，水管的状态可以是 $\tt A$ 或者 $\tt B$。如果从水管的一端扔进去一个球，则</p>
<ul>
<li>当它的状态为 $\tt A$ 时，球会 <strong>立即</strong> 从相同的一端弹回来，该水管的状态 <strong>立即</strong> 变为 $\tt B$。</li>
<li>当他的状态为 $\tt B$ 时，球会 <strong>立即</strong> 从另一端弹出，该水管的状态 <strong>立即</strong> 变为 $\tt A$。</li>
</ul>
<p>这里的立即指的是在收到下一个球之前就能完成。现在把 $n$ 个水管连成了一列，满足以下条件：</p>
<ul>
<li>$\forall 2\le i\le n$，都有如果球从第 $i$ 个水管的左端被弹出，则会立刻到达第 $i-1$ 个水管的右端。</li>
<li>$\forall 1\le i\le n-1$，都有如果球从第 $i$ 个水管的右端被弹出，则会立刻到达第 $i+1$ 个水管的左端。</li>
</ul>
<p>给出一列水管的初始状态 $S$，现在往第 $1$ 个水管的左端扔进去 $1$ 个球，等到它某从端弹出时再向第 $1$ 个水管扔球。扔 $k$ 个球后停止，问停止后所有水管的状态。可以证明球一定能被从某端弹出。($1\le n\le 2\times10^5,1\le k\le10^9$)</p>
<p>考虑扔一次球会带来什么改变，如果 $S_1=\tt A$，则 $S_1$ 会被变为 $\tt B$，其他的状态不变。如果 $S_1=\tt B$，那 $S_1$ 会变为 $\tt A$，然后求会进入后面的水管，我们来观察一下当后面的水管分别是 $\tt A,B$ 的时候，会发生什么：</p>
<ul>
<li><p>$S_2=\tt A$：</p>
<p>$\tt A\rightarrow A$，$\tt A\leftarrow B$，$\tt B\rightarrow B$，$\tt B\quad A\rightarrow$</p>
</li>
<li><p>$S_2=\tt B$：</p>
<p>$\tt A\rightarrow B$，$\tt A\quad A\rightarrow$</p>
</li>
</ul>
<p>可以看出，$S_2$ 一定会变为 $\tt A$，$S_1$ 会变为和 $S_2$ 原状态相反的状态。之后就变为一个类似的子问题了，这样可以得出结论：</p>
<ul>
<li>如果 $S_1=\tt A$，则 $S_1\Rightarrow\tt B$。</li>
<li>如果 $S_1=\tt B$，则 $\forall 1\le i\le n-1$，都有 $S_i$ 会变为 $S_{i+1}$ 原状态的相反状态，$S_n$ 变为 $\tt A$。</li>
</ul>
<p>一次扔球的状态转移直接朴素实现是 $\mathcal{O}(n)$，总时间复杂度即为 $\mathcal{O}(nk)$，显然无法接受。但注意到上述过程规律非常具有规律，可以考虑优化掉。其中一种可能的方式是我们把原始 $S$ 中所有偶数位都给翻转掉，这样一次操作只需要把 $S_1$ 删去，并在 $S$ 末尾加上 $\tt A$ 或 $\tt B$ （取决于 $n$ 的奇偶性）即可。这样操作后，奇数位变为了偶数位但没有翻转，是本应该是的相反值，偶数位变为了奇数位翻转过了，是正确的值，这样依然保证 $S$ 中仅有偶数位是翻转的，对于 $S_n$ 只需要看一下 $n$ 的奇偶性就能知道它应不应该翻转了。最后求解的时候把 $S$ 中的偶数位再翻回来即可。这样用双端队列我们可以做到 $\mathcal{O}(1)$ 处理每个小球。总时间复杂度为 $\mathcal{O}(k)$。常数小或许能过（试过了我的过不了/ll），但更稳妥的方式还是考虑再优化一下朴素的模拟扔球。</p>
<p>注意到 $S$ 的变化是有周期的。在 $2n$ 次变化后会形成环，且环的大小至多为 $2$（可以手玩体会一下）。那就简单了，我们只需要做 $2n+(k-2n)\bmod{2}$ 次就好。时间复杂度 $\mathcal{O}(n)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>; <span class="keyword">char</span> s[N]; std::deque&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k, d; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%s&quot;</span>, &amp;n, &amp;k, s + <span class="number">1</span>); d = !(n &amp; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a.<span class="built_in">push_back</span>(s[i] - <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    <span class="keyword">int</span> per = std::<span class="built_in">min</span>(<span class="number">2</span> * n, k), cnt = per + (k - per) % <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i += <span class="number">2</span>) a[i] ^= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!a[<span class="number">0</span>]) &#123; a[<span class="number">0</span>] ^= <span class="number">1</span>; <span class="keyword">continue</span>; &#125;</span><br><span class="line">        a.<span class="built_in">pop_front</span>(); a.<span class="built_in">push_back</span>(d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i += <span class="number">2</span>) a[i] ^= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">putchar</span>(a[i] + <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>); <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="E-Increasing-Numbers"><a href="#E-Increasing-Numbers" class="headerlink" title="E - Increasing Numbers"></a>E - Increasing Numbers</h4><p>定义「上升数」为在十进制表示下从高位到低位数位值单调不降的数，如 $11,1234$ 等。给出 $n$，将 $n$ 分解为如下形式，其中 $A$ 表示「上升数」集合：</p>
<script type="math/tex; mode=display">\sum_{i=1}^k a_i,a_i\in A</script><p>求 $k$ 的最小值。($1\le n\le10^{5\times10^5}$)</p>
<p>我们定义「递归数」为所有数位均为 $1$ 的数，则一个数是「上升数」当且仅当它能被分解为至多 $9$ 个「递归数」之和，所以一个数能被分为 $k$ 个「递归数」之和当且仅当它能被至多 $9k$ 个「递归数」表示。又因为「递归数」可以被 $\dfrac{10^r-1}{9}$ 的形式表示，所以题目中给出的式子相当于：</p>
<script type="math/tex; mode=display">n=\sum_{i=1}^{9k}\dfrac{(10^{r_i}-1)}{9}</script><p>也即：</p>
<script type="math/tex; mode=display">9n+9k=\sum_{i=1}^{9k}10^{r_i}</script><p>也就是说，对于一个 $k$ 其有解的充要条件是 $9n+9k$ 的十进制表示数位和不超过 $9k$（等于 $9k$ 是在上述式子中没有进位，而进位了只会让和变得更小）。</p>
<p>有了这个结论后，我们就可以尝试求解了。下文中令 $L=\log_{10}n。$首先注意到答案满足单调性，可以二分一个 $k$，高精算出 $9n+9k$，之后计算数位和求解。显然计算的时间复杂度是 $\mathcal{O}(L)$，那二分呢？注意到 $k=L$ 一定可行（每次只用「上升数」消掉一位可以构造），那我们二分的范围只需要是 $[1,L]$ 即可，总时间复杂度 $\mathcal{O}(L\log L)$。</p>
<p>我们也可以不用二分，朴素枚举 $9n,9n+9k,9n+18k,\cdot\cdot\cdot,9n+9L$ 分别进行计算，乍一看复杂度是 $\mathcal{O}(L^2)$ 的，但注意到我们只关心数位和，而会影响数位和的只是进位，每次至多进一位，所以可以实现出时间复杂度 $\mathcal{O}(L)$ 的算法。（也就是加的时候维护数位和）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">10</span>; <span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> a[N], len, b[N], lenb, ss;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">plus</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[<span class="number">1</span>] += k; ss += k; <span class="keyword">int</span> now = <span class="number">1</span>, d = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (a[now] &gt;= <span class="number">10</span>)</span><br><span class="line">        d = a[now] / <span class="number">10</span>, ss -= (a[now] - a[now] % <span class="number">10</span>), </span><br><span class="line">        a[now] %= <span class="number">10</span>, a[++now] += d, ss += d;</span><br><span class="line">    <span class="keyword">if</span> (now &gt; len) len = now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">times</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; k)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] *= k; a[i] += d;</span><br><span class="line">        d = a[i] / <span class="number">10</span>; a[i] %= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (d) a[++len] = d % <span class="number">10</span>, d /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i) s += a[i];</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> l)</span> </span>&#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= l; ++i) a[i] = s[l - i + <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>; len = l; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len; i; --i) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a[i]);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>); <span class="built_in">init</span>(<span class="built_in">strlen</span>(s + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>; <span class="built_in">times</span>(<span class="number">9</span>); ss = <span class="built_in">sum</span>();</span><br><span class="line">    <span class="keyword">while</span> (ss &gt; <span class="number">9</span> * k) ++k, <span class="built_in">plus</span>(<span class="number">9</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, k); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="F-Train-Service-Planning"><a href="#F-Train-Service-Planning" class="headerlink" title="F - Train Service Planning"></a>F - Train Service Planning</h4><p>有一段铁路，铁路上有 $n+1$ 个站台，站台与站台之间有 $n$ 段道路相邻，其中第 $i$ 条道路连接着第 $i-1$ 和第 $i$ 个站台。火车不管从哪个方向通过第 $i$ 段道路均需要 $a_i$ 的时间，一段道路要么是全程单轨要么是全程双轨。对于双轨道路，不同方向的火车在道路上不会相互影响，而对于单轨道路，不同方向的火车不能同时通过。现在想制作一张铁路时刻表，时刻表中每 $k$ 的时间发一辆车，火车要么从 $0$ 到 $n$，要么从 $n$ 到 $0$。求出时间表中从 $0$ 站台到 $n$ 站台和从 $n$ 站台到 $0$ 站台的列车所需时间之和的最小值或报告无解。($1\le n\le10^5,1\le k,a_i\le10^9$)</p>
<p>一道比较繁琐的应用题（我的题面简述可能有遗漏，建议看看原题）。比较简单的是无解情况，当 $\exist i$，满足 $2t_i&gt;k$ 时则无解，因为当第一辆车还走完这条路时后面已经要有两辆车在站台上等着了，而这是非法的。判完无解后，考虑设 $p,q$ 序列，其中 $p_i$ 表示 $0\rightarrow n$ 的车在 $i$ 站台停留的时间，$q_i$ 表示 $n\rightarrow 0$ 的车在 $i$ 站台停留的时间。并记它们和 $a$ 数组的前缀和：</p>
<script type="math/tex; mode=display">sA_i=\sum_{j=1}^i a_j,sP_i=\sum_{j=1}^i p_j,sQ_i=\sum_{j=1}^i q_j</script><p>有了这些后，我们就能很方便地表示出某两列车经过第 $i$ 段道路的时间区间了。注意到这个区间是每 $k$ 单位重复一次的。具体来讲，对于 $0\rightarrow n$ 的列车，经过第 $i$ 段道路的时间区间为：</p>
<script type="math/tex; mode=display">(sA_{i-1}+sP_i+ck,sA_i+sP_i+ck)(c\in \mathbb{Z})</script><p>对于 $n\rightarrow n$ 的列车，经过第 $i$ 段道路的时间区间为：</p>
<script type="math/tex; mode=display">(sA_n-sA_i+sQ_n-sQ_i+ck,sA_n-sA_{i-1}+sQ_n-sQ_i+ck)(k\in\mathbb{Z})</script><p>而又因为走一整次，也就是 $sA_n+sQ_n$ 所需时间一定为 $k$ 的倍数，所以上式又等于：</p>
<script type="math/tex; mode=display">(-sA_i-sQ_i+ck,-sA_{i-1}-sQ_i+ck)(k\in\mathbb{Z})</script><p>如果该道路为双向道路，则这两个区间相互不影响。如果为单向道路，则需要不相交，即：</p>
<script type="math/tex; mode=display">\begin{cases}sA_i+sP_i+ck\notin(-sA_i-sQ_i+ck,-sA_{i-1}-sQ_i+ck)\\sA_{i-1}+sP_i+ck\notin(-sA_i-sQ_i+ck,-sA_{i-1}-sQ_i+ck)\\-sA_i-sQ_i+ck\notin (sA_{i-1}+sP_i+ck,sA_i+sP_i+ck)\\-sA_{i-1}-sQ_i+ck\notin (sA_{i-1}+sP_i+ck,sA_i+sP_i+ck)\end{cases}</script><p>做一些简单的代数变换统一形式（目的是把已知的 $sA$ 塞进区间里，未知的 $sP,sQ$ 扔出区间）：</p>
<script type="math/tex; mode=display">\begin{cases}sP_i+sQ_i+ck\notin(-2sA_i,-sA_i-sA_{i-1})\\sP_i+sQ_i+ck\notin(-sA_i-sA_{i-1},-2sA_{i-1})\\-sP_i-sQ_i+ck\notin(sA_i+sA_{i-1},2sA_i)\\-sP_i-sQ_i+ck\notin(2sA_{i-1},sA_{i-1}+sA_i)\end{cases}</script><p>也即：</p>
<script type="math/tex; mode=display">\begin{cases}sP_i+sQ_i\notin(-2sA_i,-2sA_{i-1})\\-sP_i-sQ_i\notin(2sA_{i-1}+2sA_i)\end{cases}</script><p>注意这里其实把 $sP_i+sQ_i=-sA_i-sA_{i-1}$ 的解给排除掉了，不过其实可以发现这个等式不可能成立。如果记 $x_i=sP_i+sQ_i$，则可以进一步简化为：</p>
<script type="math/tex; mode=display">x_i\notin(-2sA_i,-2sA_{i-1})</script><p>而对于 $x$ 序列，我们的限制是单调不减。接下来的问题就变为了针对一个 $x$ 变量的问题：</p>
<ul>
<li>$x$ 可以取任意初始值，每次给出一个区间，要求 $x$ 加上一个非负整数后落在该区间内，最小化加上值的和。</li>
</ul>
<p>考虑 $\rm dp$。设 $f_{i,j}$ 表示 $i$ 次操作后使 $x=j$ 的最小代价。则对于给出的区间 $[l,r]$，我们应该从 $[l,r]$ 外的 $\rm dp$ 值转移过来，很容易发现转移到 $l$ 代价是最小的。这样我们就设计好了一个朴素 $\rm$，时间复杂度 $\mathcal{O}(n^2)$，显然无法接受。注意到这个涉及到的是从一个区间转移 $\rm dp$，而且维护的信息比较复杂，涉及到两个点之间的下标差。考虑用线段树维护 $f_{i,j}-i$ 的值，这样每次转移只需要找到区间最小值并加上当前的 $l$ 就是答案了。为了转移的分层性，转移完后我们要把 $[l,r]$ 区间外的所有值设为 $\infty$。然后就优化完了，时间复杂度降低至 $\mathcal{O}(n\log n)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Ls(k) (k &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rs(k) (k &lt;&lt; 1 | 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mid(k) ((h[k].l + h[k].r) &gt;&gt; 1)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll; <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>; <span class="keyword">const</span> ll inf = <span class="number">1e16</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SGT</span>&#123;</span> <span class="keyword">int</span> l, r, tag; ll x; &#125;h[N &lt;&lt; <span class="number">4</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span> ll l, r; &#125;s[N]; ll tmp[N &lt;&lt; <span class="number">1</span>], t[N]; <span class="keyword">int</span> tp, tn;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123; h[k].x = std::<span class="built_in">min</span>(h[<span class="built_in">Ls</span>(k)].x, h[<span class="built_in">Rs</span>(k)].x); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123; h[k].x = inf; h[k].tag = <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!h[k].tag) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">clear</span>(<span class="built_in">Ls</span>(k)); <span class="built_in">clear</span>(<span class="built_in">Rs</span>(k));</span><br><span class="line">    h[k].tag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    h[k].l = l; h[k].r = r;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> h[k].x = -tmp[l], <span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">Ls</span>(k), l, <span class="built_in">Mid</span>(k)); <span class="built_in">build</span>(<span class="built_in">Rs</span>(k), <span class="built_in">Mid</span>(k) + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= h[k].l &amp;&amp; h[k].r &lt;= y) <span class="keyword">return</span> <span class="built_in">clear</span>(k);</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="built_in">Mid</span>(k)) <span class="built_in">clear</span>(<span class="built_in">Ls</span>(k), x, y);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Mid</span>(k) &lt; y) <span class="built_in">clear</span>(<span class="built_in">Rs</span>(k), x, y);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> pos, ll val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h[k].l == h[k].r) <span class="keyword">return</span> h[k].x = std::<span class="built_in">min</span>(h[k].x, val - tmp[h[k].l]), <span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="keyword">if</span> (pos &lt;= <span class="built_in">Mid</span>(k)) <span class="built_in">change</span>(<span class="built_in">Ls</span>(k), pos, val);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">change</span>(<span class="built_in">Rs</span>(k), pos, val);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= h[k].l &amp;&amp; h[k].r &lt;= y) <span class="keyword">return</span> h[k].x;</span><br><span class="line">    ll ret = inf; <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="built_in">Mid</span>(k)) ret = std::<span class="built_in">min</span>(ret, <span class="built_in">query</span>(<span class="built_in">Ls</span>(k), x, y));</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Mid</span>(k) &lt; y) ret = std::<span class="built_in">min</span>(ret, <span class="built_in">query</span>(<span class="built_in">Rs</span>(k), x, y));</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">minx</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h[k].l == h[k].r) <span class="keyword">return</span> h[k].x + tmp[h[k].l];</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">min</span>(<span class="built_in">minx</span>(<span class="built_in">Ls</span>(k)), <span class="built_in">minx</span>(<span class="built_in">Rs</span>(k)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, typ; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%d&quot;</span>, &amp;t[i], &amp;typ);</span><br><span class="line">        <span class="keyword">if</span> (typ == <span class="number">1</span> &amp;&amp; <span class="number">2</span> * t[i] &gt; k) &#123; <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">        t[i] += t[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (typ == <span class="number">1</span>) </span><br><span class="line">            s[++tp].l = (k - <span class="number">2</span> * t[i - <span class="number">1</span>] % k) % k, </span><br><span class="line">            s[tp].r = (k - <span class="number">2</span> * t[i] % k) % k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tp; ++i) tmp[++tn] = s[i].l, tmp[++tn] = s[i].r;</span><br><span class="line">    std::<span class="built_in">sort</span>(tmp + <span class="number">1</span>, tmp + tn + <span class="number">1</span>);</span><br><span class="line">    tn = std::<span class="built_in">unique</span>(tmp + <span class="number">1</span>, tmp + tn + <span class="number">1</span>) - tmp - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, tn);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tp; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l = std::<span class="built_in">lower_bound</span>(tmp + <span class="number">1</span>, tmp + tn + <span class="number">1</span>, s[i].l) - tmp,</span><br><span class="line">            r = std::<span class="built_in">lower_bound</span>(tmp + <span class="number">1</span>, tmp + tn + <span class="number">1</span>, s[i].r) - tmp;</span><br><span class="line">        ll ret = inf;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (l - <span class="number">1</span> &gt;= <span class="number">1</span>)</span><br><span class="line">            &#123;   </span><br><span class="line">                ret = std::<span class="built_in">min</span>(ret, <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, l - <span class="number">1</span>) + s[i].l);</span><br><span class="line">                <span class="built_in">clear</span>(<span class="number">1</span>, <span class="number">1</span>, l - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tn &gt;= r + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ret = std::<span class="built_in">min</span>(ret, <span class="built_in">query</span>(<span class="number">1</span>, r + <span class="number">1</span>, tn) + s[i].l + k);</span><br><span class="line">                <span class="built_in">clear</span>(<span class="number">1</span>, r + <span class="number">1</span>, tn);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (r + <span class="number">1</span> &lt;= l - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ret = std::<span class="built_in">min</span>(ret, <span class="built_in">query</span>(<span class="number">1</span>, r + <span class="number">1</span>, l - <span class="number">1</span>) + s[i].l);</span><br><span class="line">            <span class="built_in">clear</span>(<span class="number">1</span>, r + <span class="number">1</span>, l - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">change</span>(<span class="number">1</span>, l, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">minx</span>(<span class="number">1</span>) + <span class="number">2</span> * t[n]); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhiyangfan1234.github.io/2022/01/24/CODE%20FESTIVAL%202016%20qual%20A%E8%A1%A5%E9%A2%98%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhiyangfan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhiyangfan 的博客小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/24/CODE%20FESTIVAL%202016%20qual%20A%E8%A1%A5%E9%A2%98%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">CODE FESTIVAL 2016 qual A</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-01-24 17:00:23 / 修改时间：17:12:56" itemprop="dateCreated datePublished" datetime="2022-01-24T17:00:23+08:00">2022-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="CODE-FESTIVAL-2016-qual-A补题总结"><a href="#CODE-FESTIVAL-2016-qual-A补题总结" class="headerlink" title="CODE FESTIVAL 2016 qual A补题总结"></a>CODE FESTIVAL 2016 qual A补题总结</h2><p>是这样的，我开了 A，B，C ，这题就这？还AGC难度呢？我是不是开了 ABC 啊？然后我看了 D…又看了 E…，对不起，我的问题，这确实是 AGC 中的好题。</p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="A-CODEFESTIVAL-2016"><a href="#A-CODEFESTIVAL-2016" class="headerlink" title="A - CODEFESTIVAL 2016"></a>A - CODEFESTIVAL 2016</h4><p>给一个有 $12$ 个英文字母的字符串，请在前四个字母和后八个字母之间加个空格后输出。</p>
<p><del>甚至不需要数据范围，感觉比最近 ABC 的 A 还简单。</del> 不多说了，想怎么实现怎么实现，这里就给个 C 风格的吧。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; ++i) <span class="built_in">putchar</span>(str[i]);</span><br><span class="line">	<span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>); <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>; i &lt;= <span class="number">12</span>; ++i) <span class="built_in">putchar</span>(str[i]);</span><br><span class="line">	<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="B-Friendly-Rabbits"><a href="#B-Friendly-Rabbits" class="headerlink" title="B - Friendly Rabbits"></a>B - Friendly Rabbits</h4><p>给出一个长为 $N$ 的序列 $a$ ，其中 $a_i$ 表示第 $i$ 只兔子喜欢第 $a_i$ 只，问有多少对兔子相互喜欢（喜欢关系不能传递）。($2\le N\le10^5,1\le a_i\le N,a_i\ne i$)</p>
<p><del>本来我以为这玩意可以相互传递，已经准备好建图判环了</del> 好吧既然关系不能传递就很简单了，对于任意一只兔子，只有它喜欢的那只才有可能与它相互喜欢，检查一下是不是有 $a_{a_i}=i$ 就好了，因为这样一对兔子会被计算两次，所以最后答案除以要 $2$。时间复杂度 $\mathcal{O}(N)$ 。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>; <span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, cnt = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="keyword">if</span> (a[a[i]] == i) ++cnt;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cnt / <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="C-Next-Letter"><a href="#C-Next-Letter" class="headerlink" title="C - Next Letter"></a>C - Next Letter</h4><p>给出一个只含有小写字母的字符串 $s$ ，对它执行以下操作 <strong>恰好</strong> $K$ 次：</p>
<ul>
<li>从 $s$ 中选择任意一个字符并把它改为它的下一个字母，注意 <code>z</code> 的下一个字母是 <code>a</code> 。</li>
</ul>
<p>找到 $K$ 次操作后能得到的字典序最小的字符串 $s$ 。($1\le |s|\le10^5,1\le K\le 10^9$)</p>
<p>注意到除非能一直对一个位置执行该操作直到把一个非 <code>a</code> 的地方变为 <code>a</code> ，否则还不如不执行，因为只要不转一圈回来这个操作都是会增大字典序的。又因为字典序是以第 $i$ 个位置为第 $i$ 关键字的比较，所以我们优先保证第 $1$ 个位置能变为 <code>a</code> ，之后依次从前往后遍历每个位置，查看剩余次数是否能使它变为 <code>a</code> ，如果能就花费相应的次数操作。最后可能会剩下一些操作，由于前面的过程已经保证剩余次数不能再把新的位置变 <code>a</code> ，所以我们对这剩余次数的最好处理方式就是全部扔到最后一个位置上，这样对字典序的影响最小。时间复杂度 $\mathcal{O}(|s|)$ 。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>; <span class="keyword">char</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> k, n; <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, s + <span class="number">1</span>, &amp;k); n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">	<span class="comment">//注意这里必须判断一下 s[i] 原来不等于 &#x27;a&#x27;，否则可能会浪费 26 次次数转一圈 </span></span><br><span class="line">		<span class="keyword">if</span> (s[i] != <span class="string">&#x27;a&#x27;</span> &amp;&amp; k &gt;= <span class="number">26</span> - s[i] + <span class="string">&#x27;a&#x27;</span>) k -= <span class="number">26</span> - s[i] + <span class="string">&#x27;a&#x27;</span>, s[i] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">	<span class="keyword">if</span> (!k) &#123; <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s + <span class="number">1</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">	s[n] = (s[n] - <span class="string">&#x27;a&#x27;</span> + k) % <span class="number">26</span> + <span class="string">&#x27;a&#x27;</span>; <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><del>前戏结束，比赛正式开始</del></p>
<h4 id="D-Grid-and-Integers"><a href="#D-Grid-and-Integers" class="headerlink" title="D - Grid and Integers"></a>D - Grid and Integers</h4><p>给出一个 $R$ 行 $C$ 列的表格，我们称第 $r$ 行第 $c$ 列为 $(r,c)$ 。在这个表格中写入 $N$ 个数字，也就是 $(r_i,c_i)$ 上有一个非负整数 $a_i$ 。接下来想把剩下的表格填满，但要满足以下条件：</p>
<ul>
<li>条件1：所有的格子中都必须是非负整数</li>
<li>条件2：对于表格中任意的 $2\times 2$ 区域，都要有左上角和右下角中整数的和等于右上角和左下角中整数的和。</li>
</ul>
<p>求是否能找到一种填表格的方式满足以上条件。($2\le R,C\le10^5,1\le N\le10^5,\forall i\ne j,(r_i,c_i)\ne (r_j,c_j),a_i\in\{x\in Z|0\le x\le10^9\}$)</p>
<p>难度骤增，我跟我后面那位 $\rm \color{black}V\color{red}areal$ 讨论了好久也没有什么特别的思路…. 好的，言归正传，这题其实我们讨论出来了一个大概，但是没想到实现这么神仙。首先我们发现原题给出的式子 $a_{i,j}+a_{i+1,j+1}=a_{i+1,j}+a_{i,j+1}$ ，其实可以变一变，变成 $a_{i,j}-a_{i+1,j}=a_{i,j+1}-a_{i+1,j+1}$ ，也就是相邻的两列($j$ 和 $j+1$) 元素差相同($i$ 和 $i+1$) 。同理类似的变化，我们可以得到相邻的两行元素差相同。也就是说，这个题的重要性质是最终填完的表格要满足所有行对应的差分序列相同，所有列对应的差分序列相同。其实这时候就可以大概有个思路的雏形了，比如对于题目中给出的例子:<br><img src="https://atcoder.jp/img/other/code_festival_2016_quala/gbanjthabot/D_1.png" alt=""></p>
<p>就是因为第二列在确定这两个数字的条件下，其差分序列不可能跟第一列的差分序列相同才无法填出。</p>
<p>接下来考虑如何去维护这个奇妙的性质，这用到了一个我之前没听说过的 DS ，带权并查集。具体来说，并查集是一个树形结构，而带权并查集就是在点上加一个权值，注意路径压缩的时候要合并一下权值信息就可以。我们首先考虑如何维护所有行对应的差分序列相同，列的就同理了。我们将已有的数字按照行编号升序遍历，对于同行不同列的两个点，我们设它们的列数为 $c_1,c_2$ 。如果 $c_1,c_2$ 不在一个并查集，说明这俩列之间的差还没有被确定，我们把它们合并到同一个并查集，我们把 $c_1$ 的父亲设为 $c_2$ ，并把 $c_1$ 的权值 $val_{c_1}$ 设为这两个点的差。如果在同一个并查集里，说明已经确定差是多少了，判断一下这俩的差符不符合就可以了($a_{r,c_1}-a_{r,c_2}=val_{c_1}-val_{c_2}$ ，这里直接用 $c_1,c_2$ 是因为刚刚查找过 $c_1,c_2$ 在并查集中的父亲，路径压缩过了，$c_1,c_2$ 直接指向根节点)。</p>
<p>还没完，这只是保证能填出来，不能保证填出来的数就是非负整数。因为带权并查集的权值表示当前节点与父亲节点的差，所以我们只需要枚举行或者列，找到最小的差和最小的权值，如果相加小于 $0$ 就不满足条件，具体实现细节放到代码中，总之时间复杂度 $\mathcal{O}(n\alpha(n))$ ，其中 $\alpha(n)$ 表示并查集的时间复杂度。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>; ll mx1[N], mx2[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span> <span class="keyword">int</span> pos[<span class="number">2</span>], val; &#125;p[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DSU</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> f[N], n; ll dif[N];</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> x)</span> </span></span><br><span class="line"><span class="function">	</span>&#123; n = x; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) f[i] = i; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (x == f[x]) <span class="keyword">return</span> x;</span><br><span class="line">		<span class="comment">//路径压缩时要把权值合并</span></span><br><span class="line">		<span class="keyword">int</span> fa = <span class="built_in">getf</span>(f[x]); dif[x] += dif[f[x]];</span><br><span class="line">		<span class="keyword">return</span> f[x] = fa;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> typ, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> tx = <span class="built_in">getf</span>(p[a].pos[typ]),</span><br><span class="line">		ty = <span class="built_in">getf</span>(p[b].pos[typ]);</span><br><span class="line">		<span class="keyword">if</span> (tx == ty)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (p[a].val - dif[p[a].pos[typ]] == </span><br><span class="line">			p[b].val - dif[p[b].pos[typ]])</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			ll va = p[a].val - dif[p[a].pos[typ]],</span><br><span class="line">			vb = p[b].val - dif[p[b].pos[typ]];</span><br><span class="line">			f[tx] = ty; dif[tx] = va - vb; <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;dsu1, dsu2;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r, c, n; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;r, &amp;c, &amp;n);</span><br><span class="line">	dsu1.<span class="built_in">init</span>(c); dsu2.<span class="built_in">init</span>(r); <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;p[i].pos[<span class="number">0</span>], &amp;p[i].pos[<span class="number">1</span>], &amp;p[i].val);</span><br><span class="line">	<span class="built_in">memset</span>(mx1, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span> (mx1)); <span class="built_in">memset</span>(mx2, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span> (mx2));</span><br><span class="line">	std::<span class="built_in">sort</span>(p + <span class="number">1</span>, p + n + <span class="number">1</span>, </span><br><span class="line">	[&amp;](<span class="keyword">const</span> node&amp; n1, <span class="keyword">const</span> node&amp; n2) &#123; <span class="keyword">return</span> n1.pos[<span class="number">0</span>] &lt; n2.pos[<span class="number">0</span>]; &#125;);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">		<span class="keyword">if</span> (p[i].pos[<span class="number">0</span>] == p[i + <span class="number">1</span>].pos[<span class="number">0</span>])</span><br><span class="line">			<span class="keyword">if</span> (dsu1.<span class="built_in">check</span>(<span class="number">1</span>, i, i + <span class="number">1</span>)) flag = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (flag) &#123; <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">	std::<span class="built_in">sort</span>(p + <span class="number">1</span>, p + n + <span class="number">1</span>,</span><br><span class="line">	[&amp;](<span class="keyword">const</span> node&amp; n1, <span class="keyword">const</span> node&amp; n2) &#123; <span class="keyword">return</span> n1.pos[<span class="number">1</span>] &lt; n2.pos[<span class="number">1</span>]; &#125;);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">		<span class="keyword">if</span> (p[i].pos[<span class="number">1</span>] == p[i + <span class="number">1</span>].pos[<span class="number">1</span>])</span><br><span class="line">			<span class="keyword">if</span> (dsu2.<span class="built_in">check</span>(<span class="number">0</span>, i, i + <span class="number">1</span>)) flag = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (flag) &#123; <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">	<span class="comment">//枚举列父亲找到最小数字</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, fa; i &lt;= n; ++i)</span><br><span class="line">	&#123; </span><br><span class="line">		fa = dsu1.<span class="built_in">getf</span>(p[i].pos[<span class="number">1</span>]); </span><br><span class="line">		mx1[fa] = std::<span class="built_in">min</span>(mx1[fa], p[i].val - dsu1.dif[p[i].pos[<span class="number">1</span>]]); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//枚举列父亲找到最小权值</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, fa; i &lt;= c; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		fa = dsu1.<span class="built_in">getf</span>(i);</span><br><span class="line">		mx2[fa] = std::<span class="built_in">min</span>(mx2[fa], dsu1.dif[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//计算最小值，判断是否合法</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, fa; i &lt;= c; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		fa = dsu1.<span class="built_in">getf</span>(i);</span><br><span class="line">		<span class="keyword">if</span> (fa == i &amp;&amp; mx1[fa] + mx2[fa] &lt; <span class="number">0</span>) flag = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (flag) &#123; <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="E-LRU-Puzzle"><a href="#E-LRU-Puzzle" class="headerlink" title="E - LRU Puzzle"></a>E - LRU Puzzle</h4><p>给出 $N$ 个长为 $M$ 的数组，刚开始每个数组里面都是 $(1,2,3,\cdot\cdot\cdot,M)$ 。给出一个长为 $Q$ 的操作序列 $a$ ，其中 $a_i$ 表示对于一个数组，我们把 $a_i$ 这个数提到第一位。我们要顺次执行完所有的操作，每次操作可以对任意一个数组施加，求能否使操作完后所有的数组都相同。($2\le N,M\le10^5,1\le Q\le10^5,1\le a_i\le M$)</p>
<p>思维神题，洛谷上只有 $3$ 个人通过的神题。我们来形式化解释一下题意，正好方便后续的解释。我们设 $f_M(a)$ 表示对于长为 $M$ 的初始数组依次施加 $a$ 序列操作后得到的序列。比如如果 $M=6,a=(6,3,1,3,6,3)$ ，则 $f_M(a)=(3,6,1,2,4,5)$ （手玩一下应该没啥问题）。有个很简单 <del>(但是挺不好想的方法)</del> 来求解 $f_M(a)$，我们定义一个辅助数组 $b$ ，一开始为空。倒序遍历 $a$ 序列，如果当前正在处理的 $a_i$ 在 $b$ 中没出现过，就把它加到末尾，否则啥也不干。遍历过后，我们把剩下的没有出现过的 $1-M$ 之间的数字以递增的顺序加到 $b$ 末尾，这样之后就满足 $f_M(a)=b$ 。经过这样转化后，原问题就是：</p>
<blockquote>
<p>给一个操作序列 $a$ ，问能不能把 $a$ 分为若干个子序列 $a_1,a_2,a_3,\cdot\cdot\cdot,a_n$ ，使得 $f_M(a_1)=f_M(a_2)=f_M(a_3)=\cdot\cdot\cdot=f_M(a_N)$ 。</p>
</blockquote>
<p>接下来我们注意到，如果 $f_M(a_1)=f_M(a_2)=f_M(a_3)=\cdot\cdot\cdot=f_M(a_N)$ ，则 $f_M(a_1)$ 的第一个元素应该与 $f_M(a)$ 的第一个元素相等，否则因为 $a_i$ 是 $a$ 的子序列，一定存在一个数组第一个元素与 $f_M(a)$ 的相同，与 $f_M(a_i)=f_(a_1)$ 矛盾。按照这个道理，我们可以发现，$f_M(a_1)$ 的第二，第三……个元素都应该与 $f_M(a)$ 的相同。再推广一下，就能得到新的题意：</p>
<blockquote>
<p>给一个操作序列 $a$ ，问能不能把 $a$ 分为若干个子序列 $a_1,a_2,a_3,\cdot\cdot\cdot,a_n$ ，使得 $f_M(a_1)=f_M(a_2)=f_M(a_3)=\cdot\cdot\cdot=f_M(a_N)=f_M(a)$ 。</p>
</blockquote>
<p>比如我们还看刚刚的例子 $M=6,a=(6,3,1,3,6,3)$，我们可以把 $a_1=(6,3,3),a_2=(1,6,3)$ 这样分为两个部分，这样 $f_M(a_1)=f_M(a_2)=f_M(a)$ 。</p>
<p>秉着从简单到复杂的原则，我们先来看 $N=2$ 的情况。首先我们按照上述方法算出 $f_M(a)$ （其实也可以边做边算，之后在代码里面说吧）。然后我们设 $b_1,b_2$ 分别表示 $f_M(a_1),f_M(a_2)$ 计算过程中的辅助数组，我们的算法就是在把 $a$ 分为 $a_1,a_2$ 的过程中同时求出 $b_1,b_2$ 。因为我们想让遍历之后的 $b_1,b_2$ 在满足是 $f_M(a)$ 前缀的条件下，尽可能的长（这样才能尽可能靠近 $f_M(a)$），所以我们可以采取以下贪心做法，依然是倒序遍历 $a$ 。</p>
<ul>
<li>如果当前的 $a_i$ 既不在 $b_1$ 中也不在 $b_2$ 中，就把它加到 $b_1$ 末尾。</li>
<li>不失一般性，我们假设 $a_i$ 在 $b_1$ 中而不在 $b_2$ 中，则如果能满足加到 $b_2$ 里面后不破坏 $b_2$ 是 $f_M(a)$ 前缀的性质，就加到 $b_2$ 末尾。</li>
<li>如果 $a_i$ 既在 $b_1$ 也在 $b_2$ 就啥也不干。</li>
</ul>
<p>这些做完之后，我们把 $b_1,b_2$ 扩展到 $M$ 的长度，然后比较是否存在 $b_1=b_2=f_M(a)$ 。最终可以做到 $\mathcal{O}(M+Q)$ 的复杂度。</p>
<p>接下来考虑把这个算法推广到 $N\ge 2$ 的情况。首先我们还是先计算 $f_M(a)$ ，并设 $b_1,b_2,b_3,\cdot\cdot\cdot,b_N$ 分别表示 $f_M(a_1),f_M(a_2),f_M(a_3),\cdot\cdot\cdot,f_M(a_N)$ 的辅助数组。然后依然是倒序遍历 $a$ ，对于每个 $a_i$ ，找到一个 $b_j$ 满足 $b_j$ 中不含有 $a_i$ 且把 $a_i$ 加到 $b_j$ 末尾不破坏 $b_j$ 的前缀性质，然后把 $a_i$ 加到 $b_j$ 末尾。最后把所有的 $b$ 扩展到 $M$ 的长度，并比较是否存在 $b_1=b_2=b_3=\cdot\cdot\cdot=f_M(a)$ 。但非常遗憾，朴素的实现是 $\mathcal{O}(MN+NQ)$ 的复杂度，显然不能接受。</p>
<p>这里给粗一种可能的优化方式。因为所有的 $b$ 都是前缀，内容不重要，重要的是长度。所以我们设 $freq$ 数组，定义为：</p>
<script type="math/tex; mode=display">freq_k=\text{在所有的}b_i\text{中长度恰好为}k\text{的个数}</script><p>刚开始显然 $freq_0=N,freq_i=0(0<i\le M)$ ，因为所有的 $b$ 都是空的。则当我们遍历到 $a_i$ ，需要把 $a_i$ 加到长度恰好为 $k$ 的 $b_j$ 后面（英语题解这里 $k$ 突然冒出来把我晕了好久，其实就是对着 $f_M(a)$ 看，$a_i$ 该加到哪个位置了，然后就能对应出来 $k$），那如果 $freq_k\ge 1$ ，我们就把 $freq_k$ 减一，$freq_{k+1}$ 加一，否则啥也不干。这样遍历完之后，我们就得到了 $b$ 数组的长度。如果还是朴素的根据前缀扩展每个 $b$ 然后暴力比较，依然会逃不掉 $\mathcal{O}(NM)$ 的瓶颈。注意到如果长度最小的 $b_j$ 都满足 $b_j=f_M(a)$ ，则长度更大的 $b$ 也一定满足，因为 **确定的前缀越多，表示限制越大，与 $f_M(a)$ 相等的可能就更大** 。这样我们只需要把最短的 $b$ 给扩展并比较就好了，最终时间复杂度 $\mathcal{O}(M+Q)$ ，足以通过本题。（题解给的复杂度 $\mathcal{O}(N+M+Q)$，至少我的理解和我的实现里面都没有那个 $N$ ，不太清楚题解的想法）。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//奇短的代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>; <span class="keyword">int</span> q[N], fM[N], sq[N], bk[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m, Q; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;Q);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line">	sq[<span class="number">0</span>] = n; <span class="keyword">int</span> frt = <span class="number">0</span>, minx;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = Q, pos; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//边做边求fM</span></span><br><span class="line">		<span class="keyword">if</span> (!(pos = bk[q[i]])) pos = bk[q[i]] = ++frt, fM[frt] = q[i];</span><br><span class="line">		<span class="keyword">if</span> (sq[pos - <span class="number">1</span>]) --sq[pos - <span class="number">1</span>], ++sq[pos];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="keyword">if</span> (!bk[i]) bk[i] = ++frt, fM[frt] = i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) <span class="keyword">if</span> (sq[i]) &#123; minx = i; <span class="keyword">break</span>; &#125;</span><br><span class="line">	<span class="comment">//没必要求完，其实只需要检验一下需要补的位置是不是严格单调递增就好了</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = minx + <span class="number">2</span>; i &lt;= m; ++i)</span><br><span class="line">		<span class="keyword">if</span> (fM[i] &lt; fM[i - <span class="number">1</span>]) &#123; <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>前三题虚晃一枪，后两题神题。这次比较大的收获是了解了一种新的 DS 带权并查集， <del>和发现了一道冷门好题</del> 。我理解的的带权并查集是给的点权，不过因为这个点权表示的是和父亲节点的关系，其实理解为边权也没啥问题，只不过保存的形式是点权，主要应用场景就是当我们不仅仅需要记录集合关系，还需要记录集合内部元素间的关系（比如固定的差）。 AGC 的题真是不管那一场都能拿出来好好说道说道啊…</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhiyangfan1234.github.io/2022/01/24/CODE%20FESTIVAL%202016%20Final%E8%A1%A5%E9%A2%98%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhiyangfan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhiyangfan 的博客小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/24/CODE%20FESTIVAL%202016%20Final%E8%A1%A5%E9%A2%98%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">CODE FESTIVAL 2016 Final</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-01-24 17:00:23 / 修改时间：17:12:44" itemprop="dateCreated datePublished" datetime="2022-01-24T17:00:23+08:00">2022-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="CODE-FESTIVAL-2016-Final补题总结"><a href="#CODE-FESTIVAL-2016-Final补题总结" class="headerlink" title="CODE FESTIVAL 2016 Final补题总结"></a>CODE FESTIVAL 2016 Final补题总结</h2><p>你问我 AGC004,005,007 的总结去哪了？在写了在写了，只不过感觉这一场太妙了，所以就拉到了最先置顶的工作量（</p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="A-Where’s-Snuke"><a href="#A-Where’s-Snuke" class="headerlink" title="A - Where’s Snuke?"></a>A - Where’s Snuke?</h4><p>给出一个 $h\times w$ 的表格，每个格子里面有 <code>snake</code> 或 <code>snuke</code>。请找出唯一一个 <code>snuke</code> 的位置，行数 $1$ 到 $h$ 编号，列 <code>A</code> 到英文第 $w$ 个小写字母编号。($1\le h,w\le26$)</p>
<p><del>过水已隐藏</del>  </p>
<p>CCF学学人家的签到题。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function">std::string <span class="title">str</span><span class="params">(<span class="string">&quot;snuke&quot;</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h, w; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;h, &amp;w); std::string s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= h; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= w; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cin &gt;&gt; s;</span><br><span class="line">            <span class="keyword">if</span> (s == str) <span class="built_in">printf</span>(<span class="string">&quot;%c%d\n&quot;</span>, <span class="string">&#x27;A&#x27;</span> + j - <span class="number">1</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="B-Exactly-N-points"><a href="#B-Exactly-N-points" class="headerlink" title="B - Exactly N points"></a>B - Exactly N points</h4><p>共有 $n$ 个物品，其中第 $i$ 个物品的权值是 $i$。现在想取出一些物品使得它们的权值和恰好是 $n$ 且最小化选取物品中权值的最大值，求出一种可能的方案。($1\le n\le10^7$)</p>
<p>首先考虑最最最简单的 $1\le n\le1000$ 的情况，显然可以直接背包 $\rm dp$ 然后随便记录一下路径，时间复杂度 $\mathcal{O}(n^2)$。接下来考虑沿着这个算法的思路继续思考。注意到物品的权值是比较特殊的，简单手玩一下就能发现，前 $i$ 个物品能组成的权值是 $1\sim \dfrac{i(i+1)}{2}$，因为要最小化最大权值，所以我们肯定要尽量用靠前的物品。所以我们可以列出：</p>
<script type="math/tex; mode=display">\dfrac{x(x+1)}{2}=n</script><p>解得 $x=\left\lceil\dfrac{-1+\sqrt{1+8n}}{2}\right\rceil$。我们只需要用前 $x$ 个物品就能满足条件了，构造方案可以直接尽量用权值较大的物品去减，最终时间复杂度 $\mathcal{O}(\sqrt{n})$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="built_in">ceil</span>((<span class="number">-1</span> + <span class="built_in">sqrt</span>(<span class="number">1</span> + <span class="number">8</span> * n)) / <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, pos); n -= pos;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = pos - <span class="number">1</span>; i &gt;= <span class="number">1</span> &amp;&amp; n; --i)</span><br><span class="line">        <span class="keyword">if</span> (n &gt;= i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i), n -= i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="C-Interpretation"><a href="#C-Interpretation" class="headerlink" title="C - Interpretation"></a>C - Interpretation</h4><p>在一个星球上有 $m$ 种语言，现在有 $n$ 个人，每个人会说 $k_i$ 种语言 $l_{i,1},l_{i,2},\cdot\cdot\cdot,l_{i,{k_i}}$。两个人能交流当且仅当以下条件满足：</p>
<ul>
<li>存在一种两个人都会讲的语言。</li>
<li>存在一个两个人都能与他交流的人。</li>
</ul>
<p>问这 $n$ 个人能否相互交流。($2\le n\le10^5,1\le k_i\le m\le10^5,\sum k_i\le 10^5,\forall i\ne j$，都有 $l_{g,i}\ne l_{g,j}$)</p>
<p><del>很容易</del> 想到图论模型，把人向他所有会说的语言连边，最后看看所有点在不在同一个连通块中。会说同一种语言的人连通是显然的，而由于这种连通性可以传递，所以通过共同都能交流的人连通也是显然的。最终时间复杂度为 $\mathcal{O}(n\alpha(n))$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>; <span class="keyword">int</span> f[N]; <span class="keyword">char</span> res[<span class="number">2</span>][<span class="number">5</span>] = &#123;<span class="string">&quot;NO&quot;</span>, <span class="string">&quot;YES&quot;</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x == f[x] ? x : f[x] = <span class="built_in">getf</span>(f[x]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123; <span class="keyword">int</span> t1 = <span class="built_in">getf</span>(u), t2 = <span class="built_in">getf</span>(v); f[t1] = t2; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m; ++i) f[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, k, l; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; ++j)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;l), <span class="built_in">merge</span>(i, l + n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n &amp;&amp; flag; ++i)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">getf</span>(i) != <span class="built_in">getf</span>(<span class="number">1</span>)) flag = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, res[flag]); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="D-Pair-Cards"><a href="#D-Pair-Cards" class="headerlink" title="D - Pair Cards"></a>D - Pair Cards</h4><p>一共有 $n$ 张卡片，第 $i$ 张卡片上面写着 $x_i$。给出一个数 $m$，则两张卡片能配对当且仅当以下条件至少满足一个：</p>
<ul>
<li>两张卡片上面写的数相同。</li>
<li>两张卡片上面写的数之和为 $m$ 的倍数。</li>
</ul>
<p>求出最多能配多少对，注意一张卡片最多在一对中。($2\le n\le10^5,1\le m,x_i\le10^5$)</p>
<p>可以想到一个配对的思路是先配出所有两张卡片之和为 $m$ 的倍数（尽量不拆开相同的卡片）最后再合并一下两张卡片上面的数相同的对数。考虑为什么这样是对的，当不得不拆开相同的卡片时，这两张卡片如果只是自己之间配对，最多只能得到一对，但如果选择拿其中一个跟别人配对，另一个也有可能能跟另一个配对，最多可以得到两对，且至少一对。总之不亏，且有可能赚。题目中的倍数可以想到同余处理，开个桶记录一下 $m$ 的完全剩余系中每个值对应了多少张卡片，然后一一匹配即可。注意特判一下 $0$ 和 $\frac{m}{2}$ 的情况，因为它们是跟自己匹配的。为了匹配剩下的相同卡片，我们再记录一下每个余数对应着多少对相同的卡片，最后跟剩下多少张取个 $\min$ 即可（这样就可以做到尽量不拆开相同的卡片了）。时间复杂度 $\mathcal{O}(n+m)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>; <span class="keyword">int</span> b[N], c[N], s[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, ans = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a), ++c[a], ++b[a % m];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) s[i % m] += c[i] &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, d; i &lt; m - i; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        d = std::<span class="built_in">min</span>(b[i], b[m - i]);</span><br><span class="line">        ans += d; b[i] -= d; b[m - i] -= d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(m &amp; <span class="number">1</span>)) ans += (b[m &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>), b[m &gt;&gt; <span class="number">1</span>] &amp;= <span class="number">1</span>;</span><br><span class="line">    ans += (b[<span class="number">0</span>] &gt;&gt; <span class="number">1</span>), b[<span class="number">0</span>] &amp;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) ans += std::<span class="built_in">min</span>(s[i], b[i] &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p>
<h4 id="E-Cookies"><a href="#E-Cookies" class="headerlink" title="E - Cookies"></a>E - Cookies</h4><p>初始时做曲奇的速度为每秒 $1$ 个。可以任意次选择在任意时刻花 $a$ 秒吃掉当前做出的所有曲奇，如果吃掉了 $x$ 个曲奇，则做曲奇的速度变为每秒 $x$ 个。问做 $n$ 个曲奇至少需要多少秒，注意一秒不能拆开来算。($1\le n\le10^{12},0\le a\le10^{12}$)</p>
<p>在考虑正解之前，让我们先来看看 $1\le n\le 10^6$ 的部分分。我们设 $f_i$ 表示做出 <strong>恰好</strong> $n$ 个曲奇的最小时间，我们从 $1$ 到 $n-1$ 枚举最后一轮的速度，如果当前的速度为 $i$，则显然有转移</p>
<script type="math/tex; mode=display">f_j=\min(f_j,f_i+a+\dfrac{j}{i})(i\le j\le 2n,i|j)</script><p>而最后答案也不一定是 $f_n$，而是 $\min_{i=n}^{2n}\{f_i\}$。最终时间复杂度 $\mathcal{O}(n\log n)$，其中 $\log n$ 为枚举倍数调和级数级别的复杂度。</p>
<p>而 $1\le n\le10^{12}$ 的正解显然不能再用 $\rm dp$ 了，考虑数学推导。如果我们令曲奇数量为 $y$ 轴，时间为 $x$ 轴，则原题的过程可以转化为以下函数图像：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/a1nq0ezm.png" alt=""></p>
<p>其中第一段直线的斜率为 $1$。则有 $c_1=t_1$，所以如果一共分为 $k$ 段，则做出的曲奇数应该为 $\prod_{i=1}^k t_i$ 块，用掉的时间为 $\sum_{i=1}^k t_i+a(k-1)$ 秒。所以问题就转化为了：</p>
<blockquote>
<p>已知 $\prod_{i=1}^k t_i\ge n$，最小化 $\sum_{i=1}^k t_i+a(k-1)$ 的值。</p>
</blockquote>
<p>注意到这个 $k$ 是 $\mathcal{O}(\log n)$ 级别的，显然我们可以直接枚举这个 $k$。$k$ 确定之后 $a(k-1)$ 也就变成常数了，而剩下来的形式就很像基本不等式了。考虑这个问题：</p>
<blockquote>
<p>已知 $\prod_{i=1}^k t_i=n$，最小化 $\sum_{i=1}^k t_i$ 的值。</p>
</blockquote>
<p>根据基本不等式，显然 $\sum_{i=1}^k t_i\ge k\sqrt[k]{\prod_{i=1}^k t_i}=k\sqrt[k]{n}$，等号成立当且仅当 $t_1=t_2=\cdot\cdot\cdot=t_k$，可以直接 $\mathcal{O}(1)$ 计算。但是原问题不是 $=$ 而是 $\ge$。不过区别并不大，注意到这个 $\ge$ 产生的原因其实是 $t_i$ 限定为整数，所以我们还是尽量让所有值相等，只不过让允许一些位置大 $1$ 使得恰好 $\ge n$，这样可以保证既 $\ge n$ 也尽量贴近基本不等式等号成立的条件。对于所有可能的 $k$，分别 $\mathcal{O}(1)$ 计算然后 $\min$ 即可，时间复杂度 $\mathcal{O}(\log n)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n, a, p, ans; <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;a); ans = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>, d; k &lt;= <span class="number">100</span>; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        p = <span class="built_in">pow</span>(n, <span class="number">1.0</span> / k) + eps; d = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">pow</span>(p, k - d) * <span class="built_in">pow</span>(p + <span class="number">1</span>, d) &lt; n) ++d;  </span><br><span class="line">        ans = std::<span class="built_in">min</span>(ans, a * (k - <span class="number">1</span>) + (k - d) * p + d * (p + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="F-Road-of-the-King"><a href="#F-Road-of-the-King" class="headerlink" title="F - Road of the King"></a>F - Road of the King</h4><p>给出一张 $n$ 个点的有向图，定义一个序列 $c$ 是合法的当且仅当以下条件均满足：</p>
<ul>
<li>$c$ 的长度为 $m$。</li>
<li>$\forall 1\le i\le m$，都有 $1\le c_i\le n$。</li>
<li>如果在原图中加入 $m$ 条有向边 $c_{i-1}\rightarrow c_i(1\le i\le m)$，定义 $c_0=1$，则原图强联通。</li>
</ul>
<p>求有多少种合法的序列，答案对 $10^9+7$ 取模。($2\le n\le300,1\le m\le300$)</p>
<p>考虑一个序列能构造出强联通的充要条件：</p>
<ol>
<li>这个序列包含所有的点。</li>
<li>点 $1$ 能从点 $c_m$ 到达。</li>
</ol>
<p>必要性显然，考虑如何证明充分性。对于条件 1，我们可以发现所有的点都能从 $1$ 到达，这样借 $1$ 为跳板，从所有都能到达 $c_m$。而根据条件 2，$c_m$ 能到达所有点，这样所有点就可以相互到达了，也就是原图强联通。</p>
<p>考虑 $\rm dp$，我们设 $f_{i,j,k}$ 表示当前序列长 $i$，已经用了 $j$ 个点，当前「强联通的状态」为 $k$ 的方案数。每次转移考虑把一个点加入序列中，这样就基本就可以描述所有需要的信息了，但问题是，「强联通的状态」到底该用什么表示呢？注意到如果我们加入的点是 $1$，则会产生一个强连通分量，如果我们加入的点能到达 $1$，则也会产生一个强联通分量，否则什么都不会改变。所以我们应该维护的是 <strong>包含 $1$ 的强联通分量大小</strong>。</p>
<p>接下来的 $\rm dp$ 转移就简单了，考虑三种情况：</p>
<ol>
<li>加入一个没有在当前序列中出现过的点：$f_{i,j,k}=f_{i,j,k}+f_{i-1,j-1,k}\times (n-j+1)$</li>
<li>加入一个不在包含 $1$ 的强联通分量中的点：$f_{i,j,k}=f_{i,j,k}+f_{i-1,j,k}\times(j-k)$</li>
<li>加入一个在包含 $1$ 的强联通分量中的点：$f_{i,j,j}=f_{i,j,j}+f_{i-1,j,k}\times k$</li>
</ol>
<p>初始值为 $f_{0,1,1}$，最终答案即为 $f_{m,n,n}$，$\mathcal{O}(n^2m)$ 转移即可。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">310</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>; <span class="keyword">int</span> f[N][N][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span>&amp; x)</span> </span>&#123; x &gt;= mod ? x -= mod : <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m); f[<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">mo</span>(f[i][j][k] += (<span class="keyword">int</span>)(<span class="number">1ll</span> * f[i - <span class="number">1</span>][j - <span class="number">1</span>][k] * (n - j + <span class="number">1</span>) % mod));</span><br><span class="line">                <span class="built_in">mo</span>(f[i][j][k] += (<span class="keyword">int</span>)(<span class="number">1ll</span> * f[i - <span class="number">1</span>][j][k] * (j - k) % mod));</span><br><span class="line">                <span class="built_in">mo</span>(f[i][j][j] += (<span class="keyword">int</span>)(<span class="number">1ll</span> * f[i - <span class="number">1</span>][j][k] * k % mod));</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[m][n][n]); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="G-Zigzag-MST"><a href="#G-Zigzag-MST" class="headerlink" title="G - Zigzag MST"></a>G - Zigzag MST</h4><p>给出一个 $n$ 个点的无向图，点从 $0$ 到 $n-1$ 编号。给出 $q$ 组询问来加边，每次询问有 $A_i,B_i,C_i$ 三个参数，然后会加入形如 $(A_i,B_i,C_i),(B_i,A_i+1,C_i+1),(A_i+1,B_i+1,C_i+2),(B_i+1,A_i+2,C_i+3),(A_i+2,B_i+2,C_i+4)\cdot\cdot\cdot$ 的无限条无向边，这里的加法是在模 $n$ 意义下的。求出 $q$ 组询问后图的最小生成树边权和。($2\le n\le2\times10^6,1\le q\le2\times10^6,1\le C_i\le10^9$)</p>
<p>这题需要画很多图。首先我们来画一下按照题目描述，一组询问 $A,B,C$ 会加入的边（后面的省略）：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/un7xwzm2.png" alt=""></p>
<p>而注意到，如果 $(A+1,B,C+1)$ 这条边被加入的话，$(A,B,C)$ 也一定被考虑过了，不管加上没有，$A,B$ 一定是连通的，所以我们可以把 $(A+1,B,C+1)$ 改为 $(A+1,A,C+1)$ 而不影响结果，即：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/goikki83.png" alt=""></p>
<p>类似地，考虑 $(A+1,B+1,C+2)$ 时，$A+1,A,B$ 一定连通了，所以可以把 $(A+1,B+1,C+2)$ 改为 $(B,B+1,C+2)$，即：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/dzv5atza.png" alt=""></p>
<p>一直这么改下去，我们会得到这样一张图：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/rjalsv1b.png" alt=""></p>
<p>注意到这张图的特点是：$A,B$ 之间有一条权值为 $C$ 的边，$A+i,A+i+1$ 之间有一条权值为 $C+1+2i$ 的边，$B+i,B+i+1$ 之间有一条权值为 $C+2+2i$ 的边。方便起见，我们下文把 $A,B$ 之间的边叫做红边，剩下的边叫做绿边。则加入所有的询问之后，原图应该长这样：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/i8qfojx4.png" alt=""></p>
<p>其中加粗的绿边表示有无限条边。当然，因为是最小生成树，其实每两个点之间只有一条边是有用的，也就是权值最小的那条。所以我们接下来的任务就变为了找到两点之间边权值的最小值。</p>
<p>发现绿边其实都是由一个点 $S$ 出发，以 $x$ 为初始权值，每连接一组点给权值加 $2$ 得到的，形式化讲，$S+i,S+i+1$ 之间的权值为 $x+2i$。根据这个性质，我们可以考虑递推计算。我们设 $c_i$ 表示连接 $i$ 和 $i+1$ 的边中的最小权值，初始时均为无穷大。对于每组 $(S,x)$，我们更新一下 $c_S=\min(c_S,x)$。接着考虑连下去的边，则有 $c_{i+1}=\min(c_{i+1},c_{i}+2)(0\le i<n)$，这里的加法依然是模 $n$ 意义下。注意贡献是一个环，所以这个玩意要更新两遍。最终我们得到了 $n+q$ 条边，直接用 $\rm kruskal$ 跑最短路即可，时间复杂度 $\mathcal{O}((n+q)\log (n+q))$。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>; <span class="keyword">int</span> cst[N], f[N], tp, tot;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">int</span> u, v, w; </span><br><span class="line">    <span class="built_in">edge</span>(<span class="keyword">int</span> u = <span class="number">0</span>, <span class="keyword">int</span> v = <span class="number">0</span>, <span class="keyword">int</span> w = <span class="number">0</span>) : <span class="built_in">u</span>(u), <span class="built_in">v</span>(v), <span class="built_in">w</span>(w) &#123; &#125;</span><br><span class="line">&#125;E[N &lt;&lt; <span class="number">1</span>]; <span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x == f[x] ? x : f[x] = <span class="built_in">getf</span>(f[x]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(cst, <span class="number">0x7f</span>, <span class="built_in"><span class="keyword">sizeof</span></span> (cst)); <span class="keyword">int</span> n, q; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;q); </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, A, B, C; i &lt;= q; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;A, &amp;B, &amp;C); E[++tp] = <span class="built_in">edge</span>(A, B, C);</span><br><span class="line">        cst[A] = std::<span class="built_in">min</span>(cst[A], C + <span class="number">1</span>); cst[B] = std::<span class="built_in">min</span>(cst[B], C + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cst[(i + <span class="number">1</span>) % n] = std::<span class="built_in">min</span>(cst[(i + <span class="number">1</span>) % n], cst[i] + <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cst[(i + <span class="number">1</span>) % n] = std::<span class="built_in">min</span>(cst[(i + <span class="number">1</span>) % n], cst[i] + <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) E[++tp] = <span class="built_in">edge</span>(i, (i + <span class="number">1</span>) % n, cst[i]), f[i] = i;</span><br><span class="line">    std::<span class="built_in">sort</span>(E + <span class="number">1</span>, E + tp + <span class="number">1</span>, [&amp;](<span class="keyword">const</span> edge&amp; e1, <span class="keyword">const</span> edge&amp; e2) &#123; <span class="keyword">return</span> e1.w &lt; e2.w; &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, tx, ty; i &lt;= tp; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        tx = <span class="built_in">getf</span>(E[i].u), ty = <span class="built_in">getf</span>(E[i].v);</span><br><span class="line">        <span class="keyword">if</span> (tx != ty) ans += E[i].w, f[tx] = ty, ++tot;</span><br><span class="line">        <span class="keyword">if</span> (tot == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="H-Tokaido"><a href="#H-Tokaido" class="headerlink" title="H - Tokaido"></a>H - Tokaido</h4><p>有 $n$ 个方格从左到右编号为 $1\sim n$ 排成一列，初始时每一格上面有一个整数 $a_i$，Snuke 和 Rng 在按照以下的规则玩游戏：</p>
<ol>
<li>两个人各执一枚棋子，Snuke 放在一号方格，Rng 放在二号方格。</li>
<li>棋子在另一个人左边的人移动，移动的目的地必须是它当前位置的右边且不为对手的位置。</li>
<li>重复执行2.步骤直到无法行动。</li>
<li>每个人的得分是他的棋子经过的格子上面的整数之和。</li>
</ol>
<p>假设两个人都是足够聪明的，他们都想最大化自己比别人分数高的值。现在 $a_1\sim a_{n-1}$ 已经确定了，给出 $m$ 组询问 $x_i$，每组询问表示如果 $a_n=x_i$，则求出 Snuke 的分数 - Rng 的分数会是多少。($3\le n\le2\times10^5,0\le a_i\le10^6,\sum a_i\le10^6,1\le m\le2\times10^5,0\le x_i\le10^9$)</p>
<p>既然是博弈论，那么我们可以先考虑两个人怎么移动是最优的。注意到如果当前格子右边相邻的格子是空着的，则最优步数是棋子走到那里。原因显然，因为格子的权值非负，所以这样走不会损失分数，也不会损失自己的轮次。所以游戏的步骤（计分系统不变）如果改成这样是相同的：</p>
<ul>
<li>每次移动完棋子，玩家要把对手的棋子一格一格移动到他棋子的左边。</li>
<li>每次移动完后两个棋子是相邻的。</li>
</ul>
<p>接下来首先考虑 $m=1$ 的部分分。考虑 $\rm dp$，我们设 $f_i$ 表示从玩家的棋子位置在 $i-1$ 号格子，对手的棋子在 $i$ 号格子开始，能得到的玩家分数比对手多的分数的最大值。注意这里状态不包括 $a_{i-1}$ 和 $a_i$ 的差，这样最终答案即为 $f_2+a_1-a_2$。最朴素的转移为：</p>
<script type="math/tex; mode=display">f_i=\max_{i<j\le n}\{a_j-\operatorname{sum}(a_{i+1}\sim a_{j-1})-f_{j}\}</script><p>其中 $\operatorname{sum}(a_l\sim a_r)$ 表示 $a_l$ 到 $a_r$ 的和。但这样直接转移是 $\mathcal{O}(n^2)$ 的，显然无法接受。</p>
<p>发现 $f_i=\max_{i&lt;j\le n}\{a_j-\operatorname{sum}(a_{i+1}\sim a_{j-1})-f_{j}\}$，而 $f_{i+1}=\max_{i+1&lt;j\le n}\{a_j-\operatorname{sum}(a_{i+1+1}\sim a_{j-1})-f_{j}\}$，长得真的很像。所以我们考虑能不能把 $f_{i+1}$ 扔到 $f_i$ 的转移里面，这样就会快很多，变一变式子，有：</p>
<script type="math/tex; mode=display">f_{i}=\max\left(\max_{i+1<j\le n}\{a_j-a_{i+1}-\operatorname{sum}(a_{i+1+1}\sim a_{j-1})-f_j\},a_{i+1}-f_{i+1}\right)</script><p>即，$f_{i}=\max(f_{i+1}-a_{i+1},a_{i+1}-f_{i+1})$。可以做到 $\mathcal{O}(n)$ 转移了。</p>
<p>接下来考虑正解。注意到原式子其实就是 $f_{i}=|f_{i+1}-a{i+1}|$。那这样我们就没必要再用 $f$ 数组来递推结果了，直接用一个 $x$ 记录结果，考虑以下伪代码：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x := a[n]</span><br><span class="line">for i := n - 1 down to 3 </span><br><span class="line">    x := abs(x - a[i])</span><br><span class="line">ans := x + a[1] - a[2]</span><br></pre></td></tr></table></figure><br>我们叫这个算法 x 算法，接下来的问题就是当 <code>a[n]</code> 改变时快速计算 $x$ 的值。（注意接下来我们不再考虑 <code>a[1]-a[2]</code> 的值，因为只有 $x$ 的值是有用的）</p>
<p>当 $a_n$ 很大时，具体来讲，当 $a_n\ge \operatorname{sum}(a_1\sim a_{n-1})$ 时，所有 $\operatorname{abs}(x-a_i)$ 都应该等于 $x-a_i$，这样最终的 $x$ 就等于 $a_n-\operatorname{sum}(a_3\sim a_{n-1})$。</p>
<p>当 $a_n$ 比较小时，具体来讲，当 $a_n&lt; \operatorname{sum}(a_1\sim a_{n-1})$ 时，由于题目数据范围的限制，应该有 $a_n\le 10^6$。这个就比原范围 $10^9$ 来得友好得多了，我们可以考虑对每一种情况都提前预处理一下。具体来讲，我们设 $dp_{j,k}$ 表示当伪代码中的循环运行到 $i=j$ 时（特别地，我们令第 $i=n$ 表示循环之前的那一行语句），$x$ 的值为 $k$，$x$ 的最终值为 $dp_{j,k}$。首先显然有 $dp_{3,k}=k$，然后当对于 $a_n$ 的某个特定值，$x$ 的最终值为 $dp_{n,a_n}$。转移有 $dp_{j+1,k}=dp_{j,\operatorname{abs}(k-a_j)}$。当然我们不可能真的开下这样一个 $dp$ 数组，我们关心的只有 $dp_n$ 这一行，所以我们尝试用小数据打个表，看看能不能找到 $dp_n$ 的什么规律，当 $n=6,a_3=5,a_4=3,a_5=4$ 时，有：</p>
<script type="math/tex; mode=display">\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}k&\bf 0&\bf 1&\bf 2&\bf 3&\bf 4&\bf 5&\bf 6&\bf 7&\bf 8&\bf 9&\bf 10&\bf 11&\bf 12&\bf 13&\bf 14&\bf 15\\dp_{3,k}&0&1&2&3&4&5&6&7&8&9&10&11&12&13&14&15\\dp_{4,k}&5&4&3&2&1&0&1&2&3&4&5&6&7&8&9&10\\dp_{5,k}&2&3&4&5&4&3&2&1&0&1&2&3&4&5&6&7\\dp_{6,k}&4&5&4&3&2&3&4&5&4&3&2&1&0&1&2&3\end{array}</script><p>如果我们能找出来 $dp_6$ 的值对于所有小的 $a_n$ 询问都可以 $\mathcal{O}(1)$ 回答了，当然这个表格也很有规律：</p>
<script type="math/tex; mode=display">\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}k&\bf 0&\bf 1&\bf 2&\bf 3&\bf 4&\bf 5&\bf 6&\bf 7&\bf 8&\bf 9&\bf 10&\bf 11&\bf 12&\bf 13&\bf 14&\bf 15\\dp_{3,k}&0&\color{red}1&\color{red}2&\color{red}3&\color{red}4&\color{red}5&6&7&8&9&10&11&12&13&14&15\\dp_{4,k}&\color{blue}5&\color{purple}4&\color{purple}3&\color{purple}2&\color{blue}1&0&1&2&3&4&5&6&7&8&9&10\\dp_{5,k}&\color{blue}2&\color{purple}3&\color{purple}4&\color{red}5&\color{red}4&3&2&1&0&1&2&3&4&5&6&7\\dp_{6,k}&\color{blue}4&\color{blue}5&\color{blue}4&\color{blue}3&2&3&4&5&4&3&2&1&0&1&2&3\end{array}</script><p>注意到每行 $dp_i$ 的开头，也就是蓝色部分，其实是上一行的红色部分，也就是 $dp_{i-1,1\sim a_{i-1}}$ 倒序放过来的（蓝色红色重叠的部分我放上紫色了）。我们根据这个规律就非常好递推了，随便用个 <code>deque</code> 维护一下当前处理到的 $dp_i$，然后每一轮开个 <code>vector</code> 之类的记录一下要把哪些塞到前面，之后直接倒序塞即可。因为题目保证了 $\sum a_i$ 的范围，所以 <code>deque</code> 只 <code>push_front</code> 不 <code>pop_back</code> 也不会导致 $\tt MLE$，而递推复杂度也只有 $\mathcal{O}(\sum a_i)$。处理出来 $dp_n$ 之后就可以是 $\mathcal{O}(1)$ 回答询问了（这个规律的证明比较不好用语言描述我就不写了，可以自己多手玩几组数据递推一下，应该就能发现证明）。所以本题最终时间复杂度 $\mathcal{O}(n+m+\sum a_i)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>; <span class="keyword">int</span> a[N]; std::deque&lt;<span class="keyword">int</span>&gt; dp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, sum = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n); </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]), sum += a[i];</span><br><span class="line">    sum -= a[<span class="number">1</span>]; sum -= a[<span class="number">2</span>]; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= sum; ++i) dp.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        std::vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= a[i]; ++j) vec.<span class="built_in">push_back</span>(dp[j]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); ++i) dp.<span class="built_in">push_front</span>(vec[i]);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">int</span> m; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= sum) &#123; <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x - sum + a[<span class="number">1</span>] - a[<span class="number">2</span>]); &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[x] + a[<span class="number">1</span>] - a[<span class="number">2</span>]); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>I 和 J 实在太难了，目前我对着题解还不太会（$\rm \color{black}T\color{red}ourist$ 是怎么当场 AK 的啊）。总之这一场思维难度很大，感觉比较贴近最近 CCF 的出题风格，尤其是 E 题的推导和 H 题的打表给我印象很深。这就是 OI 与 MO 不一样的地方，你不一定要一直推导下去，当发现无论怎么想都找不到出口时，不妨想想，能不能已经可以开始枚举了呢，能不能打个表找找规律呢。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhiyangfan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhiyangfan</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
