<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zhiyangfan1234.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="zhiyangfan 的博客小窝">
<meta property="og:url" content="https://zhiyangfan1234.github.io/index.html">
<meta property="og:site_name" content="zhiyangfan 的博客小窝">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="zhiyangfan">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://zhiyangfan1234.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>zhiyangfan 的博客小窝</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">zhiyangfan 的博客小窝</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhiyangfan1234.github.io/2022/01/24/AtCoder%20Beginner%20Contest%20233/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhiyangfan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhiyangfan 的博客小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/24/AtCoder%20Beginner%20Contest%20233/" class="post-title-link" itemprop="url">AtCoder Beginner Contest 233</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-01-24 17:00:23 / 修改时间：17:10:50" itemprop="dateCreated datePublished" datetime="2022-01-24T17:00:23+08:00">2022-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="AtCoder-Beginner-Contest-233"><a href="#AtCoder-Beginner-Contest-233" class="headerlink" title="AtCoder Beginner Contest 233"></a>AtCoder Beginner Contest 233</h2><p>F 写了个奇妙的类似模拟退火的玩意，最终肯定是没过。</p>
<p>还有 Ex 一眼 KD-tree，kuai 了个板子一交发现 $\tt TLE$ 才看到数据范围。</p>
<h3 id="A-10yen-Stamp"><a href="#A-10yen-Stamp" class="headerlink" title="A - 10yen Stamp"></a>A - 10yen Stamp</h3><p>给出 $x,y$，求使得 $x+10k\ge y$ 的最小非负整数 $k$。($1\le x,y\le 10^3$)</p>
<p>稍微变一下就有：$10k=\max(y-x,0)$，即：</p>
<script type="math/tex; mode=display">k=\left\lceil\dfrac{\max(y-x,0)}{10}\right\rceil</script><p>直接算即可，时间复杂度 $\mathcal{O}(1)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in"><span class="keyword">int</span></span>(<span class="built_in">ceil</span>(std::<span class="built_in">max</span>(<span class="number">0</span>, y - x) / <span class="number">10.0</span>)));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="B-A-Reverse"><a href="#B-A-Reverse" class="headerlink" title="B - A Reverse"></a>B - A Reverse</h3><p>给出一个字符串 $S$，和两个整数 $L,R$，输出将 $S$ 中第 $L$ 个字符到第 $R$ 个字符反转后得到的字符串。($1\le |S|\le 10^5$)</p>
<p><code>std::reverse(lef, rig)</code> 函数，能把 <code>lef</code> 到 <code>rig - 1</code> 地址区间内的元素反转。直接套用即可，时间复杂度 $\mathcal{O}(|S|)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l, r; std::string s;</span><br><span class="line">    std::cin &gt;&gt; l &gt;&gt; r &gt;&gt; s;</span><br><span class="line">    std::<span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + l - <span class="number">1</span>, s.<span class="built_in">begin</span>() + r);</span><br><span class="line">    std::cout &lt;&lt; s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="C-Product"><a href="#C-Product" class="headerlink" title="C - Product"></a>C - Product</h3><p>有 $n$ 个袋子，每个袋子里面有 $L_i$ 个球，第 $i$ 个袋子里的第 $j$ 个球上写着 $a_{ij}$。问从每个袋子各拿出一个球使得上面写的数积为 $x$ 的方案数。($n,L_i\ge 2,\prod_{i=1}^n L_i\le 10^5,1\le a_{ij}\le 10^9,1\le x\le 10^{18}$)</p>
<p>注意到所有可能的情况是 $\prod_{i=1}^n L_i$ 而题目保证它在一个合理范围内，所以我们可以直接用 $\rm dfs$ 枚举全部的情况计算。时间复杂度 $\mathcal{O}(\prod L_i)$，注意有符号整型溢出问题。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>; std::vector&lt;<span class="keyword">int</span>&gt; a[N]; <span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">long</span> <span class="keyword">long</span> aim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (now == n + <span class="number">1</span>) <span class="keyword">return</span> (aim == <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>, k = a[now][<span class="number">0</span>]; <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//这个是把连续的 a_&#123;ij&#125; 都合并</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a[now].<span class="built_in">size</span>(); ++i)</span><br><span class="line">        <span class="keyword">if</span> (a[now][i] != k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (aim % k == <span class="number">0</span>) ret += cnt * <span class="built_in">work</span>(now + <span class="number">1</span>, aim / k);</span><br><span class="line">            cnt = <span class="number">1</span>; k = a[now][i];</span><br><span class="line">        &#125; <span class="keyword">else</span> ++cnt;</span><br><span class="line">    <span class="keyword">if</span> (cnt &amp;&amp; aim % k == <span class="number">0</span>) ret += cnt * <span class="built_in">work</span>(now + <span class="number">1</span>, aim / k);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x; <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>, &amp;n, &amp;x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;l);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, x; j &lt;= l; ++j) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x), a[i].<span class="built_in">push_back</span>(x);</span><br><span class="line">        std::<span class="built_in">sort</span>(a[i].<span class="built_in">begin</span>(), a[i].<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">work</span>(<span class="number">1</span>, x));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="D-Count-Interval"><a href="#D-Count-Interval" class="headerlink" title="D - Count Interval"></a>D - Count Interval</h3><p>给出一个长为 $n$ 的序列 $a$ 和一个整数 $k$，求满足以下条件的有序二元组 $(l,r)$ 个数：</p>
<ul>
<li>$1\le l\le r\le n$。</li>
<li>$\sum_{i=l}^r a_i=k$</li>
</ul>
<p>($1\le n\le 2\times10^5,|a_i|\le 10^9,|k|\le 10^{15}$)</p>
<p>这个就显然可以转化成前缀和上的问题，设 $s_i=\sum_{j=1}^i a_j$。则原问题的第二个条件相当于：</p>
<script type="math/tex; mode=display">s_r-s_{l-1}=k</script><p>即 $s_{l-1}=s_r-k$，所以我们可以对于每个 $r$ 考虑对应的 $l-1$ 个数，即对于每个 $r$ 我们找到满足 $1\le i<r,s_i=s_r-k$ 的 $i$ 个数。统计可以用 `std::map` 轻松完成。时间复杂度 $\mathcal{O}(n\log n)$。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>; <span class="keyword">int</span> a[N]; <span class="keyword">long</span> <span class="keyword">long</span> sum[N]; std::map&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="keyword">long</span> <span class="keyword">long</span> k; <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]), sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    mp[<span class="number">0</span>] = <span class="number">1</span>; <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mp.<span class="built_in">count</span>(sum[i] - k) &gt; <span class="number">0</span>) ans += mp[sum[i] - k];</span><br><span class="line">        ++mp[sum[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="E-Σ-k-0-10-100-floor-X／10-k"><a href="#E-Σ-k-0-10-100-floor-X／10-k" class="headerlink" title="E - Σ[k=0..10^100]floor(X／10^k)"></a>E - Σ[k=0..10^100]floor(X／10^k)</h3><p>求：</p>
<script type="math/tex; mode=display">\sum_{k=0}^{10^{100}}\left\lfloor\dfrac{x}{10^k}\right\rfloor</script><p>的值。($1\le x\le 10^{5\times 10^5}$)</p>
<p>如果我们把 $x$ 表示为多项式的形式：</p>
<script type="math/tex; mode=display">x=\sum_{i=0}^{L}a_i10^i</script><p>其中 $L=\lfloor\log_{10}x\rfloor$。则式子其实相当于：</p>
<script type="math/tex; mode=display">\sum_{k=0}^{L}\sum_{i=k}^La_i10^{i-k}</script><p>简单变换有：</p>
<script type="math/tex; mode=display">\sum_{k=0}^{L}\sum_{i=0}^{L-k}a_{i+k}10^{i}</script><p>交换求和顺序：</p>
<script type="math/tex; mode=display">\sum_{i=0}^L10^i\sum_{k=0}^{L-i}a_{i+k}=\sum_{i=0}^L10^i\sum_{k=i}^{L}a_{k}</script><p>后面的就是个前缀和（看起来是后缀，但其实我们按照字符串读入的时候已经反转过了，所以是前缀），预处理之后可以直接求。这道题唯一麻烦的一点是需要高精度，简单实现一下就好。时间复杂度 $\mathcal{O}(\log x)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">10</span>; <span class="keyword">char</span> s[N]; <span class="keyword">int</span> a[N], sum[N], ans[N &lt;&lt; <span class="number">1</span>], tp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>); <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = s[i] - <span class="string">&#x27;0&#x27;</span>, sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        ans[++tp] = (sum[i] + k) % <span class="number">10</span>, k = (sum[i] + k) / <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (k) ans[++tp] = k % <span class="number">10</span>, k /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = tp; i &gt;= <span class="number">1</span>; --i) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="F-Swap-and-Sort"><a href="#F-Swap-and-Sort" class="headerlink" title="F - Swap and Sort"></a>F - Swap and Sort</h3><p>有一个 $1\sim n$ 的排列 $\mathcal{P}$。一共能在上面执行 $m$ 种操作，每种操作用一个二元组 $(a_i,b_i)$ 描述，表示交换 $\mathcal{P}_{a_i},\mathcal{P}_{b_i}$。求能否在 $5\times10^5$ 次操作内将 $\mathcal{P}$ 按升序排列，如果能构造出方案，否则报告无解。($2\le n\le 10^3,1\le m\le \min(2\times10^5,\frac{n(n-1)}{2}),\forall i\ne j$，都有 $(a_i,b_i)\ne (a_j,b_j)$)</p>
<p>我们首先从报告无解的角度思考，即什么样的情况是无解的。注意到操作与操作之间是有传递性的，即 $\mathcal{P}_i,\mathcal{P}_j$ 可交换，$\mathcal{P}_j,\mathcal{P}_k$ 可交换，则 $\mathcal{P}_i,\mathcal{P}_k$ 可交换，可以通过构造方案证明。满足这种性质的条件通常可以建模为图论模型，用连通性的传递性来表示可交换的传递性。具体来讲，对于每个操作 $(a_i,b_i)$，我们在 $\mathcal{P}_{a_i},\mathcal{P}_{b_i}$ 之间连一条无向边，这样原图会被分为若干个连通块。同一连通块之中的点两两可以相互交换，不同连通块之间的点不能交换。所以如果存在一个连通块使得存在一个 $i$ 满足 $\mathcal{P}_i$ 不属于该连通块，则原问题无解。</p>
<p>接下来考虑构造方案。在形成的无向图中，注意到我们找到它的一个生成森林不会影响结果（因为连通性不变）。这样，在生成森林中我们优先考虑叶子结点，因为它们能进行的操作最少，不需要枚举考虑。并暴力 $\rm dfs$ 找到一种方案把这个点换到该换的位置，如果找不到（其实就是上文讨论过的 $i,\mathcal{P}_i$ 不在同一连通块）则无解。否则记录下该方案并将这个点删去，表示以后不再影响。这个方法看起来很暴力，但是细细分析，每次最多进行的操作次数为 $999,998,\cdot\cdot\cdot,1$，和为 $499,500$ 满足题目要求。时间复杂度 $\mathcal{O}(n^3)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">10</span>, M = <span class="number">5e5</span> + <span class="number">10</span>; </span><br><span class="line"><span class="keyword">int</span> deg[N], p[N], rev[N], ans[M], tp; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DSU</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> f[N], len;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; len = n; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) f[i] = i; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x == f[x] ? x : f[x] = <span class="built_in">getf</span>(f[x]); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tx = <span class="built_in">getf</span>(x), ty = <span class="built_in">getf</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (tx != ty) &#123; f[tx] = ty; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;dsu;</span><br><span class="line">std::vector&lt;std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; vec[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> aim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == aim) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : vec[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (v.first == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dfs</span>(v.first, u, aim))</span><br><span class="line">        &#123;</span><br><span class="line">            ans[++tp] = v.second;</span><br><span class="line">            std::<span class="built_in">swap</span>(rev[p[v.first]], rev[p[u]]);</span><br><span class="line">            std::<span class="built_in">swap</span>(p[v.first], p[u]);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n); dsu.<span class="built_in">init</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p[i]), rev[p[i]] = i;</span><br><span class="line">    <span class="keyword">int</span> m; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span> (dsu.<span class="built_in">merge</span>(x, y))</span><br><span class="line">        &#123;</span><br><span class="line">            ++deg[x]; ++deg[y];</span><br><span class="line">            vec[x].<span class="built_in">emplace_back</span>(y, i);</span><br><span class="line">            vec[y].<span class="built_in">emplace_back</span>(x, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t = n;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (deg[i] != <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> x = rev[i];</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(i, <span class="number">-1</span>, x)) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>), <span class="number">0</span>;</span><br><span class="line">            --deg[i]; <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : vec[i]) --deg[v.first];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tp; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ans[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="G-Strongest-Takahashi"><a href="#G-Strongest-Takahashi" class="headerlink" title="G - Strongest Takahashi"></a>G - Strongest Takahashi</h3><p>给出一个 $n\times n$ 的网格，其中一些格子是黑色的，其余的为白色。可以进行若干次以下操作：</p>
<ul>
<li>选择一个 $1\sim n$ 的正整数 $d$，并在网格上选择任意一个 $d\times d$ 的正方形。</li>
<li>花费 $d$ 的代价把这个正方形内所有黑色格子变白。</li>
</ul>
<p>求把所有格子均变为白色的最小代价。($1\le n\le50$)</p>
<p>注意到对于任意一个矩形 $(lx,ly,rx,ry)$（其中 $(lx,ly)$ 表示左上角点的坐标，$(rx,ry)$ 表示右下角点的坐标）我们显然可以用 $\max(ly-lx+1,ry-rx+1)$ 的代价把它之中的所有黑色格子消除。但什么时候存在更小的代价呢？显然，如果矩形内存在一行或一列满足所有的格子均为白色，则我们就可以以这一行或者这一列为分割线将矩形分为两个子矩形分别处理，可以发现，这一定会比最朴素的情况更优。而对于子矩阵的处理就相当于原问题的子问题了，可以用 $\rm dp$ 或记忆化搜索解决。暴力实现是 $\mathcal{O}(n^6)$，实现稍微精细一点可以做到 $\mathcal{O}(n^5)$。但不管哪种，由于有大量状态是无法达到的，所以这个复杂度常数很小，都足以通过。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">60</span>, inf = N * N; <span class="keyword">int</span> f[N][N][N][N]; <span class="keyword">char</span> s[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> lx, <span class="keyword">int</span> ly, <span class="keyword">int</span> rx, <span class="keyword">int</span> ry)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lx &gt; rx || ly &gt; ry) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (f[lx][ly][rx][ry] &lt; inf) <span class="keyword">return</span> f[lx][ly][rx][ry];</span><br><span class="line">    <span class="keyword">int</span> t = std::<span class="built_in">max</span>(ry - ly + <span class="number">1</span>, rx - lx + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lx; i &lt;= rx; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = ly; j &lt;= ry &amp;&amp; flag; ++j) flag &amp;= (s[i][j] == <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (flag) t = std::<span class="built_in">min</span>(t, <span class="built_in">dp</span>(lx, ly, i - <span class="number">1</span>, ry) + <span class="built_in">dp</span>(i + <span class="number">1</span>, ly, rx, ry));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = ly; i &lt;= ry; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = lx; j &lt;= rx &amp;&amp; flag; ++j) flag &amp;= (s[j][i] == <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (flag) t = std::<span class="built_in">min</span>(t, <span class="built_in">dp</span>(lx, ly, rx, i - <span class="number">1</span>) + <span class="built_in">dp</span>(lx, i + <span class="number">1</span>, rx, ry));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[lx][ly][rx][ry] = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s[i] + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k) <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= n; ++l) f[i][j][k][l] = inf;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">dp</span>(<span class="number">1</span>, <span class="number">1</span>, n, n)); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Ex-Manhattan-Christmas-Tree"><a href="#Ex-Manhattan-Christmas-Tree" class="headerlink" title="Ex - Manhattan Christmas Tree"></a>Ex - Manhattan Christmas Tree</h3><p>给出一个平面上的 $n$ 个点，第 $i$ 个点坐标为 $(x_i,y_i)$。现在有 $q$ 次询问，每次询问在曼哈顿距离下距离点 $(a_i,b_i)$ 第 $k_i$ 近的点与 $(a_i,b_i)$ 的距离。($1\le n,q\le 10^5,0\le x_i,y_i,a_i,b_i\le 10^5,1\le k\le n,\forall i\ne j$，都有 $(a_i,b_i)\ne (a_j,b_j)$)</p>
<p>有一个经典的 trick，遇到曼哈顿距离下的一些问题，可以考虑通过旋转坐标系使曼哈顿距离变为切比雪夫距离，而后者往往在某些题目需要的方面有更优的性质。我们定义曼哈顿距离 $d_m((x_1,y_1),(x_2,y_2))=|x_1-x_2|+|y_1-y_2|$，定义切比雪夫距离 $d_q((x_1,y_1),(x_2,y_2))=\max(|x_1-x_2|,|y_1-y_2|)$。如果我们把平面上与 $(x,y)$ 曼哈顿距离不超过 $d$ 的点构成的区域画出来就有：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/74ht6hbh.png" alt=""></p>
<p>这是一个正方形。证明可以考虑上面的点的解析式，不妨先看第一象限。它们的坐标满足 $x+y=d$，即一个与 $x$ 轴夹角为 $45\degree$ 的直线。推广一下，这个图形就是正方形。</p>
<p>如果我们把平面上与 $(x,y)$ 切比雪夫距离不超过 $d$ 的点构成的区域画出来就有：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/u0fsgrux.png" alt=""></p>
<p>这也是一个正方形。证明比较显然。边长是上面曼哈顿距离构成的正方形的 $\sqrt{2}$ 倍。</p>
<p>而我们把每个点看成极坐标 $(\rho,\theta)$，对应的普通坐标为 $(\rho\cos\theta,\rho\sin\theta)$。如果把平面逆时针旋转 $\dfrac{\pi}{4}$，则坐标会变为 $\left(\rho,\theta+\dfrac{\pi}{4}\right)$。而转换成普通坐标就有 $\left(\rho\cos\left(\theta+\dfrac{\pi}{4}\right),\rho\sin\left(\theta+\dfrac{\pi}{4}\right)\right)$，用一下三角函数的和角公式就能得到：$\left(\rho\dfrac{\sqrt{2}}{2}(\cos\theta-\sin\theta),\rho\dfrac{\sqrt{2}}{2}(\cos\theta+\sin\theta)\right)$，代入 $x=\rho\cos\theta,y=\rho\sin\theta$ 并把横纵坐标缩小 $\sqrt{2}$ 倍就能得到旋转后的坐标 $(x-y,x+y)$。那这么旋转有啥用呢？注意到旋转完后，曼哈顿距离的正方形就变为了切比雪夫的正方形，所以曼哈顿距离也就变为了切比雪夫距离。</p>
<p>回到原问题，考虑二分这个距离。我们数出与该点距离小于等于当前二分的答案的点个数，根据它与 $k$ 的大小关系判断。而这个数数其实就是二维数点。但值域太大，我们不能直接用朴素的树状数组维护。但因为 $y$ 可能的值不多，我们把每种 $y$ 的值开一个数组，里面塞上从小到大排的 $x$。这样查询的时候找到对应的数组在里面二分就可以了。时间复杂度 $\mathcal{O}(n\log^2n+q\log^3n)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>; std::vector&lt;std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; p;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BIT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; c[N &lt;&lt; <span class="number">1</span>]; <span class="keyword">int</span> len;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = y; i &lt;= len; i += <span class="built_in">lowbit</span>(i)) c[i].<span class="built_in">push_back</span>(x); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> y, <span class="keyword">int</span> lx, <span class="keyword">int</span> rx)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>; y = std::<span class="built_in">min</span>(std::<span class="built_in">max</span>(y, <span class="number">0</span>), len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = y; i; i -= <span class="built_in">lowbit</span>(i))</span><br><span class="line">            ans += std::<span class="built_in">upper_bound</span>(c[i].<span class="built_in">begin</span>(), c[i].<span class="built_in">end</span>(), rx) - std::<span class="built_in">lower_bound</span>(c[i].<span class="built_in">begin</span>(), c[i].<span class="built_in">end</span>(), lx);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> lx, <span class="keyword">int</span> ly, <span class="keyword">int</span> rx, <span class="keyword">int</span> ry)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">query</span>(ry, lx, rx) - <span class="built_in">query</span>(ly - <span class="number">1</span>, lx, rx); &#125;</span><br><span class="line">&#125;bit;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bit.len = N * <span class="number">2</span>; <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n); </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y), p.<span class="built_in">emplace_back</span>(x - y + <span class="number">1</span>, x + y + <span class="number">1</span>);</span><br><span class="line">    std::<span class="built_in">sort</span>(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : p) bit.<span class="built_in">add</span>(v.first, v.second);</span><br><span class="line">    <span class="keyword">int</span> q; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b, k; i &lt;= q; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;k);</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = N * <span class="number">2</span>, mid, ans;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (bit.<span class="built_in">query</span>(a - b - mid + <span class="number">1</span>, a + b - mid + <span class="number">1</span>, a - b + mid + <span class="number">1</span>, a + b + mid + <span class="number">1</span>) &gt;= k) ans = mid, r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhiyangfan1234.github.io/2022/01/24/AtCoder%20Beginner%20Contest%20236/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhiyangfan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhiyangfan 的博客小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/24/AtCoder%20Beginner%20Contest%20236/" class="post-title-link" itemprop="url">AtCoder Beginner Contest 236</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-01-24 17:00:23 / 修改时间：17:10:58" itemprop="dateCreated datePublished" datetime="2022-01-24T17:00:23+08:00">2022-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="AtCoder-Beginner-Contest-236"><a href="#AtCoder-Beginner-Contest-236" class="headerlink" title="AtCoder Beginner Contest 236"></a>AtCoder Beginner Contest 236</h2><p>实现了新年前上蓝的 flag</p>
<h3 id="A-chukodai"><a href="#A-chukodai" class="headerlink" title="A - chukodai"></a>A - chukodai</h3><blockquote>
<p>给出一个只含有小写字母的字符串 $S$，交换第 $a$ 个和第 $b$ 个字符后输出。($2\le |S|\le 10$)</p>
</blockquote>
<p>直接上 <code>std::swap</code> 函数，没什么好说的。时间复杂度 $\mathcal{O}(1)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>; <span class="keyword">char</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a, b; <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, s + <span class="number">1</span>, &amp;a, &amp;b); std::<span class="built_in">swap</span>(s[a], s[b]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s + <span class="number">1</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="B-Who-is-missing"><a href="#B-Who-is-missing" class="headerlink" title="B - Who is missing?"></a>B - Who is missing?</h3><blockquote>
<p>有 $4n$ 张卡片，数字 $i(1\le i\le n)$ 对应的卡片恰有 $4$ 张。现在拿走了一张，给出剩下的 $4n-1$ 张卡片，求出拿走了哪张。($1\le n\le 10^5$)</p>
</blockquote>
<p>开个桶记录一下哪个数字出现了 $3$ 次就好，唯一的坑点是数组要开 $4$ 倍。时间复杂度 $\mathcal{O}(n)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">10</span>; <span class="keyword">int</span> a[N], cnt[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span> * n - <span class="number">1</span>; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]), ++cnt[a[i]];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (cnt[i] == <span class="number">3</span>) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i), <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="C-Route-Map"><a href="#C-Route-Map" class="headerlink" title="C - Route Map"></a>C - Route Map</h3><blockquote>
<p>给出 $n$ 个字符串 $S$ 和 $m$ 个字符串 $T$，对于所有的 $S_i(1\le i\le n)$，求它是否在 $T$ 中出现过。($2\le m\le n\le 10^5,\sum=\{\mathtt{a\sim z}\}$)</p>
</blockquote>
<p>直接 <code>std::map</code> 记录就行。时间复杂度 $\mathcal{O}(n\log n)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; map&lt;string, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>; std::string s[N], t[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> n, m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; s[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) cin &gt;&gt; t[i], mp[t[i]] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">puts</span>(mp[s[i]] ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="D-Dance"><a href="#D-Dance" class="headerlink" title="D - Dance"></a>D - Dance</h3><blockquote>
<p>$2n$ 个人，第 $i$ 个人和第 $j$ 个人组合会得到 $a_{i,j}(i&lt;j)$ 的权值。如果第 $i$ 组得到的权值是 $b_i$，则一个分组方案的权值是 $\bigoplus_{i=1}^n b_i$，其中 $\oplus$ 表示按位异或。求分组方案中最大的权值。($1\le n\le 8,1\le a_{ij}&lt;2^{30}$)</p>
</blockquote>
<p>写了个 $(2n)!$ 的暴力交上去才想起来复杂度不对。不过这题正解确实是暴力 $\rm dfs$ 哈，但不能太暴力，直接枚举 $2n$ 个人的全排列是不行的。正确的复杂度是每次选俩人，其中一个是根据 $\rm dfs$ 状态钦定的，另一个是枚举的，这样大概的状态总数只有 $15\times13\times11\cdot\cdot\cdot\times 3=2,027,025$ 足以通过本题。时间复杂度 $\mathcal{O}(?)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">17</span>; <span class="keyword">int</span> n, ans, a[N][N], vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> c)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &gt; <span class="number">2</span> * n) <span class="keyword">return</span> ans = std::<span class="built_in">max</span>(ans, c), <span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">	<span class="keyword">if</span> (vis[x]) <span class="keyword">return</span> <span class="built_in">dfs</span>(x + <span class="number">1</span>, c);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = x + <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; ++i) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">		vis[x] = vis[i] = <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(x + <span class="number">1</span>, c ^ a[x][i]);</span><br><span class="line">		vis[x] = vis[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">2</span> * n; ++i) </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= <span class="number">2</span> * n; ++j) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>); <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="E-Average-and-Median"><a href="#E-Average-and-Median" class="headerlink" title="E - Average and Median"></a>E - Average and Median</h3><blockquote>
<p>给出一个长为 $n$ 的序列 $a$，现在从中选出若干项，满足对于所有的 $1\le i&lt;n$，第 $a_i$ 和 $a_{i+1}$ 至少有一个被选。求选出的数可能的最大平均数和中位数，题目允许平均数一定的精度误差。($2\le n\le 10^5,1\le a_i\le10^9$)</p>
</blockquote>
<p>考虑题目中给的条件——允许精度误差，可以想到二分答案。现在的问题是考虑怎么判断一个序列能否按照上面的规则形成平均数和中位数。</p>
<p>对于某个长为 $n$ 的序列 $b$，判断它的平均数与 $v$ 的关系可以用：</p>
<script type="math/tex; mode=display">\sum_{i=1}^{n}(b_i-v)</script><p>与 $0$ 的关系来判断。同理，判断它的中位数与 $v$ 的关系可以用：</p>
<script type="math/tex; mode=display">\sum_{i=1}^n(-1)^{[b_i<v]}</script><p>与 $0$ 的关系来判断。</p>
<p>所以我们考虑对于原序列 $a$ 找到一个满足题目条件的子序列，且使得上式最大，判断和 $0$ 的关系就能找到二分出来的答案是大了还是小了。显然可以通过 $\rm dp$ 实现，只需设 $f_{i,0/1}$ 表示当前选还是不选。时间复杂度 $\mathcal{O}(n\log a)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>; <span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[N]; <span class="keyword">double</span> dp[N][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">checkAve</span><span class="params">(<span class="keyword">double</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i][<span class="number">1</span>] = std::<span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>]) + a[i] - v;</span><br><span class="line">	<span class="keyword">return</span> std::<span class="built_in">max</span>(dp[n][<span class="number">0</span>], dp[n][<span class="number">1</span>]) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">checkMid</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i][<span class="number">1</span>] = std::<span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>]) + (a[i] &gt;= v ? <span class="number">1</span> : <span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span> std::<span class="built_in">max</span>(dp[n][<span class="number">0</span>], dp[n][<span class="number">1</span>]) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">	<span class="keyword">double</span> l = <span class="number">0</span>, r = <span class="number">1e9</span>, mid;</span><br><span class="line">	<span class="keyword">while</span> (r - l &gt; eps)</span><br><span class="line">	&#123;</span><br><span class="line">		mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">checkAve</span>(mid)) l = mid;</span><br><span class="line">		<span class="keyword">else</span> r = mid;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.9lf\n&quot;</span>, l);</span><br><span class="line">	<span class="keyword">int</span> L = <span class="number">0</span>, R = <span class="number">1e9</span>, MID, ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (L &lt;= R)</span><br><span class="line">	&#123;</span><br><span class="line">		MID = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">checkMid</span>(MID)) L = MID + <span class="number">1</span>, ans = MID;</span><br><span class="line">		<span class="keyword">else</span> R = MID - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="F-Spices"><a href="#F-Spices" class="headerlink" title="F - Spices"></a>F - Spices</h3><blockquote>
<p>有 $2^n-1$ 种香料，第 $i$ 种价格为 $c_i$。混合 $k$ 种香料，即第 $a_1$ 种，第 $a_2$ 种……第 $a_k$ 种，能获得的辣度是 $\bigoplus_{i=1}^k a_i$。求满足能组合出 $1\sim 2^n-1$ 中任意辣度最少需要花多少钱买香料。($2\le n\le 16,1\le c_i\le 10^9$)</p>
</blockquote>
<p>谢谢你 AT，被这题送上蓝了。线性基板子，考虑线性基一个性质，一个数 $x$ 插入完后，如果 $x=0$，就说明 $x$ 能被当前集合中的数表示出来。所以我们考虑贪心按照价格从小到大插入线性基，一个香料要购买，当且仅当它不能被当前集合的数表示出来。时间复杂度 $\mathcal{O}(2^nn)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>; <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll; <span class="keyword">int</span> p[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">insert</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> ((x &gt;&gt; i) == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> (p[i] == <span class="number">0</span>) &#123;p[i] = x; <span class="keyword">break</span>;&#125;</span><br><span class="line">		x ^= p[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> !x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span> <span class="keyword">int</span> x, id; &#125;a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n; <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i].x), a[i].id = i;</span><br><span class="line">	std::<span class="built_in">sort</span>(a + <span class="number">1</span>, a + (<span class="number">1</span> &lt;&lt; n), [](<span class="keyword">const</span> node&amp; x1, <span class="keyword">const</span> node&amp; x2) &#123; <span class="keyword">return</span> x1.x &lt; x2.x; &#125;);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++)</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">insert</span>(a[i].id)) ans += a[i].x;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="G-Good-Vertices"><a href="#G-Good-Vertices" class="headerlink" title="G - Good Vertices"></a>G - Good Vertices</h3><p>给出一个 $n$ 个点的有向图，点从 $1$ 到 $n$ 编号，初始时没有边。一共 $t$ 个时刻，第 $i$ 个时刻会加入一条 $a_i\rightarrow b_i$ 的有向边，有自环无重边。一个点是好的，当且仅当它能从 $1$ 出发经过恰好 $l$ 条边到达，求出每个点第一次成为好点的时间或报告无法成为好点。($2\le n\le 100,1\le t\le n^2,1\le l\le 10^9$)</p>
<p>考虑先把所有边加入，第 $i$ 时刻加入的边权值为 $i$，则原问题即从 $1$ 到 $u$ 经过恰好 $l$ 条边，且最小化这 $l$ 条边中权值的最大值。像有向图上走一步这种严格按阶段行进的操作，可以考虑 $\rm dp$，考虑设 $f_{i,j}$ 表示 $i$ 号结点经过恰好 $j$ 条边后经过边边权最大值的最小值，则显然有转移：</p>
<script type="math/tex; mode=display">f_{i,j}=\min_{v\rightarrow i\in E}\{\max(f_{v,j-1},w_{v,i})\}</script><p>其中 $w_{v,i}$ 是边 $v\rightarrow i$ 的权值。而如果我们对于所有不存在边 $u\rightarrow v$ 的 $w_{u,v}$ 都设置为 $\infty$，上式还能进一步化为：</p>
<script type="math/tex; mode=display">f_{i,j}=\min_{v=1}^n\{\max(f_{v,j-1},w_{v,i})\}</script><p>写到这儿我们已经得到了 $\mathcal{O}(nl)$ 的做法了，但显然还不够。</p>
<p>来看看上面的式子展开是什么样的：</p>
<script type="math/tex; mode=display">f_{i,j}=\min\{\max(f_{1,j-1},w_{1,i}),\max(f_{2,j-1},w_{2,i}),\cdot\cdot\cdot,\max(f_{n,j-1},w_{n,i})\}</script><p>好像隐隐约约能看到矩阵乘法的影子？考虑把 $\min$ 换为 $+$，$\max$ 换为 $\times$，就很清楚了：</p>
<script type="math/tex; mode=display">f_{i,j}=f_{1,j-1}w_{1,i}+f_{2,j-1}w_{2,i}+\cdot\cdot\cdot+f_{n,j-1}w_{n,i}</script><p>这不就是矩阵乘法的定义了嘛。那就很简单了，构造矩阵如下：</p>
<script type="math/tex; mode=display">\mathbf{A}=\begin{bmatrix}f_{1,0}&f_{2,0}&\cdots&f_{n,0}\end{bmatrix},\mathbf{B}=\begin{bmatrix}
w_{1,1}&w_{1,2}&\cdots&w_{1,n}\\w_{2,1}&w_{2,2}&\cdots&w_{2,n}\\\vdots&\vdots&\ddots&\vdots\\ w_{n,1}&w_{n,2}&\cdots&w_{n,n}\end{bmatrix}</script><p>则有：</p>
<script type="math/tex; mode=display">\begin{bmatrix}f_{1,l}&f_{2,l}&\cdots&f_{n,l}\end{bmatrix}=\mathbf{A}(\mathbf{B}^l)</script><p>而 $f_{i,l}$ 即为最终答案。这里做矩阵乘法的时候只需要把 $+$ 再换回 $\min$，$\times$ 换回 $\max$ 就好，而既然操作都变了，单位矩阵也会变：</p>
<script type="math/tex; mode=display">\mathbf{I}=\begin{bmatrix}0&\infty&\infty&\cdots&\infty\\\infty&0&\infty&\cdots&\infty\\\infty&\infty&0&\cdots&\infty\\\vdots&\vdots&\vdots&\ddots&\vdots\\\infty&\infty&\infty&\infty&0\end{bmatrix}</script><p>其实就是主对角线是 $\max$ 的单位元，其余是 $\min$ 的单位元。直接上矩阵快速幂就好，时间复杂度 $\mathcal{O}(n^3\log l)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>, inf = <span class="number">2e9</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> a[N][N], n, m;</span><br><span class="line">	Matrix <span class="keyword">operator</span>*(<span class="keyword">const</span> Matrix&amp; A)</span><br><span class="line">	&#123;</span><br><span class="line">		Matrix ret; ret.n = n; ret.m = A.m;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= A.m; ++j)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> minx = inf;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= m; ++k) minx = std::<span class="built_in">min</span>(minx, std::<span class="built_in">max</span>(a[i][k], A.a[k][j]));</span><br><span class="line">				ret.a[i][j] = minx;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;A, B, I;</span><br><span class="line"><span class="function">Matrix <span class="title">ksm</span><span class="params">(Matrix A, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Matrix ret = I;</span><br><span class="line">	<span class="keyword">while</span> (b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * A;</span><br><span class="line">		A = A * A; b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, t, l; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;t, &amp;l);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= t; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y), B.a[x][y] = i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">		<span class="keyword">if</span> (!B.a[i][j]) B.a[i][j] = inf;</span><br><span class="line">	B.n = n; B.m = n; A.n = <span class="number">1</span>; A.m = n; I.n = n; I.m = n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) I.a[i][j] = (i == j) ? <span class="number">0</span> : inf;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) A.a[<span class="number">1</span>][i] = (i != <span class="number">1</span>) * inf;</span><br><span class="line">	B = <span class="built_in">ksm</span>(B, l); A = A * B;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, A.a[<span class="number">1</span>][i] == inf ? <span class="number">-1</span> : A.a[<span class="number">1</span>][i]);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>看到这儿，你会不会有疑惑：</p>
<blockquote>
<p>为啥这运算符说变就变啊？难道任意两个二元操作符组合都可以替换 $+$ 和 $\times$ 吗？</p>
</blockquote>
<p>会用到一点群论的知识。这里就简化说了，考虑两个二元运算 $+$ 和 $\times$（这里的符号只是代指，并不是一般意义上我们所说的加法和乘法），则一个集合 $A$ 带上这俩运算 $(A,+,\times)$ 是半群的条件是：</p>
<ul>
<li>$(A,+)$ 满足以下条件：<ul>
<li>$+$ 满足结合律，即 $\forall a,b,c\in A$，都有 $(a+b)+c=a+(b+c)$。</li>
<li>存在一个 $+$ 的的单位元 $0$，即 $\exist 0\in A$，满足 $\forall a\in A$，都有 $0+a=a+0=a$。（$0$ 并不是一般意义上的自然数 $0$，而是一个符号代表单位元，下文中 $\times$ 单位元 $1$ 也是同理）</li>
<li>$+$ 满足交换律，即 $\forall a,b\in A$，都有 $a+b=b+a$。</li>
</ul>
</li>
<li>$(A,\times)$ 满足以下条件：<ul>
<li>$\times$ 满足结合律，即 $\forall a,b,c\in A$，都有 $(a\times b)\times c=a\times(b\times c)$。</li>
<li>存在一个 $\times$ 的单位元 $1$，即 即 $\exist 0\in A$，满足 $\forall 1\in A$，都有 $1\times a=a\times 1=a$。</li>
</ul>
</li>
<li>$+,\times$ 满足以下条件：<ul>
<li>满足 $\times$ 对 $+$ 的分配律，即 $\forall a,b,c\in A$，都有 $a\times(b+c)=a\times b+a\times c$。</li>
<li>$\forall a\in A$，都有 $a\times 0=0\times a = 0$，其中 $0$ 指加法单位元。</li>
</ul>
</li>
</ul>
<p>而满足是半群的 $(A,+,\times)$ 就可以类比一般的矩阵乘法定义新的矩阵乘法，并满足一般意义上矩阵乘法优化 $\rm dp$ 所需要的所有性质。</p>
<p>举点半群的例子吧。</p>
<ul>
<li>$A=\mathbb{R}\cup\{-\infty\}$（有人可能会说：“啊你这个就有问题，$-\infty$ 都不是个数怎么能包含进数集呢？”但在这里 $-\infty$ 只是充当单位元的作用，你就当是一个极小数吧），$+$ 是 $\max$，$\times$ 是一般的加法。</li>
<li>对于一个正数 $n$，$A=\{x\in\mathbb{N}|x&lt;2^n\}$，$+$ 是按位或，$\times$ 是按位与。</li>
<li>对于一个正数 $n$，$A=\{x\in\mathbb{N}|x&lt;2^n\}$，$+$ 是按位异或，$\times$ 是按位与。</li>
</ul>
<h3 id="Ex-Distinct-Multiples"><a href="#Ex-Distinct-Multiples" class="headerlink" title="Ex - Distinct Multiples"></a>Ex - Distinct Multiples</h3><blockquote>
<p>给出两个整数 $n,m$，和一个长为 $n$ 的序列 $d$。找出满足以下条件的长为 $n$ 的序列 $a$ 个数：</p>
<ul>
<li>$\forall 1\le i\le n$，都有 $1\le a_i\le m$。</li>
<li>$\forall i\ne j$，都有 $a_i\ne a_j$。</li>
<li>$\forall 1\le i\le n$，都有 $d_i|a_i$。</li>
</ul>
<p>答案对 $998,244,353$ 取模。($2\le n\le 16,1\le d_i\le m\le 10^{18}$)</p>
</blockquote>
<p>考虑原问题并不好做，好做的问题是对于一个序列，所有数都相同，且满足都是 $d_i$ 的倍数的方案数。而从这里入手的话，我们考虑容斥。构造一个 $n$ 个点的无向图，其中边集为 $S\subseteq \{(i,j)|1\le i&lt;j\le n,i,j\in\mathbb{Z}\}$，所有连通块内的 $a_i$ 都相同。边集 $S$ 对应的方案为 $f(S)$，则最终答案即为：</p>
<script type="math/tex; mode=display">\sum_{S}f(S)(-1)^{|S|}</script><p>对于一个点集 $T$，考虑设 $g(T)$ 为：</p>
<script type="math/tex; mode=display">g(T)=\left\lfloor\dfrac{m}{\operatorname{lcm}_{i\in T}d_i}\right\rfloor</script><p>则连通块 $T$ 的填数方案数即为 $g(T)$。对于一个正整数 $n$，考虑设 $h(n)$ 表示：</p>
<script type="math/tex; mode=display">h(n)=\sum_{S\in E}[P(S,n)](-1)^{|S|},E=\{(i,j)|1\le i<j\le n,i,j\in\mathbb{Z}\}</script><p>其中 $P(S,n)$ 表示边集 $S$ 能否使 $n$ 个点的图连通。则如果把 $S$ 分成 $k$ 个连通块 $T_1,T_2,\cdots,T_k$，得到的方案数即：</p>
<script type="math/tex; mode=display">\prod_{i=1}^k g(T_i)h(|T_i|)</script><p>现在的问题基本就剩求出来这个 $h,g$ 的值了，$g$ 显然可以 $\mathcal{O}(2^n)$ 乱求，但 $h$ 就稍微有点难了。</p>
<p>题解的思路比较长，我没看懂，所以去学了 $\tt \color{black}F\color{red}roggy$ 的 GF 方法。</p>
<p>考虑去掉 $P(S,n)$ 的限制，则形成的图就变为了一般无向图，设这时的 $h(n)$ 对应的 EGF 为 $\hat{F}(x)$，设原来的 $h(n)$ 对应的 EGF 为 $\hat{G}(x)$。而我们好求的是 $\hat{F}(x)$：</p>
<script type="math/tex; mode=display">\hat{F}(x)=\sum_{n\ge 0}\sum_{i\ge 0}\dbinom{\binom{n}{2}}{i}(-1)^i\dfrac{x^n}{n!}=(1-1)^{\binom{n}{2}}\dfrac{x^n}{n!}=[n\le 1]\dfrac{x^n}{n!}=1+x</script><p>接下来由于一般无向图和连通无向图对应 EGF 的联系，我们有：</p>
<script type="math/tex; mode=display">\mathrm{exp}\ \hat{G}(x)=\hat{F}(x)=1+x</script><p>所以有：</p>
<script type="math/tex; mode=display">\hat{G}(x)=\ln(1+x)</script><p>这样，我们 $h(n)$ 的通项就出来了：</p>
<script type="math/tex; mode=display">h(n)=[x^n]\ln(1+x)=(-1)^{n-1}(n-1)!</script><p>更多资料可以参考：<a target="_blank" rel="noopener" href="https://ctp314.github.io/2022/01/24/%E5%85%B3%E4%BA%8E%E4%B8%80%E7%B1%BB%E5%AE%B9%E6%96%A5%E7%9A%84%E6%80%9D%E8%80%83/">卢神的博客</a>。</p>
<p>好，现在我们求完了 $h(n),g(T)$ 现在就是要把它们组合起来了。延续上面的思路，我们设 $f_{T}$ 表示把点集 $T$ 中的点分成</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhiyangfan1234.github.io/2022/01/24/AtCoder%20Beginner%20Contest%20232/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhiyangfan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhiyangfan 的博客小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/24/AtCoder%20Beginner%20Contest%20232/" class="post-title-link" itemprop="url">AtCoder Beginner Contest 232</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-01-24 17:00:23 / 修改时间：17:10:47" itemprop="dateCreated datePublished" datetime="2022-01-24T17:00:23+08:00">2022-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="AtCoder-Beginner-Contest-232"><a href="#AtCoder-Beginner-Contest-232" class="headerlink" title="AtCoder Beginner Contest 232"></a>AtCoder Beginner Contest 232</h2><p>F 想到状压没写完转移是这样的。</p>
<h3 id="A-QQ-solver"><a href="#A-QQ-solver" class="headerlink" title="A - QQ solver"></a>A - QQ solver</h3><p>给出一个长为 $3$ 的字符串 $S$，其中 $S_1,S_3$ 为 <code>0-9</code> 的字符之一，$S_2$ 为 <code>x</code>。求出该乘法算式的值。</p>
<p>腾 讯 解 决 者。直接模拟就好了，没什么可说的，时间复杂度 $\mathcal{O}(1)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (s[<span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>) * (s[<span class="number">3</span>] - <span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>ps. 这题还可以这样：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b; <span class="built_in">scanf</span>(<span class="string">&quot;%dx%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a * b); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="B-Caesar-Cipher"><a href="#B-Caesar-Cipher" class="headerlink" title="B - Caesar Cipher"></a>B - Caesar Cipher</h3><p>我们对于一个字符串 $S$ 定义如下操作：</p>
<ul>
<li>选择一个非负整数 $k$，并把 $S$ 的所有字符在模意义下加上 $k$。</li>
</ul>
<p>给出 $S,T$，求 $S$ 能否通过恰好一次操作变为 $T$。($1\le |S|=|T|\le 10^5$) </p>
<p>因为只有一次操作，所以如果可行的话，$\forall 1\le i\le |S|$，$(T_i-S_i)\bmod{26}$ 都应该相等，直接判就好。时间复杂度 $\mathcal{O}(|S|)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>; <span class="keyword">char</span> s[N], t[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, s + <span class="number">1</span>, t + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> n = (<span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> d = (t[<span class="number">1</span>] - s[<span class="number">1</span>] + <span class="number">26</span>) % <span class="number">26</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (d != (t[i] - s[i] + <span class="number">26</span>) % <span class="number">26</span>) &#123; <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="C-Graph-Isomorphism"><a href="#C-Graph-Isomorphism" class="headerlink" title="C - Graph Isomorphism"></a>C - Graph Isomorphism</h3><p>给出两张 $n$ 个结点 $m$ 条边的图，问在不考虑结点编号的情况下两张图是否相同，即问两张图是否同构。($1\le n\le 8,0\le m\le \frac{n(n-1)}{2}$)</p>
<p>$n$ 非常小，所以我们可以直接按照题目中给出的图的同构定义模拟：</p>
<blockquote>
<p>两张图 $G=(V,E),G’=(V’,E’)$ 同构，当且仅当 $|V|=|V’|,|E|=|E’|$，且满足 $\exist \mathcal{P}$ 为 $1\sim |V|$ 的一个排列，有 $(i,j)\in E$，当且仅当 $(\mathcal{P}_i,\mathcal{P}_j)\in E’$。</p>
</blockquote>
<p>直接以 $\mathcal{O}(n!)$ 时间复杂度暴力枚举全排列即可。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> p[<span class="number">10</span>], a[<span class="number">200</span>], b[<span class="number">200</span>], c[<span class="number">200</span>], d[<span class="number">200</span>];</span><br><span class="line"><span class="keyword">int</span> E[<span class="number">10</span>][<span class="number">10</span>], G[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a[i], &amp;b[i]), E[a[i]][b[i]] = E[b[i]][a[i]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;c[i], &amp;d[i]), G[c[i]][d[i]] = G[d[i]][c[i]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) p[i] = i;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n &amp;&amp; flag; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n &amp;&amp; flag; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == j) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> ((!E[i][j] &amp;&amp; G[p[i]][p[j]]) || (!G[p[i]][p[j]] &amp;&amp; E[i][j])) flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123; <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (std::<span class="built_in">next_permutation</span>(p + <span class="number">1</span>, p + n + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="D-Weak-Takahashi"><a href="#D-Weak-Takahashi" class="headerlink" title="D - Weak Takahashi"></a>D - Weak Takahashi</h3><p>给出一张 $h\times w$ 的网格，其中一些格子有障碍。求出从 $(1,1)$ 出发只向下走或向右走最多能到达多少格子。($1\le h,w\le 100$，$(1,1)$ 没有障碍)</p>
<p>显然的暴力是指数级别枚举每次走的方向，而又注意到其实在每个相同的地方能走到的格子个数是一样的，所以考虑记忆化搜索。这样每个格子最多到达一次，时间复杂度降低至 $\mathcal{O}(hw)$，足以通过本题。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> mp[<span class="number">200</span>][<span class="number">200</span>]; <span class="keyword">int</span> f[<span class="number">200</span>][<span class="number">200</span>], ans, n, m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> nxt[<span class="number">2</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f[x][y] != <span class="number">-1</span>) <span class="keyword">return</span> f[x][y];</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tx = x + nxt[i][<span class="number">0</span>], ty = y + nxt[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (mp[tx][ty] == <span class="string">&#x27;#&#x27;</span> || tx &lt; <span class="number">1</span> || ty &lt; <span class="number">1</span> || tx &gt; n || ty &gt; m) <span class="keyword">continue</span>;</span><br><span class="line">        ret = std::<span class="built_in">max</span>(<span class="built_in">dfs</span>(tx, ty), ret);</span><br><span class="line">    &#125;</span><br><span class="line">    f[x][y] = ++ret; ans = std::<span class="built_in">max</span>(ans, f[x][y]);</span><br><span class="line">    <span class="keyword">return</span> f[x][y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span> (f));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, mp[i] + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">1</span>)); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="E-Rook-Path"><a href="#E-Rook-Path" class="headerlink" title="E - Rook Path"></a>E - Rook Path</h3><p>有一个 $h\times w$ 的棋盘，在 $(x_1,y_1)$ 处有一个车。车的移动规则是能到达任意一个和它同列或同行的格子，但不能留在原地，问移动恰好 $k$ 次最终到达 $(x_2,y_2)$ 的方案数有多少种，答案对 $998,244,353$ 取模。($2\le h,w\le 10^9,1\le k\le 10^6$)</p>
<p>计数问题可以直接往 $\rm dp$ 方向或者推式子方向想，显然这玩意不能直接在棋盘上 $\rm dp$，且因为车的移动比较复杂，所以如果推式子也会非常复杂。所以我们要考虑巧妙设计一下 $\rm dp$ 状态。注意到车每次移动会且仅会改变行或列的其中一个，所以关键在于车的行是否为 $x_2$，列是否为 $y_2$。这样我们就可以设 $f_{i,0/1,0/1}$ 表示 $i$ 次移动后，车在不在 $x_2$ 行，在不在 $y_2$ 列的方案数。边界条件是 $f_{0,[x_1=x_2],[y_1=y_2]}=1$。转移就比较显然了：</p>
<ul>
<li>$f_{i,0,0}$：<ul>
<li>$f_{i,0,0}\leftarrow f_{i-1,0,0}$，这个表示原来都不在现在还是都不在，转移方案数是不能留在原地和到达 $x_2,y_2$，即 $h+w-4$。</li>
<li>$f_{i,0,0}\leftarrow f_{i-1,1,0}$，这个表示原来在 $x_2$ 这次跑走了，转移方案数是不能留在原地（不考虑到达 $y_2$，因为只能动行），即 $h-1$。</li>
<li>$f_{i,0,0}\leftarrow f_{i-1,0,1}$，这个表示原来在 $x_2$ 这次跑走了，转移方案类似上一种，即 $w-1$。</li>
</ul>
</li>
<li>$f_{i,0,1}$：<ul>
<li>$f_{i,0,1}\leftarrow f_{i,0,0}$，这个表示原来不在 $y_2$ 现在跑到 $y_2$ 了，只有 $1$ 种方案。</li>
<li>$f_{i,0,1}\leftarrow f_{i,0,1}$，这个表示原来不在 $x_2$ 现在还是不在，且不能动列，方案数是不能留在原地和到达 $x_2$，即 $h-2$。</li>
<li>$f_{i,0,1}\leftarrow f_{i,1,1}$，这个表示原来在 $x_2$ 现在走了，方案数是不能留在原地，即 $h-1$。</li>
</ul>
</li>
<li>$f_{i,1,0}$<ul>
<li>$f_{i,1,0}\leftarrow f_{i,0,0}$，类似 $f_{i,0,1}$ 的转移，方案数只有 $1$ 种。</li>
<li>$f_{i,1,0}\leftarrow f_{i,1,0}$，类似 $f_{i,0,1}$ 的转移，方案数是 $w-2$。</li>
<li>$f_{i,1,0}\leftarrow f_{i,1,1}$，类似 $f_{i,0,1}$ 的转移，方案数是 $w-1$.</li>
</ul>
</li>
<li>$f_{i,1,1}$：<ul>
<li>$f_{i,1,1}\leftarrow f_{i,1,0}$，这个表示原来不在 $y_2$ 现在走到了，方案数只有 $1$ 种。</li>
<li>$f_{i,1,1}\leftarrow f_{i,0,1}$，这个表示原来不在 $x_2$ 现在走到了，方案数只有 $1$ 种。</li>
</ul>
</li>
</ul>
<p>有了转移，就可以递推了，最终答案即为 $f_{k,1,1}$。时间复杂度 $\mathcal{O}(k)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>, mod = <span class="number">998244353</span>; <span class="keyword">int</span> f[N][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h, w, k; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;h, &amp;w, &amp;k);</span><br><span class="line">    <span class="keyword">int</span> x1, x2, y1, y2; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">    f[<span class="number">0</span>][x1 == x2][y1 == y2] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i][<span class="number">0</span>][<span class="number">0</span>] = (<span class="number">1ll</span> * f[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] * (h + w - <span class="number">4</span>) + <span class="number">1ll</span> * f[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>] * (w - <span class="number">1</span>) + <span class="number">1ll</span> * f[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>] * (h - <span class="number">1</span>)) % mod;</span><br><span class="line">        f[i][<span class="number">0</span>][<span class="number">1</span>] = (<span class="number">1ll</span> * f[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] + <span class="number">1ll</span> * f[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>] * (h - <span class="number">2</span>) + <span class="number">1ll</span> * f[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] * (h - <span class="number">1</span>)) % mod;</span><br><span class="line">        f[i][<span class="number">1</span>][<span class="number">0</span>] = (<span class="number">1ll</span> * f[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] + <span class="number">1ll</span> * f[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>] * (w - <span class="number">2</span>) + <span class="number">1ll</span> * f[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] * (w - <span class="number">1</span>)) % mod;</span><br><span class="line">        f[i][<span class="number">1</span>][<span class="number">1</span>] = (f[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>] + f[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>]) % mod; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[k][<span class="number">1</span>][<span class="number">1</span>]); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="F-Simple-Operations-on-Sequence"><a href="#F-Simple-Operations-on-Sequence" class="headerlink" title="F - Simple Operations on Sequence"></a>F - Simple Operations on Sequence</h3><p>有一个长为 $n$ 的序列 $a$，可以进行以下两种操作：</p>
<ul>
<li>选择一个满足 $1\le i\le n$ 的 $i$，并把 $a_i$ 加上 $1$，代价为 $x$。</li>
<li>选择一个满足 $1\le i&lt;n$ 的 $i$，并交换 $a_i,a_{i+1}$，代价为 $y$。</li>
</ul>
<p>给出一个长为 $n$ 的序列 $b$，求通过以上两种操作使 $a,b$ 相等的最小代价。($2\le n\le 18,1\le x\le 10^8,1\le y\le10^{16},1\le a_i,b_i\le10^8$)</p>
<p>注意到其实一次交换是改变了 $a,b$ 数组之间下标的对应关系，而一次加 $1$ 其实是尝试把当前匹配上的 $a,b$ 变的相等。再结合 $n$ 很小的条件，我们可以考虑状压 $\rm dp$。考虑设 $f_{S}$ 表示当前考虑过的 $a$ 与 $b$ 的匹配情况。具体来讲，$S_i=1$ 当且仅当 $a_i$ 有匹配上的 $b_j$。那转移思路就比较显然了，就是每次新增加一个 $a_i$ 的匹配，给它分配当前匹配到的 $b_j$，并计算它俩匹配需要的交换次数和加和次数。具体来讲，转移式子如下：</p>
<script type="math/tex; mode=display">f_{S\operatorname{or}2^i}=\min_{0\le i<n,S\operatorname{and}2^i=0}\{f_S+x|a_{i+1}-b_{cnt+1}|+y\mathbf{g}(S,i)\}</script><p>我们转移的思路是顺次匹配 $b_i$，每次选择一个 $a_i$ 和它匹配。其中我们定义 $cnt$ 为 $S$ 中 $1$ 的个数，定义 $\mathbf{g}(S,x)$ 为满足 $S\operatorname{and}2^i=0,i<x$ 的 $i$ 个数。这个就是如果想让 $a_{i+1},b_{cnt+1}$ 匹配上需要的交换次数。最终答案即为 $f_{2^n-1}$，边界为 $f_{0}=0$。时间复杂度 $\mathcal{O}(n2^n)$。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>; <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll a[N], b[N], f[<span class="number">1</span> &lt;&lt; N], x, y; <span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">if</span> ((S &amp; (<span class="number">1</span> &lt;&lt; i)) == <span class="number">0</span> &amp;&amp; i &lt; x) ++ret;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld%lld&quot;</span>, &amp;n, &amp;x, &amp;y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;b[i]);</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span> (f)); f[<span class="number">0</span>] = <span class="number">0</span>; <span class="keyword">int</span> all = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> S = <span class="number">0</span>; S &lt;= all; ++S)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (S &amp; (<span class="number">1</span> &lt;&lt; i)) ++cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (S &amp; (<span class="number">1</span> &lt;&lt; i)) <span class="keyword">continue</span>;</span><br><span class="line">            f[S | (<span class="number">1</span> &lt;&lt; i)] = std::<span class="built_in">min</span>(f[S | (<span class="number">1</span> &lt;&lt; i)], f[S] + x * std::<span class="built_in">abs</span>(a[i + <span class="number">1</span>] - b[cnt + <span class="number">1</span>]) + y * <span class="built_in">calc</span>(S, i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, f[all]); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="G-Modulo-Shortest-Path"><a href="#G-Modulo-Shortest-Path" class="headerlink" title="G - Modulo Shortest Path"></a>G - Modulo Shortest Path</h3><p>给出一个有 $n$ 个结点的图，结点 $i$ 到结点 $j$ 有一条权值为 $(a_i+b_j)\bmod{m}$ 的有向边，求 $1$ 到 $n$ 的最短路。($2\le n\le 2\times10^5,2\le m\le 10^9$)</p>
<p>显然直接建图是不可能的，面对这种边很多的题我们一般的思路都是去掉一些没用的边，使边的级别到达合理的程度。但这道题原图并没有什么可以比较好的减边思路，所以我们考虑转化一下原图。注意到权值是在模 $m$ 意义下的，所以我们考虑建立一个模 $m$ 的剩余系构成的圈，并在这上面连一些边来达到相同的效果。</p>
<p>具体来讲，我们在原题的点集上新增一个点集 $\mathcal{A}=(\overline{0},\overline{1},\overline{2},\cdot\cdot\cdot,\overline{m-1})$ 用来构造边对应的值，其中为了和原来的点区分，我们在新加入的点上面标上横线。所以有 $\overline{i}\rightarrow\overline{(i+1)\bmod{m}}$ 权值为 $1$ 的边。这样会构成一个圈，以下是 $m=8$ 的情况：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/4fdbao2l.png" alt=""></p>
<p>然后对于原来的点，其中一种可能的构造方式是：</p>
<ul>
<li>对于所有的 $1\le i\le n$，有 $i\rightarrow\overline{(-a_i)\bmod{m}}$ 权值为 $0$ 的边。</li>
<li>对于所有的 $1\le i\le n$，有 $\overline{b_i}\rightarrow i$ 权值为 $0$ 的边。</li>
</ul>
<p>这样从 $i$ 到 $j$ 就是从 $\overline{(-a_i)\bmod{m}}$ 走到 $\overline{b_j}$，距离即为 $(a_i+b_j)\bmod{m}$。比如对于图 $G,a=(1,2,3,4),b=(2,3,4,5),m=8$，对应的新图为：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/gxzsg72z.png" alt=""></p>
<p>其中为了表示区分，原图的点我标记为 $\tt(a,b,c,d)$。可以自己试试，这个确实是成立的。</p>
<p>但这还不够，边的级别仍然是 $\mathcal{O}(n+m)$ 这样一个很大的级别。不过我们注意到，其实有很多边可以合并（比如上图中的 $5\rightarrow 6,6\rightarrow 7$ 其实就可以合并为一个权值为 $2$ 的边）那如果我们把能合并的边都合并了，则其实原图的边数就仅有 $\mathcal{O}(n)$ 级别了。因为外层圈仅有 $n$ 个点是关键点，其余的点都会被压缩，得到的边也就只有 $n$ 个。具体实现见代码，总之跑 $\rm Dijkstra$ 最短路的时间复杂度是 $\mathcal{O}(n\log n)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>; <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll; std::map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; id;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span> <span class="keyword">int</span> v, next, w; &#125;E[N &lt;&lt; <span class="number">3</span>]; <span class="keyword">int</span> p[N &lt;&lt; <span class="number">3</span>], cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(p, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span> (p)); cnt = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123; E[cnt].w = w; E[cnt].v = v; E[cnt].next = p[u]; p[u] = cnt++; &#125;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N], st[N], vis[N], tn, tp; ll dis[N]; std::priority_queue&lt;std::pair&lt;ll, <span class="keyword">int</span>&gt; &gt; pq;</span><br><span class="line"><span class="function">ll <span class="title">Dij</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span> (dis)); dis[s] = <span class="number">0</span>;</span><br><span class="line">    pq.<span class="built_in">emplace</span>(-dis[s], s);</span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> r = pq.<span class="built_in">top</span>(); pq.<span class="built_in">pop</span>(); <span class="keyword">int</span> u = r.second;</span><br><span class="line">        <span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>; vis[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = p[u], v; i + <span class="number">1</span>; i = E[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            v = E[i].v; </span><br><span class="line">            <span class="keyword">if</span> (dis[v] &gt; dis[u] + E[i].w) </span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = dis[u] + E[i].w;</span><br><span class="line">                pq.<span class="built_in">emplace</span>(-dis[v], v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>(); <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m); tn = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        <span class="keyword">if</span> (!id[m - a[i]]) id[m - a[i]] = ++tn, st[++tp] = m - a[i];</span><br><span class="line">        <span class="built_in">insert</span>(i, id[m - a[i]], <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[i]);</span><br><span class="line">        <span class="keyword">if</span> (!id[b[i]]) id[b[i]] = ++tn, st[++tp] = b[i];</span><br><span class="line">        <span class="built_in">insert</span>(id[b[i]], i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">sort</span>(st + <span class="number">1</span>, st + tp + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; tp; ++i) <span class="built_in">insert</span>(id[st[i]], id[st[i + <span class="number">1</span>]], (st[i + <span class="number">1</span>] - st[i]) % m);</span><br><span class="line">    <span class="built_in">insert</span>(id[st[tp]], id[st[<span class="number">1</span>]], (m + st[<span class="number">1</span>] - st[tp]) % m);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">Dij</span>(<span class="number">1</span>, n)); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="H-King’s-Tour"><a href="#H-King’s-Tour" class="headerlink" title="H - King’s Tour"></a>H - King’s Tour</h3><p>有一块 $h\times w$ 的棋盘，在 $(1,1)$ 处有一个王。王的移动规则是可以横，竖或斜着走，但一次只能走一格。构造出王在到达每个格子恰好一次后停留在 $(a,b)$ 的方案。($2\le h,w\le 100$)</p>
<p>最水的 H 题了，真应该跟 F 题换换。本题图片来自 AT 题解。首先考虑平凡情况，当 $h=2$ 时，我们可以通过如下的方式移动：</p>
<p><img src="https://img.atcoder.jp/ghi/45d400563f38eb01ffea2e66239b9664.png" alt=""></p>
<p>具体来讲，我们构造如下的序列：</p>
<ul>
<li>$(1,1)\rightarrow(2,1)\rightarrow(1,2)\rightarrow(2,2)\rightarrow(1,3)\rightarrow(2,3)\rightarrow\cdot\cdot\cdot\rightarrow(1,b-1)\rightarrow(2,b-1)\rightarrow(3-a,b)\rightarrow$</li>
<li>$(1,b+1)\rightarrow(1,b+2)\rightarrow\cdot\cdot\cdot\rightarrow(1,w)\rightarrow(2,w)\rightarrow(2,w-1)\cdot\cdot\cdot\rightarrow(2,b+1)\rightarrow(a,b)$</li>
</ul>
<p>然后是另一种平凡情况。当 $w=2$ 时，我们可以通过交换行和列来把它变成 $h=2$ 的情况。</p>
<p>最后是一般情况。当 $h&gt;2,w&gt;2$ 时，我们考虑通过走这个 $S$ 区域来达到缩小棋盘的目的：</p>
<p><img src="https://img.atcoder.jp/ghi/6a11b9fe7eebca4ddd44a12826580c99.png" alt=""></p>
<p>如果 $(a,b)$ 不在 $S$ 区域内，我们就可以走完 $S$，这样问题就变为了行颠倒一下，列数减少 $1$ 的子问题。</p>
<p>如果 $(a,b)$ 在 $S$ 区域内，简单通过交换行和列就可以让 $(a,b)$ 不在 $S$ 区域内了。</p>
<p>这样我们就把原问题变为了两个平凡情况和两个可以变为子问题的情况。每次缩小规模会缩小一行或一列（取决于当前交换了一次行和列的意义），所以总共递归的次数级别为 $\mathcal{O}(h+w)$。因为最终答案是 $\mathcal{O}(hw)$ 级别的，所以时间复杂度为 $\mathcal{O}(hw)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="function">std::vector&lt;pii&gt; <span class="title">solve</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> w, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;pii&gt; ret;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= b - <span class="number">1</span>; ++i)</span><br><span class="line">            ret.<span class="built_in">emplace_back</span>(<span class="number">1</span>, i), ret.<span class="built_in">emplace_back</span>(<span class="number">2</span>, i);</span><br><span class="line">        ret.<span class="built_in">emplace_back</span>(<span class="number">3</span> - a, b);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = b + <span class="number">1</span>; i &lt;= w; ++i) ret.<span class="built_in">emplace_back</span>(<span class="number">1</span>, i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &gt; b; --i) ret.<span class="built_in">emplace_back</span>(<span class="number">2</span>, i);</span><br><span class="line">        ret.<span class="built_in">emplace_back</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((h &gt; <span class="number">2</span> &amp;&amp; w == <span class="number">2</span>) || (b == <span class="number">1</span>) || (a == h &amp;&amp; b == <span class="number">2</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        ret = <span class="built_in">solve</span>(w, h, b, a);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : ret) std::<span class="built_in">swap</span>(p.first, p.second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= h; ++i) ret.<span class="built_in">emplace_back</span>(i, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">auto</span> t = <span class="built_in">solve</span>(h, w - <span class="number">1</span>, h + <span class="number">1</span> - a, b - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : t) </span><br><span class="line">        &#123;</span><br><span class="line">            ++p.second; p.first = h + <span class="number">1</span> - p.first;</span><br><span class="line">            ret.<span class="built_in">push_back</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h, w, a, b; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;h, &amp;w, &amp;a, &amp;b);</span><br><span class="line">    <span class="keyword">auto</span> ans = <span class="built_in">solve</span>(h, w, a, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : ans) <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, p.first, p.second);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhiyangfan1234.github.io/2022/01/24/AtCoder%20Beginner%20Contest%20227%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhiyangfan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhiyangfan 的博客小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/24/AtCoder%20Beginner%20Contest%20227%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">AtCoder Beginner Contest 227</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-01-24 17:00:23 / 修改时间：17:10:42" itemprop="dateCreated datePublished" datetime="2022-01-24T17:00:23+08:00">2022-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="AtCoder-Beginner-Contest-227"><a href="#AtCoder-Beginner-Contest-227" class="headerlink" title="AtCoder Beginner Contest 227"></a>AtCoder Beginner Contest 227</h2><p>这把广告场的 H 题码量真的阴间，我写了 $\rm 4KB$ 左右。因为我没广告费，所以比赛标题不打全（</p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="A-Last-Card"><a href="#A-Last-Card" class="headerlink" title="A - Last Card"></a>A - Last Card</h4><p>想把 $k$ 张卡片分给 $n$ 个人，人从 $1\sim n$ 编号。现在从编号为 $a$ 的人开始发卡片，在 $x(1\le x&lt;n)$ 拿到卡片后，下一个会发给 $x+1$，特别地，在 $n$ 拿到卡片后，下一个会发给 $1$。问拿到最后一张卡片的人编号。($1\le n,k\le1000,1\le a\le n$)</p>
<p>非常签到的一道题。可以直接 $\mathcal{O}(k)$ 朴素枚举，当然也可以利用取模相关知识 $\mathcal{O}(1)$ 得出：</p>
<script type="math/tex; mode=display">ans=\begin{cases}n&(a+k-1\equiv0\pmod{n})\\(a+k-1)\bmod{n}&\tt otherwise\end{cases}</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, k, a; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;k, &amp;a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (a + k - <span class="number">1</span>) % n == <span class="number">0</span> ? n : (a + k - <span class="number">1</span>) % n);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="B-KEYENCE-building"><a href="#B-KEYENCE-building" class="headerlink" title="B - KEYENCE building"></a>B - KEYENCE building</h4><p>给出长为 $n$ 的序列 $S$，问其中有多少个 $S_i$ 不能被表示为 $4ab+3a+3b(a,b\in \mathbb{N}_+)$ 的形式。($1\le n\le20,1\le S_i\le1000$)</p>
<p>依然是签到题。对于 $S_i$ 直接枚举所有可能的 $a,b$ 判断即可，时间复杂度 $\mathcal{O}(nS_i^2)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> s[<span class="number">30</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">1</span>; a &lt;= <span class="number">1000</span>; ++a)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">1</span>; b &lt;= <span class="number">1000</span>; ++b)</span><br><span class="line">			<span class="keyword">if</span> (<span class="number">4</span> * a * b + <span class="number">3</span> * a + <span class="number">3</span> * b == S) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, ans = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[i]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">check</span>(s[i])) ++ans;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="C-ABC-conjecture"><a href="#C-ABC-conjecture" class="headerlink" title="C - ABC conjecture"></a>C - ABC conjecture</h4><p>给出一个正整数 $n$，求满足 $a\le b\le c,abc\le n$ 的三元组 $(a,b,c)$ 的数量。($1\le n\le10^{11}$)</p>
<p>稍微复杂一点的签到题。直接枚举 $a,b$ 然后求出对应的 $c$ 的个数（令 $k=\left\lfloor\dfrac{n}{ab}\right\rfloor$，则 $c$ 的个数为 $\max(0,k-b+1)$）。虽然这个做法很简单，但是时间复杂度不是很好分析，原题解一通分析得出复杂度为 $\mathcal{O}(n^{\frac{2}{3}})$，因为涉及到的数学知识比较复杂这里不再深究，总之写完拿极限数据试一下就大概明白复杂度行不行了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll n, ans = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (ll a = <span class="number">1</span>; a * a &lt;= n; ++a)</span><br><span class="line">		<span class="keyword">for</span> (ll b = a; a * b &lt;= n; ++b)</span><br><span class="line">		&#123;</span><br><span class="line">			ll c = n / a / b; <span class="keyword">if</span> (c &lt; b) <span class="keyword">break</span>;</span><br><span class="line">			ans += c - b + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="D-Project-Planning"><a href="#D-Project-Planning" class="headerlink" title="D - Project Planning"></a>D - Project Planning</h4><p>给出一个长为 $n$ 的序列 $a$ 和一个正整数 $k$。我们定义一轮操作为从 $a$ 中选恰好 $k$ 个非 $0$ 数，把它们全部 $-1$。问最多能进行多少轮操作。($1\le k\le n\le2\times10^5,1\le a_i\le10^{12}$)</p>
<p>开始难起来了。如果你像我一样一直想找到一个最优策略，就会罚坐很久。注意到答案具有单调性，所以我们考虑用二分把题目转化为一个判断性问题，即对于当前二分到的值 $p$，询问能否进行 $p$ 轮。我们令 $sum=\sum_{i=1}^n\min(a_i,p)$，则当 $p\times k&gt;sum$ 时，显然不可能进行 $p$ 轮，因为连最优情况全部都能取完都不满足。而当 $p\times k\le sum$ 时，我们能证明，一定能进行 $p$ 轮。当 $p\times k\le sum$ 时，如果有至少 $k$ 个 $a_i$ 满足 $a_i\ge p$，显然能进行 $p$ 轮，如果没有，我们可以选择最大的 $k$ 个数操作一轮，这会把 $sum$ 减掉最多 $k$，这样一直进行下去，也能进行 $p$ 轮。直接二分查找即可，时间复杂度 $\mathcal{O}(n\log w)$，其中 $w=\dfrac{\sum a_i}{k}$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>; <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll; ll a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">    ll l = <span class="number">1</span>, r = <span class="number">3e17</span> / k, mid, sum, ans;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>; sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) sum += std::<span class="built_in">min</span>(mid, a[i]);</span><br><span class="line">        <span class="keyword">if</span> (mid * k &gt; sum) r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> ans = mid, l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="E-Swap"><a href="#E-Swap" class="headerlink" title="E - Swap"></a>E - Swap</h4><p>给出一个仅含有 <code>K</code>，<code>E</code>，<code>Y</code> 三个字符组成的字符串 $S$，问在交换至多 $k$ 次后能得到的不同字符串个数（本题中的交换指交换相邻字符）。($1\le|S|\le30,0\le k\le10^9$)</p>
<p>考虑这样一个问题，给定字符串 $S$ 和 $T$，问至少需要多少次交换才能使 $S,T$ 相同。这个问题很简单，我们可以通过贪心交换使每一位都相同来做。现在来看原题，受上述做法的启发我们可以在 $S$ 上一位一位确定。</p>
<p>考虑设 $f_{i,x,e,y}$ 表示 $S$ 前 $i$ 个字符中有 $e$ 个 <code>E</code>，$y$ 个 <code>Y</code>，通过 $x$ 次交换能得到的字符串个数。转移的时候我们尝试在第 $i$ 位放上 <code>K</code>，<code>E</code> 或 <code>Y</code>，并通过上述贪心算出需要的操作次数，就可以转移了。通过一些预处理可以达到最终 $\mathcal{O}(|S|^5)$ 的时间复杂度。注意转移的时候 $x$ 上界没必要到 $k$，到 $n^2$ 就足够了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">40</span>, B = <span class="number">1e3</span>; <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll; ll dp[N][B + <span class="number">10</span>][N][N]; </span><br><span class="line"><span class="keyword">char</span> s[N]; <span class="keyword">int</span> n, K[N], E[N], Y[N], Ki[N], Ei[N], Yi[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> kk; <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, s + <span class="number">1</span>, &amp;kk); n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        K[i] = K[i - <span class="number">1</span>] + (s[i] == <span class="string">&#x27;K&#x27;</span>);</span><br><span class="line">        E[i] = E[i - <span class="number">1</span>] + (s[i] == <span class="string">&#x27;E&#x27;</span>);</span><br><span class="line">        Y[i] = Y[i - <span class="number">1</span>] + (s[i] == <span class="string">&#x27;Y&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;K&#x27;</span>) Ki[K[i]] = i;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;E&#x27;</span>) Ei[E[i]] = i;</span><br><span class="line">        <span class="keyword">else</span> Yi[Y[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> e = <span class="number">0</span>; e &lt; i; ++e)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; e + y &lt; i; ++y)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> k = i - e - y - <span class="number">1</span>; </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; B; ++x)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!dp[i - <span class="number">1</span>][x][e][y]) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (Ki[k + <span class="number">1</span>])</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">int</span> pos = Ki[k + <span class="number">1</span>], add = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">if</span> (E[pos] &gt; e) add += E[pos] - e;</span><br><span class="line">                        <span class="keyword">if</span> (Y[pos] &gt; y) add += Y[pos] - y;</span><br><span class="line">                        dp[i][x + add][e][y] += dp[i - <span class="number">1</span>][x][e][y]; </span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (Ei[e + <span class="number">1</span>])</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">int</span> pos = Ei[e + <span class="number">1</span>], add = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">if</span> (K[pos] &gt; k) add += K[pos] - k;</span><br><span class="line">                        <span class="keyword">if</span> (Y[pos] &gt; y) add += Y[pos] - y;</span><br><span class="line">                        dp[i][x + add][e + <span class="number">1</span>][y] += dp[i - <span class="number">1</span>][x][e][y]; </span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (Yi[y + <span class="number">1</span>])</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">int</span> pos = Yi[y + <span class="number">1</span>], add = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">if</span> (K[pos] &gt; k) add += K[pos] - k;</span><br><span class="line">                        <span class="keyword">if</span> (E[pos] &gt; e) add += E[pos] - e;</span><br><span class="line">                        dp[i][x + add][e][y + <span class="number">1</span>] += dp[i - <span class="number">1</span>][x][e][y];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e = <span class="number">0</span>; e &lt;= n; ++e)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; e + y &lt;= n; ++y)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt;= B &amp;&amp; x &lt;= kk; ++x) ans += dp[n][x][e][y];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="F-Treasure-Hunting"><a href="#F-Treasure-Hunting" class="headerlink" title="F - Treasure Hunting"></a>F - Treasure Hunting</h4><p>给出一个 $n\times m$ 的网格 $a$，每一个的权值为 $a_{i,j}$。现在从 $(1,1)$ 出发，只能往下或往右走到 $(n,m)$。这样一条路径的权值为经过的 $n+m-1$ 个格子中权值前 $k$ 大的格子的权值之和。求出所有可能的路径中权值最小为多少。($1\le n,m\le30,1\le k\le n+m,1\le a_{i,j}\le10^9$)</p>
<p>$n,m$ 都比较小，我们考虑枚举一下路径上第 $k$ 大的权值到底是多少。固定下来这个值 $x$ 之后，就可以进行 $\rm dp$ 了。考虑设 $f_{i,j,k}$ 表示当前路径到 $(j,k)$ 了，路径上的权值有 $i$ 个大于等于 $x$。转移比较显然，但注意一个细节，当 $a_{j,k}=x$ 时，既可以算到那 $i$ 个数里面，也可以不算。总之可以 $\mathcal{O}(nmk)$ 转移，算上枚举 $x$ 的复杂度，最近时间复杂度 $\mathcal{O}(n^2m^2k)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">40</span>; <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll dp[N &lt;&lt; <span class="number">1</span>][N][N], ans = <span class="number">1e18</span>; <span class="keyword">int</span> mp[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, k; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;mp[i][j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n; ++i) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        x = mp[i][j]; <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span> (dp));</span><br><span class="line">        <span class="keyword">if</span> (mp[<span class="number">1</span>][<span class="number">1</span>] &gt;= x) dp[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] = mp[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (mp[<span class="number">1</span>][<span class="number">1</span>] &lt;= x) dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt;= k; ++a) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">1</span>; b &lt;= n; ++b) <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">1</span>; c &lt;= m; ++c)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (b != n)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (a != k &amp;&amp; mp[b + <span class="number">1</span>][c] &gt;= x) </span><br><span class="line">                        dp[a + <span class="number">1</span>][b + <span class="number">1</span>][c] = std::<span class="built_in">min</span>(dp[a + <span class="number">1</span>][b + <span class="number">1</span>][c], dp[a][b][c] + mp[b + <span class="number">1</span>][c]);</span><br><span class="line">                    <span class="keyword">if</span> (mp[b + <span class="number">1</span>][c] &lt;= x)</span><br><span class="line">                        dp[a][b + <span class="number">1</span>][c] = std::<span class="built_in">min</span>(dp[a][b + <span class="number">1</span>][c], dp[a][b][c]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (c != m)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (a != k &amp;&amp; mp[b][c + <span class="number">1</span>] &gt;= x)</span><br><span class="line">                        dp[a + <span class="number">1</span>][b][c + <span class="number">1</span>] = std::<span class="built_in">min</span>(dp[a + <span class="number">1</span>][b][c + <span class="number">1</span>], dp[a][b][c] + mp[b][c + <span class="number">1</span>]);</span><br><span class="line">                    <span class="keyword">if</span> (mp[b][c + <span class="number">1</span>] &lt;= x)</span><br><span class="line">                        dp[a][b][c + <span class="number">1</span>] = std::<span class="built_in">min</span>(dp[a][b][c + <span class="number">1</span>], dp[a][b][c]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ans = std::<span class="built_in">min</span>(ans, dp[k][n][m]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="G-Divisors-of-Binomial-Coefficient"><a href="#G-Divisors-of-Binomial-Coefficient" class="headerlink" title="G - Divisors of Binomial Coefficient"></a>G - Divisors of Binomial Coefficient</h4><p>求 $\dbinom{n}{k}$ 的约数个数对 $998,244,353$ 取模的结果。($1\le n\le10^{12},0\le k\le\min(10^6,n)$)</p>
<p>对于一个正整数 $n$，根据唯一分解定理，有 $n=\prod_{p_i} p_i^{e_i}$，则 $n$ 的约数个数为 $\prod_{p_i}(e_i+1)$，证明用乘法原理显然。则我们把二项式系数拆成下降幂 $\dfrac{n^{\underline{k}}}{k!}$ 的形式后，分别求出 $n,n-1,\cdot\cdot\cdot,n-k+1$ 和 $k,k-1,\cdot\cdot\cdot,1$ 这 $2k$ 个数分解质因数后的结果，即能套上述式子得到答案。当然 $n$ 的范围很大，不能直接分解质因数。不过我们可以利用 $n$ 大于 $\sqrt{n}$ 的质因数至多只有一个的性质，只判断 $\sqrt{n}$ 范围内的质数。如果朴素分解质因数得到的复杂度为 $\mathcal{O}(\dfrac{k^2}{\log k})$，不足以通过本题。但注意到，需要分解质因数的数是一些连续正整数，这样我们不去一一枚举每个数，而是去枚举每个质数，找到在对应范围内质数的所有倍数对其最终指数贡献即可。时间复杂度类似埃氏筛的时间复杂度 $\mathcal{O}(k\log \log k)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>, mod = <span class="number">998244353</span>; <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> p[N], vis[N], tp; ll a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n, k; <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) vis[i] = <span class="number">1</span>, p[++tp] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tp &amp;&amp; <span class="number">1ll</span> * p[j] * i &lt; N; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[i * p[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll d = n - k, ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) a[i] = i + d; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, e; i &lt;= tp; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        e = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = p[i], tmp; j &lt;= k; j += p[i])</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = j;</span><br><span class="line">            <span class="keyword">while</span> (tmp % p[i] == <span class="number">0</span>) --e, tmp /= p[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (ll j = (d + p[i]) / p[i] * p[i]; j &lt;= n; j += p[i])</span><br><span class="line">            <span class="keyword">while</span> (a[j - d] % p[i] == <span class="number">0</span>) ++e, a[j - d] /= p[i];</span><br><span class="line">        (ans *= (e + <span class="number">1</span>)) %= mod;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) <span class="keyword">if</span> (a[i] &gt; <span class="number">1</span>) (ans *= <span class="number">2</span>) %= mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="H-Eat-Them-All"><a href="#H-Eat-Them-All" class="headerlink" title="H - Eat Them All"></a>H - Eat Them All</h4><p>给出一个 $3\times 3$ 的网格，第 $i$ 行第 $j$ 列上有 $a_{i,j}$ 个物品。从 $(1,1)$ 出发，每次移动时先取走当前格子的一个物品，再移动到上下左右相邻的任意一个位置。当当前格子没有物品时便停止移动。找到满足以下条件的路径或报告无解：</p>
<ul>
<li>最后停在 $(1,1)$。</li>
<li>每个格子上都没有物品了。</li>
</ul>
<p>($1\le a_{i,j}\le100$)</p>
<p>细节挺多的一道题，但是一点点分析还是很有条理的。首先显然我们能把题中给出的网格图换成 $9$ 个点 $12$ 条边的二分图（在相邻两个点之间连无向边，建图可以黑白染色建）。则原问题要求找到的路径满足的条件即为：</p>
<ol>
<li>对于每个点，与它相邻的边被经过的次数和恰好为 $2\times a_{i,j}$（因为到这里需要一次，拿走又需要一次）</li>
<li>去掉经过次数为 $0$ 的边后原图仍然连通（保证最终能回到 $(1,1)$）</li>
</ol>
<p>在构造出最终的路径前，我们需要给每条边定一个经过次数，使得 1,2 条件均被满足，再根据这个经过次数找一条欧拉回路。对于条件 1 的限制，发现可以通过最大流模型解决，即源点向左部点连容量为 $2\times a_{i,j}$ 的边，右部点向汇点连 $2\times a_{i,j}$ 的边，有边相连的左右部点连容量为 $\infty$ 的边，如果源汇点相邻的边容量之和不相等，则无解。但这样有个问题，不能保证去掉 $0$ 边后原图仍然连通。所以我们考虑枚举边集的 $2^{12}$ 个子集中能使得原图连通的若干子集。我们钦定枚举到的子集内所有边均为非 $0$ 边，即已经通过一次了。假如当前与 $u$ 相邻的边中有 $deg_u$ 个已经被钦定经过了，则它与源点或汇点之间连的边容量改为 $2\times a_{i,j}-deg_u$，如果容量为负数则无解。我们跑出来个最大流，就能获得每条边被经过的次数了。</p>
<p>有了经过次数之后，直接 $\rm dfs$ 一遍同时记录一下路径就能找到答案了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> id(x, y) ((x - 1) * 3 + y)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200</span>, inf = <span class="number">1e9</span>; <span class="keyword">int</span> d[N], a[<span class="number">5</span>][<span class="number">5</span>], s, t;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span> <span class="keyword">int</span> v, next, c; &#125;E[N]; <span class="keyword">int</span> p[N], cur[N], cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(p, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span> (p)); cnt = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123; E[cnt].c = c; E[cnt].v = v; E[cnt].next = p[u]; p[u] = cnt++; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123; <span class="built_in">insert</span>(u, v, c); <span class="built_in">insert</span>(v, u, <span class="number">0</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span> (d)); d[s] = <span class="number">0</span>; cur[s] = p[s];</span><br><span class="line">    std::queue&lt;<span class="keyword">int</span>&gt; q; q.<span class="built_in">push</span>(s); <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = p[u], v; i + <span class="number">1</span>; i = E[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            v = E[i].v; cur[v] = p[v];</span><br><span class="line">            <span class="keyword">if</span> (d[v] == <span class="number">-1</span> &amp;&amp; E[i].c) d[v] = d[u] + <span class="number">1</span>, q.<span class="built_in">push</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[t] != <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> flow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == t) <span class="keyword">return</span> flow; <span class="keyword">int</span> ans = <span class="number">0</span>, ret;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cur[u], v; i + <span class="number">1</span>; i = E[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        v = E[i].v; cur[u] = i;</span><br><span class="line">        <span class="keyword">if</span> (d[v] == d[u] + <span class="number">1</span> &amp;&amp; E[i].c)</span><br><span class="line">        &#123;</span><br><span class="line">            ret = <span class="built_in">dfs</span>(v, std::<span class="built_in">min</span>(flow, E[i].c));</span><br><span class="line">            E[i].c -= ret; E[i ^ <span class="number">1</span>].c += ret;</span><br><span class="line">            ans += ret; flow -= ret; <span class="keyword">if</span> (!flow) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ans) d[u] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dinic</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> ans = <span class="number">0</span>; <span class="keyword">while</span> (<span class="built_in">bfs</span>()) ans += <span class="built_in">dfs</span>(s, inf); <span class="keyword">return</span> ans; &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DSU</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> f[N], size[N], len;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; len = n; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) f[i] = i, size[i] = <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> f[x] == x ? f[x] : f[x] = <span class="built_in">getf</span>(f[x]); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tx = <span class="built_in">getf</span>(x), ty = <span class="built_in">getf</span>(y); <span class="keyword">if</span> (tx == ty) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span> (size[tx] &lt; size[ty]) f[tx] = ty, size[ty] += size[tx];</span><br><span class="line">        <span class="keyword">else</span> f[ty] = tx, size[tx] += size[ty];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;dsu;</span><br><span class="line">std::vector&lt;std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; e; <span class="keyword">int</span> deg[N], f[N][N];</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= <span class="built_in">id</span>(<span class="number">3</span>, <span class="number">3</span>); ++v)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!f[u][v]) <span class="keyword">continue</span>;</span><br><span class="line">        --f[u][v]; --f[v][u];</span><br><span class="line">        <span class="built_in">dfs</span>(v); path.<span class="built_in">push_back</span>(v); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">3</span>; ++j) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">    s = <span class="number">0</span>; t = <span class="built_in">id</span>(<span class="number">3</span>, <span class="number">3</span>) + <span class="number">1</span>; <span class="keyword">int</span> lim = (<span class="number">1</span> &lt;&lt; <span class="number">12</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">3</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &lt;= <span class="number">3</span>) e.<span class="built_in">emplace_back</span>(<span class="built_in">id</span>(i, j), <span class="built_in">id</span>(i + <span class="number">1</span>, j));</span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= <span class="number">3</span>) e.<span class="built_in">emplace_back</span>(<span class="built_in">id</span>(i, j), <span class="built_in">id</span>(i, j + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> S = <span class="number">0</span>; S &lt;= lim; ++S)</span><br><span class="line">    &#123;</span><br><span class="line">        dsu.<span class="built_in">init</span>(<span class="built_in">id</span>(<span class="number">3</span>, <span class="number">3</span>)); </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">id</span>(<span class="number">3</span>, <span class="number">3</span>); ++i) deg[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, u, v; i &lt; <span class="number">12</span>; ++i)</span><br><span class="line">            <span class="keyword">if</span> (S &amp; (<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">            &#123;</span><br><span class="line">                u = e[i].first; v = e[i].second;</span><br><span class="line">                dsu.<span class="built_in">merge</span>(u, v); ++deg[u]; ++deg[v];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">id</span>(<span class="number">3</span>, <span class="number">3</span>) &amp;&amp; flag; ++i)</span><br><span class="line">            <span class="keyword">if</span> (dsu.<span class="built_in">getf</span>(i) != dsu.<span class="built_in">getf</span>(<span class="number">1</span>)) flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span> &amp;&amp; flag; ++i) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">3</span> &amp;&amp; flag; ++j)</span><br><span class="line">            <span class="keyword">if</span> (a[i][j] * <span class="number">2</span> &lt; deg[<span class="built_in">id</span>(i, j)]) flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!flag) <span class="keyword">continue</span>; <span class="built_in">init</span>(); <span class="keyword">int</span> lef = <span class="number">0</span>, rig = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= <span class="number">3</span>; ++i) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">3</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            x = <span class="built_in">id</span>(i, j);</span><br><span class="line">            <span class="keyword">if</span> (x &amp; <span class="number">1</span>) <span class="built_in">addedge</span>(s, x, a[i][j] * <span class="number">2</span> - deg[x]), lef += a[i][j] * <span class="number">2</span> - deg[x];</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">addedge</span>(x, t, a[i][j] * <span class="number">2</span> - deg[x]), rig += a[i][j] * <span class="number">2</span> - deg[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lef != rig) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, u, v; i &lt; <span class="number">12</span>; ++i)</span><br><span class="line">            <span class="keyword">if</span> (S &amp; (<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">            &#123;</span><br><span class="line">                u = e[i].first; v = e[i].second;</span><br><span class="line">                <span class="keyword">if</span> (v &amp; <span class="number">1</span>) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">                <span class="built_in">addedge</span>(u, v, inf);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="built_in">dinic</span>(); <span class="keyword">if</span> (ret != lef) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">id</span>(<span class="number">3</span>, <span class="number">3</span>); ++i) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="built_in">id</span>(<span class="number">3</span>, <span class="number">3</span>); ++j) f[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, u, v; i &lt; cnt; i += <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            u = E[i ^ <span class="number">1</span>].v; v = E[i].v;</span><br><span class="line">            f[u][v] = f[v][u] = inf - E[i].c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, u, v; i &lt; <span class="number">12</span>; ++i)</span><br><span class="line">            <span class="keyword">if</span> (S &amp; (<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">            &#123;</span><br><span class="line">                u = e[i].first; v = e[i].second;</span><br><span class="line">                ++f[u][v]; ++f[v][u];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>); std::<span class="built_in">reverse</span>(path.<span class="built_in">begin</span>(), path.<span class="built_in">end</span>());</span><br><span class="line">        std::string ans; <span class="keyword">int</span> x = <span class="number">1</span>, y = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; path.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tx = path[i] / <span class="number">3</span> + <span class="number">1</span>, ty = path[i] % <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">if</span> (ty == <span class="number">0</span>) --tx, ty = <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">if</span> (tx + <span class="number">1</span> == x) ans += <span class="string">&quot;U&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (tx - <span class="number">1</span> == x) ans += <span class="string">&quot;D&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (ty - <span class="number">1</span> == y) ans += <span class="string">&quot;R&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (ty + <span class="number">1</span> == y) ans += <span class="string">&quot;L&quot;</span>;</span><br><span class="line">            x = tx; y = ty;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; ans &lt;&lt; std::endl; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本场没什么特别的科技之类的。但 H 题我认为比较有价值，它给我们带来的经验是面对一道无从下手的题，可以尝试转化后，分步一点点解决。虽然这样码量会很大，但如果思路清晰码起来也不算太难。当然 E,F 的 $\rm dp$ 也很精彩，可以为我们解决类似问题提供思路。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhiyangfan1234.github.io/2022/01/24/AtCoder%20Grand%20Contest%20002/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhiyangfan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhiyangfan 的博客小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/24/AtCoder%20Grand%20Contest%20002/" class="post-title-link" itemprop="url">AtCoder Grand Contest 002</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-01-24 17:00:23 / 修改时间：17:11:00" itemprop="dateCreated datePublished" datetime="2022-01-24T17:00:23+08:00">2022-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="AtCoder-Grand-Contest-002"><a href="#AtCoder-Grand-Contest-002" class="headerlink" title="AtCoder Grand Contest 002"></a>AtCoder Grand Contest 002</h2><p>xs 刚开始打的时候脑子不太清晰，A 题 $\tt WA$ 了 $\tt 3$ 发，心态直接爆炸。不过后来 D 题整体二分做出来了害挺开心。$\rm RK$ 的话大概是 $85/662$ 。</p>
<h4 id="A-Range-Product"><a href="#A-Range-Product" class="headerlink" title="A - Range Product"></a>A - Range Product</h4><p>给出两个整数 $a,b$ ，问 $\prod_{i=a}^b i$ 是正数，还是负数，还是 $0$ 。( $-10^9\le a\le b\le10^9$ )</p>
<p>简单的观察就可以知道（下面的式子中令 $\dfrac{0}{0}=0$）：</p>
<p>$\dfrac{|\prod_{i=a}^b i|}{\prod_{i=a}^b i}=\begin{cases}-1&amp;a<0\and b<0\and (b-a+1)\equiv 1\pmod{2}\\1&(a>0\and b&gt;0)\or(a&lt;0\and b&lt;0\and (b-a+1)\equiv0\pmod{2}\\0&amp;ab\le0\end{cases}$ </p>
<p>$\mathcal{O}(1)$ 计算即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> a, b; <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="keyword">if</span> (a * b &lt;= <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;Zero\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;Positive\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((b - a + <span class="number">1</span>) &amp; <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Negative\n&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Positive\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="B-Box-and-Ball"><a href="#B-Box-and-Ball" class="headerlink" title="B - Box and Ball"></a><strong>B - Box and Ball</strong></h4><p>有 $n$ 个盒子，把它们从 $1$ 到 $n$ 编号。开始时，$1$ 盒子有一个红球，而其余的盒子有一个白球。现在依次进行 $m$ 次操作，在第 $i$ 次操作中，从 $x_i$ 盒子中随机拿一个球放入 $y_i$ 盒子中。问最终可能含有红球的盒子个数。( $2\le n\le 10^5,1\le m\le10^5,x_i\neq y_i$ ，保证操作合法 )</p>
<p>我们可以这样理解原问题：有 $n$ 个水杯，初始时第 $1$ 个水杯里有 $10\text{mL}$ 红墨水，而其余的水杯有 $10\text{mL}$ 纯净水，每次操作是把 $x_i$ 水杯内的水倒 $10\text{mL}$ 进入 $y_i$ 水杯中（如果倒完了，假设水的颜色不会残留在原水杯中） ，最后在 $m$ 次操作后问有多少个水杯内的水是红色的。因为一旦红球进入过某个盒子，除非把这个盒子的球全部拿完（水全部倒完），否则都有可能红球还留在这个盒子（水如果不全部倒完就会一直是红色的），而除非红球就没可能在这个盒子内，否则在拿到其他盒子时都有可能拿到红球（红水倒进其他水杯会染色）。</p>
<p>那问题就简单了，对于每个盒子维护一个 $cnt$ 表示里面有多少球，一个 $hr$ 表示是否可能有红球。每次操作，如果 $hr_{x_i}=1$ 答案才有可能变化：如果 $cnt_{x_i}&gt;1$ ，$x_i$ 中的球没有全部拿完，依然是红色，而 $y_i$ 被染色，如果 $hr_{y_i}=0$， 答案 $+1$ 就好，记得记录一下 $hr_{y_i}=1$ ；如果 $cnt_{x_i}=1$ ，$x_i$ 中的球拿完了，不可能再有红球了，即 $hr_{x_i}=0$ ，答案 $-1$ ， $y_i$ 被染色，如果 $hr_{y_i}=0$， 答案 $+1$ 就好，记得记录一下 $hr_{y_i}=1$ 。时间复杂度 $\mathcal{O}(n+m)$  。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> cnt[N], hr[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cnt[i] = <span class="number">1</span>;</span><br><span class="line">    hr[<span class="number">1</span>] = <span class="number">1</span>; <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span> (hr[x] &amp;&amp; cnt[x] &gt; <span class="number">1</span>)</span><br><span class="line">        &#123; <span class="keyword">if</span> (!hr[y]) &#123; ++ans; hr[y] = <span class="number">1</span>; &#125; &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (hr[x] &amp;&amp; cnt[x] == <span class="number">1</span>)</span><br><span class="line">        &#123; hr[x] = <span class="number">0</span>; --ans; <span class="keyword">if</span> (!hr[y]) &#123; ++ans; hr[y] = <span class="number">1</span>; &#125; &#125;</span><br><span class="line">        --cnt[x]; ++cnt[y];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="C-Knot-Puzzle"><a href="#C-Knot-Puzzle" class="headerlink" title="C - Knot Puzzle"></a>C - Knot Puzzle</h4><p>有 $n$ 个绳子，把它们从 $1$ 到 $n$ 编号，$i$ 号绳子的长度为 $a_i$ 。初始时，我们对于每个 $i(1\le i\le n-1)$ ，都把 $i$ 号绳子和 $i+1$ 号绳子打个绳结连起来，形成一个上面有 $n-1$ 个绳结的长绳子。接下来我们尝试不断用以下操作来解开所有的绳结：</p>
<ul>
<li>选择一个长度至少为 $L$ 的绳子，解开这个绳子上的一个绳结。</li>
</ul>
<p>如果可能全解开，输出 <code>possible</code> ，然后找到一种解绳结的方案，按解开的顺序输出绳结编号（如果一个绳结连接了 $i$ 和 $i+1$ ，则它的编号是 $i$ ），否则输出 <code>Impossible</code> 。( $2\le n\le 10^5,1\le L\le 10^9,1\le a_i\le 10^9$ )</p>
<p>我们发现，如果一个方案可行，则最终剩下来的 $a_i$ 和 $a_{i+1}$ 一定满足 $a_i+a_{i+1}\le L$ 。所以我们可以找到满足这个条件的一个 $i$ （如果找不到就是无解情况），接着依次解开 $1,2,3,\cdot\cdot\cdot,i-1$ 号绳结，然后再依次解开 $n-1,n-2,n-3,\cdot\cdot\cdot,i+1$ 号绳结，最后解开 $i$ 号绳结。因为每次操作会把整个绳子分为两个部分，一部分只有一个绳子不需要再管了，而另一部分包含 $a_i,a{i+1}$ ，和一定 $\ge L$ ，可以继续操作，所以这样的方案一定合法。时间复杂度 $\mathcal{O}(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum; <span class="keyword">int</span> cut[N], a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, L, pos = <span class="number">-1</span>; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;L);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (a[i] + a[i + <span class="number">1</span>] &gt;= L) </span><br><span class="line">        &#123; pos = i; <span class="keyword">break</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (pos == <span class="number">-1</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;Impossible\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Possible\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; pos; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= pos + <span class="number">1</span>; --i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, pos);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="D-Stamp-Rally"><a href="#D-Stamp-Rally" class="headerlink" title="D - Stamp Rally"></a>D - Stamp Rally</h4><p>给出一个 $n$ 个节点和 $m$ 条边（边从 $1$ 到 $m$ 编号）的连通无向图和 $Q$ 组询问。对于每组询问，给出 $x_i,y_i,z_i$ ，询问两个人分别从 $x_i$ 和 $y_i$ 出发，恰好经过 $z_i$ 个节点（不管是一个人经过多次还是两个人都经过，一个点都只算一次）的情况下，经过边的编号最大值最小可能是多少。( $3\le n\le10^5,n-1\le m\le10^5,1\le Q\le 10^5,x_i\neq y_i,3\le z_i\le n$ ，无自环 )</p>
<p>首先看到 “最大值最小” ，立马想到二分。接着一个 naive 的想法就出来了，对于每组询问，在 $[1,m]$ 范围内二分，<code>check()</code> 函数中，我们用并查集加入前 $mid$ 条边，看 $x_i,y_i$ 能到达的点集合大小是大于 $z_i$ 还是小于 $z_i$ 。这样做的时间复杂度是 $\mathcal{O}(Qm\log m)$ 显然会超时。我们注意到一次 $mid$ 的计算可以决定所有询问的范围，没必要每组询问都建一次图，所以可以考虑整体二分。</p>
<p>可以递归实现，但这里采用了模拟，用队列实现。队列中的节点是三元组 $(L,R,\{\cdot\cdot\cdot\})$ ，其中 $L,R$ 表示当前答案区间为 $(L,R]$ ，$\{\cdot\cdot\cdot\}$ 表示这些询问的答案在前面的答案区间中。初始时我们把 $(0,m,\{1,2,3,\cdot\cdot\cdot,Q\})$ 加入队列。每次取出队首，如果 $L+1=R$ ，直接把 $\{\cdot\cdot\cdot\}$ 内所有询问的答案设为 $R$ 就好。如果 $L+1&lt;R$ ，则令 $MID = \left\lfloor\dfrac{L+R}{2}\right\rfloor$ ，如果并查集内的边小于 $MID$ 个，就把边加到 $MID$ 个；如果大于 $MID$ 个，就清空再加 $MID$ 个（应该可以可持久化一下然后回撤，不过没必要，反正这样暴力搞最多 $\log m$ 次，瓶颈不在这儿），接着对于 $\{\cdot\cdot\cdot\}$ 里面所有的询问判断，如果答案区间在 $(L,MID]$ 中，就加入 $v1$ ，如果答案区间在 $(MID,R]$ ，就加入 $v2$ 。最终把 $(L,MID, v1)$ 和 $(MID, R,v2)$ 入队就好。时间复杂度 $\mathcal{O}(m\log m)$  。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DSU</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> f[N], size[N], maxn;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxn; ++i) f[i] = i, size[i] = <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123; <span class="keyword">return</span> f[u] == u ? u : f[u] = <span class="built_in">getf</span>(f[u]); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t1 = <span class="built_in">getf</span>(u), t2 = <span class="built_in">getf</span>(v);</span><br><span class="line">        <span class="keyword">if</span> (t1 != t2) f[t1] = t2, size[t2] += size[t1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;dsu;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span>&#123;</span> <span class="keyword">int</span> x, y, z; &#125;q[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">int</span> l, r; std::vector&lt;<span class="keyword">int</span>&gt; vec; </span><br><span class="line">    <span class="built_in">node</span>(<span class="keyword">int</span> l = <span class="number">0</span>, <span class="keyword">int</span> r = <span class="number">0</span>, std::vector&lt;<span class="keyword">int</span>&gt; vec = std::vector&lt;<span class="keyword">int</span>&gt;()) :</span><br><span class="line">        <span class="built_in">l</span>(l), <span class="built_in">r</span>(r), <span class="built_in">vec</span>(vec) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N], ans[N]; std::queue&lt;node&gt; tq;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, cnt = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    dsu.maxn = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a[i], &amp;b[i]);</span><br><span class="line">    <span class="keyword">int</span> Q; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;Q); dsu.<span class="built_in">init</span>();</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; ve;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;q[i].x, &amp;q[i].y, &amp;q[i].z), ve.<span class="built_in">push_back</span>(i);</span><br><span class="line">    tq.<span class="built_in">push</span>(<span class="built_in">node</span>(<span class="number">0</span>, m, ve));</span><br><span class="line">    <span class="keyword">while</span> (!tq.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        node u = tq.<span class="built_in">front</span>(); tq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (u.l + <span class="number">1</span> == u.r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; u.vec.<span class="built_in">size</span>(); ++i)</span><br><span class="line">                ans[u.vec[i]] = u.r;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::vector&lt;<span class="keyword">int</span>&gt; v1, v2;</span><br><span class="line">        <span class="keyword">int</span> mid = (u.l + u.r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (cnt &lt; mid)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = cnt + <span class="number">1</span>; i &lt;= mid; ++i)</span><br><span class="line">                dsu.<span class="built_in">merge</span>(a[i], b[i]);</span><br><span class="line">            cnt = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cnt &gt; mid)</span><br><span class="line">        &#123;</span><br><span class="line">            dsu.<span class="built_in">init</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= mid; ++i)</span><br><span class="line">                dsu.<span class="built_in">merge</span>(a[i], b[i]);</span><br><span class="line">            cnt = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, x, y, siz, t1, t2; i &lt; u.vec.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            x = q[u.vec[i]].x, y = q[u.vec[i]].y; siz = <span class="number">0</span>;</span><br><span class="line">            t1 = dsu.<span class="built_in">getf</span>(x), t2 = dsu.<span class="built_in">getf</span>(y);</span><br><span class="line">            <span class="keyword">if</span> (t1 == t2) siz = dsu.size[t1];</span><br><span class="line">            <span class="keyword">else</span> siz = dsu.size[t1] + dsu.size[t2];</span><br><span class="line">            <span class="keyword">if</span> (siz &gt;= q[u.vec[i]].z) v1.<span class="built_in">push_back</span>(u.vec[i]);</span><br><span class="line">            <span class="keyword">else</span> v2.<span class="built_in">push_back</span>(u.vec[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        tq.<span class="built_in">push</span>(<span class="built_in">node</span>(u.l, mid, v1)); </span><br><span class="line">        tq.<span class="built_in">push</span>(<span class="built_in">node</span>(mid, u.r, v2));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="E-Candy-Piles"><a href="#E-Candy-Piles" class="headerlink" title="E - Candy Piles"></a>E - Candy Piles</h4><p>有 $n$ 堆石子，每堆有 $a_i$ 个石子。现在 Alice 和 Bob 在玩游戏，每轮玩家可以执行以下两种操作：</p>
<ol>
<li>选取数量最多的那堆石子全部拿走；</li>
<li>从每堆石子拿走一个。</li>
</ol>
<p>拿走最后一个石子的人输。现在两人都采用最优策略，问先手必胜还是后手必胜。( $1\le n\le10^5,1\le a_i\le10^9$ )</p>
<p>ps. 这个题需要用图，我不可避免的要从 AtCoder 找一些图qwq。</p>
<p>人类智慧神仙题Orz</p>
<p>如果把石子从大到小排序 ，我们就得到了这样一张图:</p>
<p><img src="https://s2.ax1x.com/2019/10/13/uxC5ND.png" alt="ex1"></p>
<p>注意到操作1相当于从最左端拿走一列，而操作2相当于从最底下抽走一行。这样如果我们把上图看为一个表格，那可以把问题抽象为从表格左下角出发，轮流行走，一次可以向左走一格（操作1）或向上走一个（操作2），先碰到边界线的失败。也就是这张图：</p>
<p><img src="https://s2.ax1x.com/2019/10/13/uxiGyn.png" alt=""></p>
<p>那转化为这个模型后，就要找必胜和必败点了，最终答案就是左下角点的状态。首先注意到边界上的点一定是先手必胜点，因为后手刚刚走到了边界。最 naive 的想法是根据这个结论一点点递推，但这样复杂度高达 $\sum_{i=1}^n a_i$ ，不能接受。接着我们发现，如果我们设左下角的点是 $(0,0)$ ，则如果 $(x,y)$ 是必败态，则 $(x-1,y),(x,y-1)$ 应该是必胜态，相应地，$(x-1,y-1)$ 是必败态。类似地，我们可以证明如果 $(x+2,y+2),(x+1,y+1)$ 均为必胜态，则 $(x,y)$ 也应该是必胜态，这样我们得出了一个结论，除去边界上的点，所有的对角线上的点状态相同。这样我们就可以把求 $(0,0)$ 的状态转化为求 $(0,0)$ 所在对角线上任意一点的状态，通过这张图可以看得更直观一点：</p>
<p><img src="https://s2.ax1x.com/2019/10/13/uxite0.png" alt=""></p>
<p>为了尽可能简化计算，待求的点应该尽可能接近边界，这样需要递推的内容就尽可能少。换句话说，就是找最大的以 $(0,0)$ 为左下顶点的正方形，且其他顶点不碰到边界。在上面的例子中，这个正方形的右上角应该是 $(3,3)$ ，如图：</p>
<p><img src="https://s2.ax1x.com/2019/10/13/uxiNwV.png" alt=""></p>
<p>一个结论是，从右上角这个点开始往上和往右走，在碰到边界前走的步数，如果全为偶数，则这个点为必败态，否则为必胜态，原因得大概是在这个过程上必胜态和必败态是交替出现的。 $\mathcal{O}(n)$ 找到这个正方形后 $\mathcal{O}(n)$ 计算就好，总复杂度 $\mathcal{O}(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>; <span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; x, <span class="keyword">const</span> <span class="keyword">int</span>&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> x &gt; y; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    std::<span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &gt; a[i + <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (a[j + i + <span class="number">1</span>] == i) ++j;</span><br><span class="line">            <span class="keyword">if</span> (((a[i] - i) &amp; <span class="number">1</span>) || (j &amp; <span class="number">1</span>)) <span class="built_in">printf</span>(<span class="string">&quot;First\n&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Second\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="F-Leftmost-Ball"><a href="#F-Leftmost-Ball" class="headerlink" title="F - Leftmost Ball"></a>F - Leftmost Ball</h4><p>给出 $n\times k$ 个球，一共 $n$ 种颜色，每种 $k$ 个。现在将这些球随意地从左至右摆放成一行，然后对于这 $n$ 种颜色，把每种颜色的最左端的球涂成不同于这 $n$ 种颜色的其他颜色。求最终能形成多少颜色序列，答案对 $10^9+7$ 取模。( $1\le n,k\le 2000$ )</p>
<p>题解的求拓扑序个数的方法没怎么看懂（摊手），所以这里给出一个 $\mathcal{O}(n^2)$ 的 $\rm dp$ 吧，不知道算不算一个思路。</p>
<p>我们发现正着想不好想，我们反着考虑，求出所有可能的合法的最终序列。假设题目中描述的不同的颜色是白色，则对于某一个序列，它是合法的当且仅当对于所有的 $1\le i\le n$ ，从左往右数第 $i$ 个白球在第 $i$ 种颜色的最左端的球的左边。</p>
<p>则我们设 $f_{i,j}$ 表示放了 $i$ 个白球和 $j$ 种非白球的方案数。因为一个白球要对应一种非白球，所以 $j\le i$ 。$f_{i,j}$ 可以从两个地方转移过来，一个是新加入一个白球，也就是 $f_{i-1,j}$ ，一个是新加入一种颜色，也就是 $f_{i,j-1}$ 。为了避免重复算的情况，我们每次加入球都要放在所有可能位置中的最左端。对于放入一个白球，就只有一种情况——放在最左边的空位；而对于新加入一种颜色，首先我们有 $n-(j-1)$ 种剩余颜色可以放，把其中一个放到最左端之后之后还剩 $k-2$ 个球需要放，一共有 $n\times k-i-(j-1)(k-1)-1$ 空位，所以有 $\dbinom{n\times k-i-(j-1)(k-1)-1}{k-2}$ 种方案数。最终的转移方程就是： $f_{i,j}=f_{i-1,j}+f_{i,j-1}(n-j+1)\dbinom{n\times k-i-(j-1)(k-1)-1}{k-2}$</p>
<p>边界条件是 $f_{i,0}=1(0\le i\le n)$ ，这个表示只有白球，肯定只有一种方案。最终答案就为 $f_{n,n}$ 。时间复杂度 $\mathcal{O}(n^2)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e3</span> + <span class="number">10</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> fac[N * N], ifac[N * N], f[N][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ksm</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="number">1ll</span> * a * ret % mod;</span><br><span class="line">        a = <span class="number">1ll</span> * a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="number">1ll</span> * fac[n] * ifac[m] % mod * ifac[n - m] % mod; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">1</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    fac[<span class="number">0</span>] = ifac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * k; ++i)</span><br><span class="line">        fac[i] = <span class="number">1ll</span> * fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    ifac[n * k] = <span class="built_in">ksm</span>(fac[n * k], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n * k - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        ifac[i] = <span class="number">1ll</span> * ifac[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) f[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span> (j)</span><br><span class="line">                f[i][j] = (f[i][j] + (<span class="number">1ll</span> * f[i][j - <span class="number">1</span>] * (n - j + <span class="number">1</span>) % mod</span><br><span class="line">                * <span class="built_in">C</span>(n * k - i - (j - <span class="number">1</span>) * (k - <span class="number">1</span>) - <span class="number">1</span>, k - <span class="number">2</span>) % mod)) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[n][n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="知识经验总结"><a href="#知识经验总结" class="headerlink" title="知识经验总结"></a>知识经验总结</h3><ol>
<li>对于一次二分 <code>check()</code> 函数可以判断所有询问的取值范围的题目，可以考虑整体二分，一般就是维护一个三元组 $(L,R,\{\cdot\cdot\cdot\})$ 表示询问 $\{\cdot\cdot\cdot\}$ 的答案范围为 $(L,R]$ ，之后 $\rm bfs$ 或者 $\rm dfs$ 递归二分计算；</li>
<li>博弈论的题有时候要把题目中的描述换一种表示方法才能更容易利用博弈论相关算法计算，当常规方法无法直接计算时，要注意找题目中的规律，利用规律加速计算；</li>
<li>正难则反，如果一个题目问的是有多少种不同的结果，则可以考虑找所有可能的合法结果数。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhiyangfan1234.github.io/2022/01/24/AtCoder%20Grand%20Contest%20003/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhiyangfan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhiyangfan 的博客小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/24/AtCoder%20Grand%20Contest%20003/" class="post-title-link" itemprop="url">AtCoder Grand Contest 003</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-01-24 17:00:23 / 修改时间：17:11:31" itemprop="dateCreated datePublished" datetime="2022-01-24T17:00:23+08:00">2022-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="AtCoder-Grand-Contest-003"><a href="#AtCoder-Grand-Contest-003" class="headerlink" title="AtCoder Grand Contest 003"></a>AtCoder Grand Contest 003</h2><p>xs D题想出来一个图论做法（应该是假的），结果把匈牙利的复杂度记成了 $\mathcal{O}(|V|+|E|)$ ，然后其他啥都写完了就剩匈牙利的时候发现复杂度其实是  $\mathcal{O}(|V||E|)$ ，然后就寄了。</p>
<p>upd. 把 D,E 题总结中混乱，错误的部分纠正了，放上 F 题说明和 E,F 题代码，放上总的总结。</p>
<h4 id="A-Wanna-go-back-home"><a href="#A-Wanna-go-back-home" class="headerlink" title="A - Wanna go back home"></a>A - Wanna go back home</h4><p>一个人在二维平面上行走 $n$ 天，每天会朝东南西北中给定的一个方向前进，问能否通过恰当安排每天前进的距离来使得在 $n$ 天后回到起点。( $1\le n\le1000$ )</p>
<p>注意到如果每天的距离是可以随意安排的，则行进相同方向的若干天可以被合并为一天，这样 $n$ 天就被转化为最多 $4$ 天。只要向东走而不向西走或者向南走而不向北走，就无法回到起点，反之亦然。读入时记录一下，然后 $\mathcal{O}(1)$ 判断即可，最终复杂度就是读入的复杂度，$\mathcal{O}(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> s[N]; <span class="keyword">int</span> book[<span class="string">&#x27;Z&#x27;</span> + <span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>); <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        book[s[i]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((book[<span class="string">&#x27;W&#x27;</span>] ^ book[<span class="string">&#x27;E&#x27;</span>]) || (book[<span class="string">&#x27;S&#x27;</span>] ^ book[<span class="string">&#x27;N&#x27;</span>]))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="B-Simplified-mahjong"><a href="#B-Simplified-mahjong" class="headerlink" title="B - Simplified mahjong"></a>B - Simplified mahjong</h4><p>给出一些卡片，每张卡片上有 $1$ 到 $n$ 之间的整数，写有整数 $i$ 的卡片有 $a_i$ 张。两张卡片可以被合并为一对，当且仅当两张卡片上写的数字差的绝对值小于 $2$ 。求所有卡片最多能组成多少对。( $1\le n\le10^5,0\le a_i\le10^9$ )</p>
<p>如果原题条件改为 $0&lt;a_i\le10^9$ ，则答案应该为 $\left\lfloor\dfrac{S}{2}\right\rfloor$ ，其中 $S=\sum_{i=1}^n a_i$ 。证明的话，首先肯定不可能配对出比 $\left\lfloor\dfrac{S}{2}\right\rfloor$ 更多的对数了，所以要证明的是一定可以找到 $\left\lfloor\dfrac{S}{2}\right\rfloor$ 对。如果我们把所有的牌按照上面写的整数排列成一个不下降序列，$x_1,x_2,\cdot\cdot\cdot,x_{S}$ （其中 $x_i$ 是卡片上写的数字），则一定有 $x_{i+1}-x_i&lt;2$ （否则与  $a_i\neq0$ 矛盾），所以我们可以找到 $\left\lfloor\dfrac{S}{2}\right\rfloor$ 对卡片——$(x_1,x_2),(x_3,x_4),\cdot\cdot\cdot$ 。而如果 $0\le a_i\le10^9$ ，则可能存在一些地方使得 $x_{i+1}-x_i\ge 2$ ，那我就把 $a_i=0$ 的位置当成分割线，把原序列分成若干个满足 $a_i\neq0$ 的子序列。分别求解后相加即可，时间复杂度 $\mathcal{O}(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n); <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!a[i]) &#123; ans += cnt / <span class="number">2</span>; cnt = <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="keyword">else</span> cnt += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ans += cnt / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="C-BBuBBBlesort"><a href="#C-BBuBBBlesort" class="headerlink" title="C - BBuBBBlesort!"></a>C - BBuBBBlesort!</h4><p>给出一个有 $n$ 个整数的序列 $a$ ，满足 $a_i$ 之间互不相同 。我们可以进行两种操作：</p>
<ul>
<li><p>操作 $1$ ：选择两个连续的元素，反转它们的顺序。</p>
</li>
<li><p>操作 $2$ ：选择三个连续的元素，反转它们的顺序。</p>
</li>
</ul>
<p>问最少需要多少次操作 $1$ 才能使原序列从小到大排序。( $1\le n\le10^5,0\le a_i\le10^9,\forall i\neq j,a_i\neq a_j$ )</p>
<p>注意到操作 $2$ 相当于交换两个相隔一位的元素，操作 $1$ 相当于交换两个相邻一位的元素。一个很重要的想法是注意下标奇偶性。对于操作 $2$ ，它是不会改变元素在序列中下标奇偶性的，也就是说，如果一个元素在排序后下标是偶数，但在原序列中下标是奇数，就不可能只通过操作 $2$ 达到使它到该到的位置。</p>
<p>那么一个想法就是排序后统计所有下标奇偶性与原来不同的元素个数，除以 $2$ 后就是答案（因为一次操作 $1$ 可以改变两个元素下标的奇偶性）。证明就以给出构造方法来证明吧。首先我们注意到，如果把原序列分为下标为奇数的和下标为偶数的两个子序列，只使用操作$2$ 的话，对于每个子序列都可以随意交换相邻的元素，而这样就可以达到随意排列这两个序列的目的。那我们就可以通过恰当的操作把需要改变奇偶性的元素成对排到相邻位置然后用操作 $1$ 交换。接着所有的元素都在它该在的子序列中了，接着就可以只用操作 $2$ 使每个元素到达排序后的位置了。时间复杂度就是排序的复杂度，$\mathcal{O}(n\log n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val, pos;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node&amp; x) &#123; <span class="keyword">return</span> val &lt; x.val; &#125;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, ans = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i].val), a[i].pos = i;</span><br><span class="line">    std::<span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//这里只找奇-&gt;偶的，是因为一定会有一个偶-&gt;奇与它形成一对</span></span><br><span class="line">    <span class="comment">//只找一边就不用除以2了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> ((a[i].pos &amp; <span class="number">1</span>) &amp;&amp; !(i &amp; <span class="number">1</span>)) ++ans;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="D-Anticube"><a href="#D-Anticube" class="headerlink" title="D - Anticube"></a>D - Anticube</h4><p>给出有 $n$ 个正整数的序列 $s$ 。现在想从中选取一个子序列 $S$ ，使得 $\forall i,j,S_i\times S_j$ 不是立方数。问 $S$ 中最多能有多少元素。( $1\le n\le 10^5,1\le s_i\le10^{10}$ )</p>
<p>我想的图论做法是最大点独立集….显然不行，这还是一道根正苗红的数论题啊。我们对于每个整数 $x$ ，定义 $norm_x$ 为 $x$ 去掉所有立方因子的正整数，$pair_x$ 为与 $x$ 相乘后为立方数的最小正整数。则我们注意到，如果 $norm_x=pair_y$ ，则 $x,y$ 就不能被同时选取。所以我们统计一下对于所有的 $s_i$ ，$norm_{s_i}$ 出现了多少次，然后对于正整数 $x$ ，如果 $norm_x=norm_y$ ，则 $x=y$ ，如果 $norm_y=pair_x$ ，则 $x,y$ 不能同时选取，所以 $x$ 带来的贡献应该是 $\max(cnt_{norm_x},cnt_{pair_x})$ ，其中 $cnt_t$ 表示 $t$ 在 $norm_{s_i}$ 中的出现次数，因为是选取，所以加上贡献后要把 $cnt_{norm_x},cnt_{pair_x}$ 清 $0$。</p>
<p>问题转化为了如何对于每个 $x$ 快速求解 $norm_x,pair_x$ 。首先直接分解质因数是 $\mathcal{O}(n\sqrt{\max_{s_i}})$ 级别的，会 $\tt TLE$ 。注意到我们要的是立方因子，所以可以只分解到 $\sqrt[3]{\max_{s_i}}$ 的质数，其余算成大质数直接扔到 $norm_x$ 里面就好。分解的时候如果一个质数 $p$ 在 $x$ 中出现了 $c$ 次，则 $norm_x$ 应该乘 $p^{c\operatorname{mod} 3}$ （ $\operatorname{mod}3$ 就是去掉立方因子 ），$pair_x$ 应该乘 $p^{(3-c)\operatorname{mod}3}$ （补上不够立方的部分）。最终剩余的 $x$ 对于 $norm_x$ 的贡献上文提到了，而对于 $pair_x$ 的贡献，如果 $x$ 不是平方数，则还得再乘 $x^2$ 才能构成立方数，否则只需要再乘 $\sqrt{x}$ 就好。算出来 $norm_x$ 和 $pair_x$ 后直接计算就好，筛质数的复杂度为 $\mathcal{O}(\sqrt[3]{s_i})$ ，分解质因数的复杂度为 $\mathcal{O}(\dfrac{\sqrt[3]{s_i}}{\log(\sqrt[3]{s_i})})$ （ 小于等于 $x$ 的质数量级在 $\dfrac{x}{\log x}$ 级别） ，最终计算的复杂度为 $\mathcal{O}(n\log n)$ （带个 $\log$ 是因为需要用 $\rm map$），所以最终复杂度 $\mathcal{O}(\dfrac{\sqrt[3]{s_i}}{\log(\sqrt[3]{s_i})}+n\log n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>; <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> p[N], vis[N], tp; ll norm[N], pair[N]; </span><br><span class="line">std::map&lt;ll, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">getP</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) p[++tp] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; i * p[j] &lt;= n &amp;&amp; j &lt;= tp; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[i * p[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">getP</span>(<span class="number">5e3</span>); <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    ll cnt, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ll x, now = <span class="number">1</span>, y = <span class="number">1</span>; </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;x); </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tp; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (x % p[j] == <span class="number">0</span>) x /= p[j], ++cnt;</span><br><span class="line">            cnt %= <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">if</span> (cnt)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= cnt; ++k)</span><br><span class="line">                    now *= p[j];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = cnt + <span class="number">1</span>; k &lt;= <span class="number">3</span>; ++k)</span><br><span class="line">                    y *= p[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        now *= x; </span><br><span class="line">        <span class="keyword">if</span> ((ll)<span class="built_in">sqrt</span>(x) * (ll)<span class="built_in">sqrt</span>(x) == x) y *= <span class="built_in">sqrt</span>(x);</span><br><span class="line">        <span class="keyword">else</span> y *= x * x;</span><br><span class="line">        ++mp[now]; norm[i] = now; pair[i] = y; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (norm[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        ans += std::<span class="built_in">max</span>(mp[norm[i]], mp[pair[i]]);</span><br><span class="line">        mp[norm[i]] = mp[pair[i]] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans + !!mp[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="E-Sequential-operations-on-Sequence"><a href="#E-Sequential-operations-on-Sequence" class="headerlink" title="E - Sequential operations on Sequence"></a>E - Sequential operations on Sequence</h4><p>给出一个有 $n$ 个整数的序列，初始时第 $i$ 位上的值就是 $i$ 。给出 $Q$ 次操作，每次操作有一个参数 $q_i$ ，然后对原序列进行以下操作：</p>
<ul>
<li>从把当前序列无限复制延伸得到的序列中（如 $1,2,3,4,5$ 就对应着 $1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,\cdot\cdot\cdot$），取出前 $q_i$ 位作为新的序列。</li>
</ul>
<p>在 $Q$ 次操作后，询问 $1$ 到  $n$ 每个数在最终序列中出现了多少次。( $1\le n\le 10^5,0\le Q\le10^5,1\le q_i\le10^{18}$ )</p>
<p>ps. 这个算法比较难理解，不好描述，如果感到困惑的话可以按照算法流程手玩几组数据基本就明白了。</p>
<p>首先我们注意到，如果 $q_i\ge q_{i+1}$ ，则我们就可以忽略 $q_i$ ，因为 $q_i,q_{i+1}$ 和 $q_{i+1}$ 是等价的。所以我们可以通过单调栈，把原修改序列 $q$ 转化为一个上升序列 $b$ 。我们设 $l$ 表示 $b$ 的长度。则我们可以考虑从 $b_l$ 到 $b_1$ 执行操作。</p>
<ul>
<li>首先建一个有 $b_l$ 个元素的序列，每个元素都为 $1$ 。</li>
<li>如果我们当前正在执行操作参数为 $x$ ，则我们把原序列换为一个有 $x$ 元素的序列，新序列的第 $i$ 个元素的值为原序列的所有下标在模 $x$ 意义下等于 $i$ 的元素之和。</li>
<li>最后输出最终序列就是答案。</li>
</ul>
<p>这个过程相当于从最终状态（不考虑本质不同的话，每个数都出现一次），一点点合并成答案状态（考虑本质不同，每个数出现的次数），显然这个复杂度为 $\mathcal{O}(n+Qq_i)$ 级别的，不能接受。所以考虑改进算法。不仅仅是按照 $b_l$ 到 $b_1$ 的顺序单独处理每个操作，考虑以下算法：</p>
<ul>
<li>定义两个数组：$a,t$ ，其中 $t_l=1$ 。</li>
<li><p>我们依然是按照 $b_l$ 到 $b_1$ 的顺序，然后进行到 $b_i$ 时，执行以下操作：</p>
<ul>
<li>令 $k=b_i$ 。</li>
<li><p>对于 $b_{i-1},\cdot\cdot\cdot,b_1$ 我们分别处理，每个执行以下操作：</p>
<ol>
<li><p>假如我们正在处理 $b_j$ 。</p>
</li>
<li><p>如果 $k\ge b_j$ ，则我们给 $t_j$ 加上 $t_i\times \left\lfloor\dfrac{k}{b_j}\right\rfloor$ ，然后把 $k$ 替换为 $k\mod{b_j}$ </p>
</li>
</ol>
</li>
<li>给  $a_1,a_2,\cdot\cdot\cdot,a_{k}$ 加上 $t_i$ 。</li>
</ul>
</li>
<li>最后输出 $a$ 序列就是答案。</li>
</ul>
<p>在这个算法中，$t_i$ 是第 $i$ 次操作后对应的序列在最终序列中出现的次数（也就是循环节），$k$ 的值是除了 $t_i$ 次的出现外在最终序列中元素出现的次数（也就是除了循环以外的余数部分）。而这个算法还需要更进一步优化，注意到 $k$ 的值会有变化，当且仅当 $k\ge b_j$ 。在取模操作下 $k$ 至少减少减少了两倍，所以 $k$ 至多改变 $\mathcal{O}(\log a_i)$ 次。所以我们用二分找到最大的 $j$ ，使得 $k\ge b_j$ ，这样我们就可以对每个 $i$ 做到 $\mathcal{O}(\log Q\log a_i)$ 的复杂度。而用差分我们就可以做到 $\mathcal{O}(1)$ 的区间加 $t$ 。所以最终复杂度为 $\mathcal{O}(Q\log Q\log a_i+n)$ 。</p>
<p>一个小细节是，如果所有的 $b_i$ 都很大，那  $k$ 就会超过 $n$ 的范围从而 $\tt RE$ 。但单纯的把 $k$ 换成 $\min(n,k)$ 只会让 $\tt RE$ 变成 $\tt WA$ ，真正正确的做法是在所有的 $b_i$ 前面加上一个 $b_0=n$ ，这样 $k$ 就保证 $k&lt;n$ ，且不影响正确性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll a[N], t[N], q[N], b[N], stk[N]; <span class="keyword">int</span> tp;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; x, <span class="keyword">const</span> ll&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> x &lt; y ? x : y; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getpos</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, ll val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (r - l &gt; <span class="number">1</span>) mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> mid = r;</span><br><span class="line">        <span class="keyword">if</span> (b[mid] &lt; val) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, Q; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;Q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= Q + <span class="number">1</span>; ++i) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;q[i]);</span><br><span class="line">    q[<span class="number">1</span>] = n; stk[++tp] = q[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= Q + <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (tp &amp;&amp; q[i] &lt;= stk[tp]) --tp;</span><br><span class="line">        stk[++tp] = q[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tp; ++i) b[i] = stk[i];</span><br><span class="line">    t[tp] = <span class="number">1</span>; ll k, x = <span class="number">0</span>; <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = tp; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        k = b[i]; j = i; <span class="keyword">if</span> (!k) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &amp;&amp; (j = <span class="built_in">getpos</span>(<span class="number">0</span>, tp, k)))</span><br><span class="line">            t[j] += t[i] * (k / b[j]), k %= b[j];</span><br><span class="line">        a[<span class="number">1</span>] += t[i]; a[k + <span class="number">1</span>] -= t[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        x += a[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="F-Fraction-of-Fractal"><a href="#F-Fraction-of-Fractal" class="headerlink" title="F - Fraction of Fractal"></a>F - Fraction of Fractal</h4><p>给出一个 $H\times W$ 的网格图，每一格都是黑色或白色，所有的黑色是格子是四连通的，也就是说只横平竖直的移动可以使任意黑色格子之间相互到达。本题中， $\rm fractals$ 分形的定义如下：</p>
<ul>
<li>$0$ 级分形是一个 $1\times 1$ 的网格，其中唯一的格子为黑色。</li>
<li>$k+1$ 级分形是由 $H\times W$ 个 $k$ 级分形大小的网格图组成的，如果在题目中给出的网格图中，对应的位置为黑色，则该位置放上 $k$ 级分形，如果为白色，则该位置全部格子都是白色。</li>
</ul>
<p>给出整数 $k$ ，求 $k$ 级分形中，黑色格子的连通块个数，答案对 $10^9+7$ 取模。( $1\le H,W\le1000,0\le k\le10^{18}$ ，给出的网格图中至少有一个黑色格子)</p>
<p>我们称一个网格是水平连通的，当它存在一行使得这一行最左边和最右边的的格子均为黑色，称一个网格是竖直连通的当它存在一列使得这一列最上边和最下边的格子均为黑色。那当一个网格既水平连通又竖直连通，显然不管 $k$ 等于多少，所有的黑色格子一定是全部连通的，所以这种情况下答案一定是 $1$ 。当一个网格既不水平连通也不竖直连通，则每当分形等级增长时，连通块个数都会乘以 $a$ ，其中 $a$ 是题目给出的网格图中黑色格子的数量，所以答案为 $a^{k-1}$ 。</p>
<p>而对于只水平连通或者只竖直连通的情况，就比较复杂了。不失一般性，我们假设这个网格是水平连通的，但不竖直连通。对于在每个 $k-1$ 级分形中的黑色格子，我们要放一个题目中给定的网格图（分形定义的另一种表述方法），这样黑色格子的连通块个数就会 $+1$ 。但如果 $k-1$ 级分形中有两个黑色格子水平相邻的话，这两个格子对应的网格就会在同一个连通块内了。所以答案就是 $a-b$ ，其中 $a$ 是题目给出的网格图中黑色格子的数量，$b$ 是水平相邻的黑色格子对数。</p>
<p>但注意到 $k$ 非常大，加上这个递推的形式，可以想到列出  $\rm dp$ 式子，然后用矩阵快速幂来优化一下。我们设 $f_i$ 表示 $i$ 级分形的答案，$s_i$ 表示 $i$ 级分形最左列和最右列的连通块个数。则 $f_i=af_i-bs_{i-1}$ ，$s_i=cs_{i-1}$ （其中 $a$ 是题目给出的网格图中黑色格子的数量，$b$ 是水平相邻的黑色格子对数，$c$ 是满足最左端和最右端均为黑色的行数）。根据这个状态转移方程，我们有 $\begin{pmatrix}a&amp;-b\\0&amp;c\end{pmatrix}\begin{pmatrix}f_i\\s_i\end{pmatrix}=\begin{pmatrix}f_{i+1}\\s_{i+1}\end{pmatrix}$ ，所以最终答案就是 $\begin{pmatrix}f_k\\s_k\end{pmatrix}=\begin{pmatrix}a&amp;-b\\0&amp;c\end{pmatrix}^{k-1}\begin{pmatrix}f_1\\s_1\end{pmatrix}$ ，其中 $f_1=s_1=1$ 。</p>
<p>对于只竖直连通的情况，只需要把所有定义倒转一下就好，最终时间复杂度为统计的 $\mathcal{O}(HW)$ ，加上计算的 $\mathcal{O}(\log k)$ ，即 $\mathcal{O}(\log k+HW)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">10</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> n, m; ll a[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line">    Matrix <span class="keyword">operator</span>*(<span class="keyword">const</span> Matrix&amp; X)</span><br><span class="line">    &#123;</span><br><span class="line">        Matrix ret;</span><br><span class="line">        ret.n = n; ret.m = X.m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ret.n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= ret.m; ++j)</span><br><span class="line">                ret.a[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= X.m; ++j)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= m; ++k)</span><br><span class="line">                    ret.a[i][j] = </span><br><span class="line">                    ((ret.a[i][j] + a[i][k] * X.a[k][j] % mod)</span><br><span class="line">                    % mod + mod) % mod;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;A, B, I;</span><br><span class="line"><span class="function">Matrix <span class="title">fpow</span><span class="params">(Matrix A, ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Matrix ret = I;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) ret = ret * A;</span><br><span class="line">        A = A * A;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> a, ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) ret = <span class="number">1ll</span> * ret * a % mod;</span><br><span class="line">        a = <span class="number">1ll</span> * a * a % mod;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//0:vertically connected, 1:horizontally connected</span></span><br><span class="line"><span class="keyword">char</span> mp[N][N]; <span class="keyword">int</span> a, b[<span class="number">2</span>], c[<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> tag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A.n = A.m = I.n = I.m = <span class="number">2</span>;</span><br><span class="line">    I.a[<span class="number">1</span>][<span class="number">1</span>] = I.a[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    A.a[<span class="number">1</span>][<span class="number">1</span>] = a; A.a[<span class="number">1</span>][<span class="number">2</span>] = -b[tag];</span><br><span class="line">    A.a[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">0</span>; A.a[<span class="number">2</span>][<span class="number">2</span>] = c[tag];</span><br><span class="line">    B.n = <span class="number">2</span>; B.m = <span class="number">1</span>;</span><br><span class="line">    B.a[<span class="number">1</span>][<span class="number">1</span>] = B.a[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; ll k; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, mp[i] + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            <span class="keyword">if</span> (mp[i][j] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ++a;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">1</span>) b[<span class="number">0</span>] += (mp[i][j - <span class="number">1</span>] == <span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">1</span>) b[<span class="number">1</span>] += (mp[i - <span class="number">1</span>][j] == <span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        c[<span class="number">0</span>] += (mp[i][<span class="number">1</span>] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; mp[i][m] == <span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        c[<span class="number">1</span>] += (mp[<span class="number">1</span>][i] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; mp[n][i] == <span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">    <span class="comment">//vertically connected and horizontally connected</span></span><br><span class="line">    <span class="keyword">if</span> (c[<span class="number">0</span>] &amp;&amp; c[<span class="number">1</span>]) &#123; <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="comment">//not vertically connected and not horizontally connected</span></span><br><span class="line">    <span class="keyword">if</span> (!c[<span class="number">0</span>] &amp;&amp; !c[<span class="number">1</span>])</span><br><span class="line">    &#123; <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">fpow</span>(a, k - <span class="number">1</span>)); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="comment">//tag = 1 if c[1]&gt;0, 0 if c[1]=0</span></span><br><span class="line">    <span class="keyword">int</span> tag = !!c[<span class="number">1</span>]; <span class="built_in">init</span>(tag);</span><br><span class="line">    B = <span class="built_in">fpow</span>(A, k - <span class="number">1</span>) * B;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, B.a[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="知识经验总结"><a href="#知识经验总结" class="headerlink" title="知识经验总结"></a>知识经验总结</h3><ol>
<li>题目中如果给出了一些不寻常的操作，考虑把不寻常的操作转化为熟悉的样子，比如反转相邻的 $3$ 个元素就可以视为交换相隔的 $2$ 个元素，还可以视为在下标奇偶性相同的子序列中交换相邻元素。</li>
<li>对于子序列选取问题，除了 $\rm dp$ 枚举选或者不选，如果条件是两两冲突，可以考虑对于每个数，找到与它权值相同的数，和与该权值冲突的数，二者取较大的集合就可以。</li>
<li>对于满足明显递推关系，且递推层数较大的题目，想到找规律或者矩阵快速幂优化。</li>
</ol>
<p>ps. 这套题目思维难度较大（尤其是 E 题那道神仙题），很难总结出较多的经验，只能说锻炼思维了吧。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhiyangfan1234.github.io/2022/01/24/AtCoder%20Grand%20Contest%20005/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhiyangfan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhiyangfan 的博客小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/24/AtCoder%20Grand%20Contest%20005/" class="post-title-link" itemprop="url">AtCoder Grand Contest 005</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-01-24 17:00:23 / 修改时间：17:11:26" itemprop="dateCreated datePublished" datetime="2022-01-24T17:00:23+08:00">2022-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="AtCoder-Grand-Contest-005-补题总结"><a href="#AtCoder-Grand-Contest-005-补题总结" class="headerlink" title="AtCoder Grand Contest 005 补题总结"></a>AtCoder Grand Contest 005 补题总结</h2><p>之前做的，忘了订题写总结，但看到 A 题的 WA 我就瞬间想起来我在 A 题卡了五分钟的痛苦了。</p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="A-STring"><a href="#A-STring" class="headerlink" title="A - STring"></a>A - STring</h4><p>给出一个长度为偶数的字符串 $X$，一般的字符是 <code>S</code>，另一半是 <code>T</code>。现在要进行以下操作 $10^{10000}$ 次：</p>
<ul>
<li>去掉最左端的子串 <code>ST</code>，如果没有 <code>ST</code> 这个子串就什么都不做。</li>
</ul>
<p>问这么多次操作后 $X$ 的最终长度。($2\le |X|\le2\times10^5$)</p>
<p>记录一下当前连续 <code>S</code> 个数（去掉 <code>ST</code> 后的连续也算连续），然后直接匹配即可，时间复杂度 $\mathcal{O}(|X|)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>; <span class="keyword">char</span> s[N]; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>); <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s + <span class="number">1</span>), len = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!len &amp;&amp; s[i] == <span class="string">&#x27;T&#x27;</span>) ++ans;</span><br><span class="line">		<span class="keyword">if</span> (s[i] == <span class="string">&#x27;S&#x27;</span>) ++len;</span><br><span class="line">		<span class="keyword">if</span> (len &amp;&amp; s[i] == <span class="string">&#x27;T&#x27;</span>) --len;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans + len); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="B-Minimum-Sum"><a href="#B-Minimum-Sum" class="headerlink" title="B - Minimum Sum"></a>B - Minimum Sum</h4><p>给出一个长为 $n$ 的排列 $\mathcal{P}_1,\mathcal{P}_2,\cdot\cdot\cdot,\mathcal{P}_n$，求：</p>
<script type="math/tex; mode=display">\sum_{l=1}^n\sum_{r=l}^n \min\{\mathcal{P}_l,\mathcal{P}_{l+1},\cdot\cdot\cdot\mathcal{P}_r\}</script><p>($1\le n\le2\times10^5$)</p>
<p>比较经典的问题了。考虑用单调栈维护 $\mathcal{P}_i$ 作为最小值的区间 $(l_i,r_i)$，然后我们分别考虑每个点的贡献。最终答案即为：</p>
<script type="math/tex; mode=display">\sum_{i=1}^n \mathcal{P}_i\times(i-l_i)\times(r_i-i)</script><p>时间复杂度 $\mathcal{O}(n)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>; </span><br><span class="line"><span class="keyword">int</span> a[N], lef[N], rig[N]; std::stack&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">	st.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; a[st.<span class="built_in">top</span>()] &gt; a[i])</span><br><span class="line">			rig[st.<span class="built_in">top</span>()] = i, st.<span class="built_in">pop</span>();</span><br><span class="line">		st.<span class="built_in">push</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) rig[st.<span class="built_in">top</span>()] = n + <span class="number">1</span>, st.<span class="built_in">pop</span>();</span><br><span class="line">	st.<span class="built_in">push</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; a[st.<span class="built_in">top</span>()] &gt; a[i])</span><br><span class="line">			lef[st.<span class="built_in">top</span>()] = i, st.<span class="built_in">pop</span>();</span><br><span class="line">		st.<span class="built_in">push</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) lef[st.<span class="built_in">top</span>()] = <span class="number">0</span>, st.<span class="built_in">pop</span>();</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		ans += <span class="number">1ll</span> * a[i] * (i - lef[i]) * (rig[i] - i);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="C-Tree-Restoring"><a href="#C-Tree-Restoring" class="headerlink" title="C - Tree Restoring"></a>C - Tree Restoring</h4><p>给出一个长为 $n$ 的序列 $a$，要求构造出一棵树，其中对于第 $i$ 个结点，它和距离它最远结点的距离为 $a_i$。（边权均为 $1$）询问这样的树是否存在。($2\le n\le100,1\le a_i\le n-1$)</p>
<p>约定 $dis_{u,v}$ 表示树上 $u,v$ 两点之间的距离。注意到根据题意，如果存在这样一棵树，则它的直径一定为 $\max\{a_i\}$，我们设直径的端点为 $x,y$，则对于任意结点 $u$，显然有：</p>
<script type="math/tex; mode=display">\max_{i=1}^n\{dis_{i,u}\}=a_u=\max\{dis_{i,x},dis_{i,y}\}</script><p>证明可以参考两遍 $\rm dfs$ 求直径方法正确性的证明。则如果我们设直径的长度为 $k$，直径上有 $k+1$ 个点，则根据上面的性质，对于直径上每个点的 $a$，我们显然有如下结论：</p>
<ul>
<li>如果 $k$ 为偶数，则 $a$ 对应的值应为 $\{k,k-1,\cdot\cdot\cdot,\frac{k}{2}+1,\frac{k}{2},\frac{k}{2}+1,\cdot\cdot\cdot,k-1,k\}$。</li>
<li>如果 $k$ 为奇数，则 $a$ 对应的值应为 $\{k,k-1,\cdot\cdot\cdot,\frac{k+1}{2}+1,\frac{k+1}{2},\frac{k+1}{2},\frac{k+1}{2}+1,\cdot\cdot\cdot,k-1,k\}$。</li>
</ul>
<p>则对于给出的数据，我们可以先去掉满足这些条件的值，也就是直径上的点对应的 $a$，如果无法完成，则不存在这样的树。而对于去掉之后剩余的点 $u$，如果 $k$ 为偶数，则 $a_u$ 应至少为 $\frac{k}{2}+1$，如果为奇数，则至少为 $\frac{k+1}{2}+1$。（可以通过直接接到直径的中点达到最小值，而只需要选路径上一个合适的点加一个相邻的点就能构造出剩下的情况了）我们只需要看一下剩下的 $a_u$ 是否都满足以上条件即可。时间复杂度 $\mathcal{O}(n)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> f[<span class="number">200</span>], a[<span class="number">200</span>], Max, Min = <span class="number">200</span>, n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> Max)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = (Max + <span class="number">1</span>) / <span class="number">2</span> + <span class="number">1</span>; i &lt;= Max; ++i)</span><br><span class="line">		<span class="keyword">if</span> (f[i] &lt; <span class="number">2</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;Impossible\n&quot;</span>); <span class="keyword">return</span> ; &#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Possible\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]); ++f[a[i]];</span><br><span class="line">		Max = std::<span class="built_in">max</span>(Max, a[i]);</span><br><span class="line">		Min = std::<span class="built_in">min</span>(Min, a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (Min &lt; (Max + <span class="number">1</span>) / <span class="number">2</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;Impossible\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">	<span class="keyword">if</span> (Max &amp; <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (f[(Max + <span class="number">1</span>) / <span class="number">2</span>] != <span class="number">2</span>) </span><br><span class="line">		&#123; <span class="built_in">printf</span>(<span class="string">&quot;Impossible\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">		<span class="built_in">check</span>(Max);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (f[Max / <span class="number">2</span>] != <span class="number">1</span>) </span><br><span class="line">		&#123; <span class="built_in">printf</span>(<span class="string">&quot;Impossible\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">		<span class="built_in">check</span>(Max);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="D-K-Perm-Counting"><a href="#D-K-Perm-Counting" class="headerlink" title="D - ~K Perm Counting"></a>D - ~K Perm Counting</h4><p>我们定义一个长度为 $n$ 的排列 $\mathcal{P}$ 是好的，当且仅当对于所有所有 $1\le i\le n$，都有 $|\mathcal{P_i}-i|\ne k$，其中 $k$ 为给定常数。问在所有可能的 $n!$ 个排列中，有多少排列是好的，答案对 $924,844,033$ 取模。($2\le n\le2\times10^3,1\le k\le n-1$)</p>
<p>考虑用一个二分图去对应这个排列，即左部点 $\{L_1,L_2,\cdot\cdot\cdot,L_n\}$ 和右部点 $\{R_1,R_2,\cdot\cdot\cdot,R_n\}$ 组成的二分图，显然图上的一个完美匹配会对应一个排列，具体来讲，排列 $\mathcal{P}$ 会对应边集 $\{(L_i,R_{\mathcal{P}_i})\}$。而本题的目标就是求不用边集 $\{(L_i,R_{i+k})\}$ 和 $\{(L_i,R_{i-k})\}$ 中的边能形成的完美匹配个数。</p>
<p>好了，我们一看「不用」这个字眼已经可以考虑容斥了。考虑设 $M_i$ 表示钦定 $i$ 个 $L_i$ 连出去的边在那两个边集内，则最终答案即为：</p>
<script type="math/tex; mode=display">\sum_{i=0}^n (-1)^iM_i(n-i)!</script><p>其中前面是简单的容斥，$(n-i)!$ 是因为除了那些匹配其他随便选。接下来问题就变为了求出 $M_i$。这个就比较简单了，可以直接 $\mathcal{O}(n^2)$ 递推解决（如果不会了的话去看洛谷题解第一篇，感觉会比我写下来清楚），利用多项式科技还可以达到 $\mathcal{O}(n\log n)$ 的复杂度，但比较复杂。这里实现的是 $\mathcal{O}(n^2)$ 的 $\rm dp$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e3</span> + <span class="number">10</span>, mod = <span class="number">924844033</span>; <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n, k, ans, tot, a[N], fac[N], f[N &lt;&lt; <span class="number">1</span>][N][<span class="number">2</span>], vis[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k); fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fac[i] = (ll)fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; <span class="number">2</span>; ++t)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j += k) ++tot, (i != j) ? (vis[tot] = <span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= (n &lt;&lt; <span class="number">1</span>); ++i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; ++j)</span><br><span class="line">		&#123;	</span><br><span class="line">			<span class="keyword">if</span> (vis[i] &amp;&amp; j) f[i][j][<span class="number">1</span>] = f[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">			f[i][j][<span class="number">0</span>] = (f[i - <span class="number">1</span>][j][<span class="number">0</span>] + f[i - <span class="number">1</span>][j][<span class="number">1</span>]) % mod;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (i &amp; <span class="number">1</span>) ans = (ans - (ll)fac[n - i] * (f[n &lt;&lt; <span class="number">1</span>][i][<span class="number">0</span>] + f[n &lt;&lt; <span class="number">1</span>][i][<span class="number">1</span>]) + mod) % mod;</span><br><span class="line">		<span class="keyword">else</span> ans = (ans + (ll)fac[n - i] * (f[n &lt;&lt; <span class="number">1</span>][i][<span class="number">0</span>] + f[n &lt;&lt; <span class="number">1</span>][i][<span class="number">1</span>])) % mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans); <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="E-Sugigma-The-Showdown"><a href="#E-Sugigma-The-Showdown" class="headerlink" title="E - Sugigma: The Showdown"></a>E - Sugigma: The Showdown</h4><p>两个人在一棵 $n$ 个结点的图上做游戏，一开始先手的棋子在 $X$，后手的棋子在 $Y$。这张图上有 $n-1$ 条蓝边和 $n-1$ 条红边。每种颜色的边和图上的 $n$ 个点都构成一棵树。先后手轮流操作，每次操作先手可以把棋子移动到一个由红边连接的相邻结点或选择不动，后手可以把棋子移动到一个由蓝边连接的相邻结点或选择不动，当两个棋子相遇时游戏结束。先手的目标是最大化游戏轮次，后手的目标是最小化游戏轮次，问在二人都采取最优策略的情况下，游戏的轮数是否有限，如果有限，求出游戏轮数。($2\le n\le2\times10^5$)</p>
<p>神仙博弈论Orz。首先我们先来解释一下题意，先后手各有一棵点集相同的树，先手从 $X$ 出发使用红树尝试逃脱后手从 $Y$ 出发使用蓝树的追捕。约定 $dis_r(u,v)$ 表示在红树上 $u,v$ 点之间的距离，$dis_b(u,v)$ 表示在蓝树上 $u,v$ 点之间的距离。如果存在这样的 $u,v$ 满足 $dis_r(u,v)=1$ 且 $dis_b(u,v)\ge3$，则当先手到达 $u,v$ 中的任意一个结点且后手不能在这之后立即抓到他，游戏就可以一直进行下去了，即先手就可以一直逃脱后手的抓捕了。不妨设先手到的是 $u$，则他可以一直在那等直到后手追到一个与 $u$ 在蓝树上相邻的结点 $x$，这时他就会去 $v$，而因为 $dis_b(x,u)=1,dis_b(u,v)\ge3$，所以有 $dis_b(x,v)\ge 2$，后手不能一步追上先手。之后先手就可以一直这样在 $u,v$ 之间反复横跳来逃避抓捕，所以此时游戏轮数是无限的。我们称 $u,v$ 之间的红边为长边。</p>
<p>有了这个结论后，我们再来审视一下原题面给出的树。我们把蓝树考虑为一棵以 $Y$ 为根的有根树，而其中长边两端的点是特殊的，因为如果先手到达这些点且后手不能立即捉到他游戏就会无限进行，除了长边，红边还有短边，满足 $dis_r(u,v)=1,dis_b(u,v)\le 2$。我们可以把这些红边看做一次跳跃，现在问题就变为了在一棵有根树上的问题，先手在这些短边上跳跃尝试去走到特殊点或尝试去逃离后手的抓捕。一个非常重要的发现是，先手永远不会跳过后手，因为跳跃的最远距离是 $2$，所以最后到达的点一定会和后手相邻，下一轮就会被抓到。也就是说，先手一定会一直在后手所在的子树内。显然后手的最优策略是一直朝着先手的方向往下走，而如果这样先手一旦到达一个满足 $dis_b(Y,x)\le t$ 的结点 $x$ 用了 $t$ 步，就会被抓到。反之，如果先手一直尽量保持 $dis_b(Y,x)&gt;t$ 就不会被抓住，这就是他的最优策略。</p>
<p>这样，游戏就可以理解为先手的单人游戏了。他到达的第 $i$ 个结点 $u_i$（$u_0=X$）应满足 $dis_b(u_i,Y)&gt;i$，在这个限制下，如果他能到达某个特殊结点则游戏轮数就为无限，否则答案即为可能的路径中的最长路径长度。这些都可以用一次 $\rm dfs$ 求出，时间复杂度 $\mathcal{O}(n)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>; std::vector&lt;<span class="keyword">int</span>&gt; R[N], B[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span> <span class="keyword">int</span> u, v; &#125;e[N]; <span class="keyword">int</span> n, x, y, ans, depr[N], depb[N], fa[N], vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfsB</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	fa[u] = f;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, v; i &lt; B[u].<span class="built_in">size</span>(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		v = B[u][i]; <span class="keyword">if</span> (v == f) <span class="keyword">continue</span>;</span><br><span class="line">		depb[v] = depb[u] + <span class="number">1</span>; <span class="built_in">dfsB</span>(v, u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfsR</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (vis[u]) <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>), <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	ans = std::<span class="built_in">max</span>(ans, depb[u]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, v; i &lt; R[u].<span class="built_in">size</span>(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		v = R[u][i]; <span class="keyword">if</span> (v == f) <span class="keyword">continue</span>;</span><br><span class="line">		depr[v] = depr[u] + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (depr[v] &lt; depb[v]) <span class="built_in">dfsR</span>(v, u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (depb[u] &lt; depb[v]) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">	<span class="keyword">if</span> (depb[u] == depb[v]) </span><br><span class="line">	&#123;	</span><br><span class="line">		<span class="keyword">if</span> (fa[u] != fa[v]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (depb[u] == depb[v] + <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (fa[u] != v) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (depb[u] == depb[v] + <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (fa[fa[u]] != v) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;x, &amp;y);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">		R[u].<span class="built_in">push_back</span>(v); R[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">		e[i].u = u; e[i].v = v;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">		B[u].<span class="built_in">push_back</span>(v); B[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfsB</span>(y, y);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		u = e[i].u; v = e[i].v;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">check</span>(u, v)) vis[u] = vis[v] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfsR</span>(x, x); <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans &lt;&lt; <span class="number">1</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="F-Many-Easy-Problems"><a href="#F-Many-Easy-Problems" class="headerlink" title="F - Many Easy Problems"></a>F - Many Easy Problems</h4><p>给出一棵 $n$ 个结点的无根树，我们定义 $f_i$ 表示对于所有大小为 $i$ 的点集，能包含住它的最小连通块大小之和。对于 $1\le i\le n$ 求出 $f_i$，答案对 $924,844,033$ 取模。($2\le n\le2\times10^5$)</p>
<p>这题有三处非常神仙的转化。我们要发现直接求是无法求的，要考虑每个结点 $u$ 对 $f_i$ 的贡献，而且还需要一点补集转化。也就是选择的总方案数减去没 $u$ 的事的方案。显然当选中的所有结点均在 $u$ 的一个子树内时没 $u$ 的事，所以 $u$ 对 $f_i$ 的贡献即为 $\binom{n}{i}-\sum_{v\in son_u}\binom{sz_v}{i}$，其中 $sz_v$ 表示以 $v$ 为根的子树大小。则 $f_i$ 就可以表示为：</p>
<script type="math/tex; mode=display">\begin{aligned}f_i&=\sum_{u=1}^n\left(\dbinom{n}{i}-\sum_{v\in son_u}\dbinom{sz_v}{i}\right)\\&=n\dbinom{n}{i}-\sum_{u=1}^n\sum_{v\in son_u}\dbinom{sz_v}{i}\end{aligned}</script><p>前面那一项已经可以 $\mathcal{O}(1)$ 求了，但想求后面那项还得费点功夫。发现后面其实就是统计所有子树的大小，所以我们考虑设 $cnt_i$ 表示大小为 $i$ 的子树数量的个数，注意这里包括上文的 $u$ 的子树意义为以 $u$ 为根时。则 $f_i$ 又可以转化为：</p>
<script type="math/tex; mode=display">\begin{aligned}f_i&=n\dbinom{n}{i}-\sum_{j=i}^n cnt_j\dbinom{j}{i}\\&=n\dbinom{n}{i}-\dfrac{1}{i!}\sum_{j=i}^n \dfrac{cnt_j\times j!}{(j-i)!}\end{aligned}</script><p>这里后面又没法搞了，还是需要一点转化，考虑设 $F_i=cnt_i\times i!,G_i=\dfrac{1}{i!}$，则 $f_i$ 为：</p>
<script type="math/tex; mode=display">\begin{aligned}f_i&=n\dbinom{n}{i}-\dfrac{1}{i!}\sum_{j=i}^n F_jG_{j-i}\\&=n\dbinom{n}{i}-\dfrac{1}{i!}\sum_{j=0}^{n-i}F_{i+j}G_j\end{aligned}</script><p>后面已经非常非常接近卷积了，我们只需要令 $H_i=F_{n-i}$，就有：</p>
<script type="math/tex; mode=display">f_i=n\dbinom{n}{i}-\dfrac{1}{i!}\sum_{j=0}^{n-i} H_{n-i-j}G_j</script><p>搞定，后面已经是卷积的形式了。可以直接上 $\rm NTT$ 了，但注意题目给的质数不是常见的 $998,244,353$ 而是 $924,844,033$，不过差不多，只是要注意题目里的这个原根是 $5$。卷出来之后直接套式子就能得到答案了，时间复杂度 $\mathcal{O}(n\log n)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>, mod = <span class="number">924844033</span>; <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span> <span class="keyword">int</span> v, next; &#125;E[N &lt;&lt; <span class="number">1</span>]; <span class="keyword">int</span> p[N], tot;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(p, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span> (p)); tot = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123; E[tot].v = v; E[tot].next = p[u]; p[u] = tot++; &#125;</span><br><span class="line"><span class="keyword">int</span> cnt[N], size[N], fac[N], ifac[N], rev[N &lt;&lt; <span class="number">2</span>], F[N &lt;&lt; <span class="number">2</span>], G[N &lt;&lt; <span class="number">2</span>], n;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ksm</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = (ll)ret * a % mod;</span><br><span class="line">		a = (ll)a * a % mod; b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	size[u] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = p[u], v; i + <span class="number">1</span>; i = E[i].next)</span><br><span class="line">	&#123;</span><br><span class="line">		v = E[i].v; <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(v, u); size[u] += size[v]; ++cnt[size[v]];</span><br><span class="line">	&#125;</span><br><span class="line">	++cnt[n - size[u]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123; <span class="keyword">return</span> (ll)fac[n] * ifac[m] % mod * ifac[n - m] % mod; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span>* c, <span class="keyword">int</span> len, <span class="keyword">int</span> on)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">		<span class="keyword">if</span> (i &lt; rev[i]) std::<span class="built_in">swap</span>(c[i], c[rev[i]]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">2</span>; h &lt;= len; h &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> gn = <span class="built_in">ksm</span>(<span class="number">5</span>, (mod - <span class="number">1</span>) / h); <span class="keyword">if</span> (on == <span class="number">-1</span>) gn = <span class="built_in">ksm</span>(gn, mod - <span class="number">2</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j += h)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> g = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; j + h / <span class="number">2</span>; ++k, g = (ll)g * gn % mod)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> u = c[k], t = (ll)g * c[k + h / <span class="number">2</span>] % mod;</span><br><span class="line">				c[k] = (u + t) % mod; c[k + h / <span class="number">2</span>] = (u - t + mod) % mod;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (on == <span class="number">-1</span>) &#123; <span class="keyword">int</span> inv = <span class="built_in">ksm</span>(len, mod - <span class="number">2</span>); <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) c[i] = (ll)c[i] * inv % mod; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="built_in">init</span>(); <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y), <span class="built_in">insert</span>(x, y), <span class="built_in">insert</span>(y, x);</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>); fac[<span class="number">0</span>] = ifac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fac[i] = (ll)fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">	ifac[n] = <span class="built_in">ksm</span>(fac[n], mod - <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i) ifac[i] = (ll)ifac[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) F[i] = (ll)cnt[i] * fac[i] % mod;</span><br><span class="line">	std::<span class="built_in">reverse</span>(F, F + n + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) G[i] = ifac[i];</span><br><span class="line">	<span class="keyword">int</span> limit = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (limit &lt;= (n &lt;&lt; <span class="number">1</span>)) limit &lt;&lt;= <span class="number">1</span>, ++l;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; ++i) rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l - <span class="number">1</span>));</span><br><span class="line">	<span class="built_in">NTT</span>(F, limit, <span class="number">1</span>); <span class="built_in">NTT</span>(G, limit, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; ++i) F[i] = (ll)F[i] * G[i] % mod;</span><br><span class="line">	<span class="built_in">NTT</span>(F, limit, <span class="number">-1</span>); std::<span class="built_in">reverse</span>(F, F + n + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (<span class="keyword">int</span>)(((ll)n * <span class="built_in">C</span>(n, i) % mod - (ll)ifac[i] * F[i] % mod + mod) % mod));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhiyangfan1234.github.io/2022/01/24/AtCoder%20Grand%20Contest%20007/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhiyangfan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhiyangfan 的博客小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/24/AtCoder%20Grand%20Contest%20007/" class="post-title-link" itemprop="url">AtCoder Grand Contest 007</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-01-24 17:00:23 / 修改时间：17:11:40" itemprop="dateCreated datePublished" datetime="2022-01-24T17:00:23+08:00">2022-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="AtCoder-Grand-Contest-007-补题总结"><a href="#AtCoder-Grand-Contest-007-补题总结" class="headerlink" title="AtCoder Grand Contest 007 补题总结"></a>AtCoder Grand Contest 007 补题总结</h2><p>感觉题开始难起来了呀，最后压线才把 A,B,D 写完，而且还罚时一堆/kk。</p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="A-Shik-and-Stone"><a href="#A-Shik-and-Stone" class="headerlink" title="A - Shik and Stone"></a>A - Shik and Stone</h4><p>给出一个 $h$ 行 $w$ 列的方格，现在从 $(1,1)$ 走到 $(h,w)$，可以上下左右走且能重复经过格子。给出一个表格表示路径，其中格子是 <code>#</code> 表示经过了，<code>.</code> 表示没经过。问能否只通过向下和向右走构造出这样的路径，数据保证给出的表格合法，即存在一条走出来的路径。($2\le h,w\le8$)</p>
<p>这题可以爆搜做，但是细节比较多，容易写挂（对就是我），所以我们考虑找一些结论。注意到只向下和向右走的话是不能经过重复方格的，且每一步就要移动一步且仅移动一步，所以可以大胆猜想一个结论：如果最后存在这样一条路径，则表格中的 <code>#</code> 数量一定恰好为 $h+w-1$。必要性显然，那充分性呢？注意到一定存在一条从 $(1,1)$ 到 $(h,w)$ 的路径，所以只要走且仅走了 $h+w-1$ 步就一定能构造出来这样的路径，所以可以直接用这个结论做，时间复杂度 $\mathcal{O}(hw)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> mp[<span class="number">10</span>][<span class="number">10</span>]; <span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m); <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, mp[i] + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) sum += (mp[i][j] == <span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, sum == n + m - <span class="number">1</span> ? <span class="string">&quot;Possible&quot;</span> : <span class="string">&quot;Impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="B-Construct-Sequences"><a href="#B-Construct-Sequences" class="headerlink" title="B - Construct Sequences"></a>B - Construct Sequences</h4><p>给出一个 $1\sim n$ 的排列 $p$，要求构造出满足以下条件的两组序列 $a=\langle a_1,a_2,\cdot\cdot\cdot,a_n\rangle,b=\langle b_1,b_2,\cdot\cdot\cdot,b_n\rangle$：</p>
<ul>
<li>$\forall 1\le i\le n$ 有 $1\le a_i,b_i\le10^9$</li>
<li>$a_1&lt;a_2&lt;\cdot\cdot\cdot&lt;a_n$</li>
<li>$b_1&gt;b_2&gt;\cdot\cdot\cdot&gt;b_n$</li>
<li>$a_{p_1}+b_{p_1}&lt;a_{p_2}+b_{p_2}&lt;\cdot\cdot\cdot&lt;a_{p_n}+b_{p_n}$</li>
</ul>
<p>($2\le n\le2\times10^4$)</p>
<p>说句题外话，这道题我因为看错 $n$ 的数据范围 $\tt RE$ 了一发…  既然面对题目给的条件不知所云，我们不如首先考虑一下如何让 $a_{p_1}+b_{p_1}=a_{p_2}+b_{p_2}=\cdot\cdot\cdot=a_{p_n}+b_{p_n}$，之后再微调一下说不定就出来了。一个很显然的思路就是令 $a_i=i,b_i=n-i$，这样既满足 $a$ 严格递增，$b$ 严格递减，也满足任意一对 $a_i,b_i$ 加起来是定值。接下来考虑微调，一个最最最初步的想法是给 $a_{p_i}$ 或者 $b_{p_i}$ 加上一个 $i$（为了方便之后我们后面都选择给 $b_{p_i}$ 加），这样就能做到题目要求的严格递增了。但问题又来了，这样一加就可能会破坏 $b$ 序列的严格递减性。这没有关系，考虑让 <strong>使得 $b_i$ 单调递减的因素占在整个 $b_i$ 的大小中的主要地位</strong> 即可。具体来讲，我们可以给 $n-i$ 这一部分加上一个很大的因子 $k$ （为了满足加和一定的性质 $a_i$ 上的 $i$ 也要加），这样就 $b$ 的严格递减性就不会被轻易破坏了。总结一下就是，构造 $a_i=ki,b_i=k(n-i)+q_i$，其中 $q_i=j$ 当且仅当 $p_j=i$，而 $k$ 只需要选到大于 $n$ 即可，最终时间复杂度 $\mathcal{O}(n)$。这也就是为啥这题明明是线性复杂度而题目却给了这么小一个 $n$ 的理由，因为要保证 $a_i,b_i$ 不超值域嘛。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e4</span> + <span class="number">10</span>; <span class="keyword">int</span> p[N], a[N], b[N], rk[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n); <span class="keyword">int</span> k = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p[i]), rk[p[i]] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = k * i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) b[i] = k * (n - i + <span class="number">1</span>) + rk[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]); <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i]); <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="C-Pushing-Balls"><a href="#C-Pushing-Balls" class="headerlink" title="C - Pushing Balls"></a>C - Pushing Balls</h4><p>一条线上有 $n$ 个球和 $n+1$ 个洞，初始状态下第 $i$ 个球在第 $i$ 个和第 $i+1$ 个洞之间。我们令两个相邻物品之间的距离为 $d_i(1\le i\le 2n)$，则我们可以给出 $d_1$ 和 $x$ 来描述这个序列：$\forall 2\le i\le 2n$ 都有 $d_i-d_{i-1}=x$。现在我们想进行 $n$ 轮操作使得所有球进洞，对于每一轮操作，我们随机选择一个球，并随机选择左右方向推动这个球，这个球会进入它被推动的方向上第一个没有球的洞。求出 $n$ 轮操作后所有球的移动距离和的期望大小。($1\le n\le2\times10^5,1\le d_1\le100,0\le x\le100$)</p>
<p>有一说一，这题考场 AC 比 D 少，为啥 C 题会存在这样的神题啊？首先发现 $d$ 序列初始时是个等差数列，想到可以从这点入手去推一推式子。而又发现每次推完球我们得到的是一个球和洞各少了一个的子问题，所以考虑推球前后问题的相似性。一共有 $2n$ 种推球的可能性，考虑哪种情况下会对 $d_i$ 期望长度增加产生贡献：</p>
<ul>
<li>被推动的球经过的是前 $i$ 段距离之中的一段（注意这里的第 $i$ 个距离跟第 $i$ 个球的区别，第 $i$ 个球有可能经过第 $i$ 个路径，也有可能经过第 $i+1$ 个路径），比如经过了第 $k$ 段，则会导致距离 $k$ 与它相邻的那一段距离消失，而第 $i$ 段也会被第 $i+2$ 段取代，所以这种情况下的增加的期望长度为 $i\times(d_{i+2}-d_i)$</li>
<li>被推动的球经过的是第 $i+1$ 段路径，则第 $i,i+2,i+3$ 段会合并为新的第 $i$ 段，所以增加的期望长度为 $d_{i+2}+d_{i+3}$</li>
</ul>
<p>最终，每一轮后，$d_i$ 增加的期望长度为：$\dfrac{i\times(d_{i+2}-d_i)+(d_{i+2}+d_{i+3})}{2n}$，所以新一轮的 $d_i’$ 即为</p>
<script type="math/tex; mode=display">d_i'=d_i+\dfrac{i\times(d_{i+2}-d_i)+(d_{i+2}+d_{i+3})}{2n}=d_i+\dfrac{i\times 2x+2d+5x}{2n}</script><p>可以观察到，这形成了一个新的等差数列。而每次推球的期望长度是 $d_i$ 的中位数，即 $d_1+x\times \dfrac{2n-1}{2}$，这样每次递推更新公差为 $x+\dfrac{2x}{n}$，初始值为 $d_1+\dfrac{2d_1+5x}{2n}$（这里不加那个 $i\times 2x$ 是因为在更新公差时算上了），$\mathcal{O}(n)$ 递推即可。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="keyword">double</span> d, x; <span class="built_in">scanf</span>(<span class="string">&quot;%d%lf%lf&quot;</span>, &amp;n, &amp;d, &amp;x);</span><br><span class="line">    <span class="keyword">double</span> ans = <span class="number">0</span>; <span class="keyword">int</span> n2 = (n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ans += d + x * (n2 - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        d += (<span class="number">2</span> * d + <span class="number">5</span> * x) / n2;</span><br><span class="line">        x += <span class="number">4</span> * x / n2; n2 -= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.10lf\n&quot;</span>, ans); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="D-Shik-and-Game"><a href="#D-Shik-and-Game" class="headerlink" title="D - Shik and Game"></a>D - Shik and Game</h4><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhiyangfan1234.github.io/2022/01/24/AtCoder%20Grand%20Contest%20006/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhiyangfan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhiyangfan 的博客小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/24/AtCoder%20Grand%20Contest%20006/" class="post-title-link" itemprop="url">AtCoder Grand Contest 006</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-01-24 17:00:23 / 修改时间：17:11:23" itemprop="dateCreated datePublished" datetime="2022-01-24T17:00:23+08:00">2022-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="AtCoder-Grand-Contest-006补题总结"><a href="#AtCoder-Grand-Contest-006补题总结" class="headerlink" title="AtCoder Grand Contest 006补题总结"></a>AtCoder Grand Contest 006补题总结</h2><p><del>突然发现 AGC004,AGC005 不知道为啥被我跳过去了，还得回头补。</del>  这把的难度就感觉比之前的 CODE FESITIVAL 要大，我只做到 C 题。</p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="A-Prefix-and-Suffix"><a href="#A-Prefix-and-Suffix" class="headerlink" title="A - Prefix and Suffix"></a>A - Prefix and Suffix</h4><p>给出两个长为 $n$ 的字符串 $s,t$，求出满足前 $n$ 个字符为 $s$，后 $n$ 个字符为 $t$ 的字符串中长度最小的字符串长为多少。($1\le n\le100$)</p>
<p>设这个字符串为 $S$，则一定有 $|S|\le 2n$，其中小于的部分是 $s,t$ 共用了一些字符。所以我们只需要求出 $s,t$ 能共用字符的最大值即可。直接枚举长度然后判断即可，时间复杂度 $\mathcal{O}(n^2)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">110</span>], t[<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, flag, cnt; <span class="built_in">scanf</span>(<span class="string">&quot;%d%s%s&quot;</span>, &amp;n, s + <span class="number">1</span>, t + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        flag = <span class="number">1</span>; cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n - i + <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            <span class="keyword">if</span> (s[j] != t[j + i - n]) &#123; flag = <span class="number">0</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123; <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n + n - i); <span class="keyword">break</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="B-Median-Pyramid-Easy"><a href="#B-Median-Pyramid-Easy" class="headerlink" title="B - Median Pyramid Easy"></a>B - Median Pyramid Easy</h4><p>给出一个 $n$ 层的方格金字塔，其中从上到下分别为第 $1$ 到 $n$ 层。第 $i$ 层有 $2i-1$ 个方格，具体形态如下：</p>
<p><img src="https://cdn.luogu.com.cn/upload/vjudge_pic/AT2163/a992c42b0e9b0597f104bf82a0adc1131324bb4f.png" alt=""></p>
<p>第 $n$ 层有一个 $1$ 到 $2n-1$ 的排列，其余位置的数字是它正下方，右下方和左下方方格中的三个数字里排名第二的数。现在给出一个数字 $x$，求出第 $n$ 层一个可能的排列方式，使得第一层的数字是 $x$。($2\le n\le10^5$)</p>
<p>首先能注意到的是，当 $x=1$ 或 $x=2n-1$ 时，显然无解，因为它们是排列里面的极小，极大值，在除了第 $n$ 层之外的地方都不可能出现。而对于有解的 $x$，考虑在这两个位置为 $x$：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/rmo7jvaf.png" alt=""></p>
<p>则画图可以发现，这些位置均为 $x$：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/5wa47hit.png" alt=""></p>
<p>所以如果我们想构造出来最上面一层为 $x$ 的情况，只需要让第 $n-1$ 层的中间和右边一格为 $x$ 即可。这个可以通过令第 $n$ 层的排列为 $(\cdot\cdot\cdot,x-1,x,x+1,x-2,\cdot\cdot\cdot)$ 轻松构造，注意当 $x=2$ 时，排列应为 $(\cdot\cdot\cdot,x-1,x,x+1,x+2,\cdot\cdot\cdot)$。时间复杂度 $\mathcal{O}(n)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>; <span class="keyword">int</span> a[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, x; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;x);</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1</span> || x == <span class="number">2</span> * n - <span class="number">1</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">    a[n] = x; a[n - <span class="number">1</span>] = x - <span class="number">1</span>; a[n + <span class="number">1</span>] = x + <span class="number">1</span>; <span class="keyword">int</span> now = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">2</span>) now = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n - <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i]) <span class="keyword">continue</span>;</span><br><span class="line">        a[i] = now; ++now; </span><br><span class="line">        <span class="keyword">if</span> (now + <span class="number">1</span> == x) now += <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n - <span class="number">1</span>; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="C-Rabbit-Exercise"><a href="#C-Rabbit-Exercise" class="headerlink" title="C - Rabbit Exercise"></a>C - Rabbit Exercise</h4><p>一行上面有 $n$ 只兔子，分别从 $1$ 到 $n$ 编号，编号为 $i$ 的兔子初始位置为 $x_i$。兔子们要执行一段操作。一段操作以一个长为 $m$ 的操作序列 $a$ 描述，其中 $a_i(2\le a_i\le n-1)$ 表示这次操作由兔子 $a_i$ 执行，它会等概率选择兔子 $a_i-1$ 和 $a_i+1$ 中的一个，并跳到以它为对称中心和现在的位置中心对称的位置。现在给出初始位置和兔子们执行这段操作的次数 $k$，求出所有兔子最终的期望位置。($3\le n\le10^5,|x_i|\in\{x\in \mathbf{Z}||x|\le10^9\},1\le m\le10^5,1\le k\le10^{18}$)</p>
<p>首先有一个显然的结论，也就是执行完一个操作后，$a_i$ 号兔子所在期望位置就会变为：</p>
<script type="math/tex; mode=display">E(a_i)=\dfrac{1}{2}(2E(a_i-1)-E(a_i))+\dfrac{1}{2}(2E(a_i+1)-E(a_i))</script><p>但如果直接按照这个式子递推，您将会收获一个 $\tt TLE$ 和 5 分钟的罚时。所以我们考虑变一变这个式子，稍微合并一下有：</p>
<script type="math/tex; mode=display">E(a_i)=E(a_i-1)+E(a_i+1)-E(a_i)</script><p>好了如果你没有灵光乍现这题也就到此为止了，但如果你发现原序列的差分序列在这样一次操作后会有很神奇的变化，这题也就到此为止了，如果我们令 $d_i=E(a_i)-E(a_i-1)$，则有：</p>
<script type="math/tex; mode=display">d_i=E(a_i)-E(a_i-1)=E(a_i+1)-E(a_i)</script><script type="math/tex; mode=display">d_{i+1}=E(a_i+1)-E(a_i)=E(a_i)-E(a_i-1)</script><p>可以观察到，$d_i$ 和 $d_{i+1}$ 在一次操作的前后交换了位置，利用这个性质，我们可以求出一段操作后，差分序列的每个位置会跑到哪去，注意到执行 $k$ 次其实是个循环的过程，所以我们就可以找到循环节直接做了。这个循环节其实可以理解为置换环的大小，比如每次操作有 $1\rightarrow2,2\rightarrow4,4\rightarrow1$，则置换环如下图：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/oult3tr1.png" alt=""></p>
<p>每次操作其实就是在置换环上走一步。求置换环的部分用个栈记录一下就好了，具体实现见代码，时间复杂度 $\mathcal{O}(m+n)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> id[N], vis[N], st[N], tp; <span class="keyword">double</span> x[N], d[N], dd[N]; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;x[i]), d[i] = x[i] - x[i - <span class="number">1</span>], id[i] = i;</span><br><span class="line">    <span class="keyword">int</span> m; <span class="keyword">long</span> <span class="keyword">long</span> k; <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>, &amp;m, &amp;k); <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a; i &lt;= m; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a), std::<span class="built_in">swap</span>(id[a], id[a + <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>; tp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; !vis[j]; j = id[j]) vis[j] = <span class="number">1</span>, st[++tp] = j;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tp; ++j) dd[st[j]] = d[st[(k + j - <span class="number">1</span>) % tp + <span class="number">1</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) dd[i] += dd[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%.1lf\n&quot;</span>, dd[i]); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="D-Median-Pyramid-Hard"><a href="#D-Median-Pyramid-Hard" class="headerlink" title="D - Median Pyramid Hard"></a>D - Median Pyramid Hard</h4><p>题目背景同 B。只不过这一次给出了 $1$ 到 $2n-1$ 的排列，需要求出第 $1$ 层的数 $x$。($2\le n\le10^5$)</p>
<p><del>总觉得最近至少做了三道这种类型的题，但这次还是没做出来</del></p>
<p>非常妙的思想，我甚至不知道怎么才能恰当的引入二分这个思想。只能说朴素的算法是 $\mathcal{O}(n^2)$ 而很难再优化，所以考虑转化为判断性问题，并尝试在 $\mathcal{O}(n)$ 的时间复杂度内判断可行性，这样就可以做到最终 $\mathcal{O}(n\log n)$ 的复杂度了。考虑判断最终答案与 $x$ 的大小关系，注意到题目关心的是数的大小关系而不是实际的数，所以我们把排列中所有小于 $x$ 的数变为 $0$，所有大于等于 $x$ 的数变为 $1$。这样一个格子里面填入的数就是它的下面三格中数量比较多的那个数，具体来讲，见下图：</p>
<p><img src="https://cdn.luogu.com.cn/upload/pic/28097.png" alt=""></p>
<p>我们最终的目标就是判断最上面的数是 $0$ 还是 $1$，通过这个来找到最终答案和 $x$ 的大小关系。注意到图中的连续 $0$ 和连续 $1$ 会把每一层的这一部分变成连续 $0$ 或连续 $1$，而交替 $1,0$ 会形成一个 V 字结构。而当不同的结构两两相遇时，它们就会停下。根据这个性质，我们可以发现第 $1$ 层的元素其实是连续 $0$ 和连续 $1$ “比赛”谁先到顶端的结果，换句话说，也就是哪个离中心近顶端就是哪个。那有没有可能一样近呢，<del>显然没有</del> 因为底端的长度是奇数，如果连续段距离中心一样近，中间的交替段长度一定是奇数，也就是说交替段的两边一定相同，总会有一边和相邻的连续段形成更长的连续段从而导致距离不同的。这样这题就做完了，注意特判两位选手都不在的情况，即底端是全交替的情况，此时顶层的元素即为底层最左右端的元素。最终时间复杂度 $\mathcal{O}(n\log n)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>; <span class="keyword">int</span> a[N &lt;&lt; <span class="number">1</span>], b[N &lt;&lt; <span class="number">1</span>], n;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (n &lt;&lt; <span class="number">1</span>); ++i) b[i] = (a[i] &gt;= x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b[n + i] == b[n + i + <span class="number">1</span>]) <span class="keyword">return</span> b[n + i];</span><br><span class="line">        <span class="keyword">if</span> (b[n - i] == b[n - i - <span class="number">1</span>]) <span class="keyword">return</span> b[n - i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b[(n &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (n &lt;&lt; <span class="number">1</span>); ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = (n &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>, mid, ans;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) ans = mid, l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="E-Rotate-3x3"><a href="#E-Rotate-3x3" class="headerlink" title="E - Rotate 3x3"></a>E - Rotate 3x3</h4><p>给出一个 $3$ 行 $n$ 列的表格，其中 $(i,j)$ 位置的初始值为 $i+3\times j-3$。可以把其中任意的 $3\times 3$ 的格子旋转 $180^\circ$。给出一个 $3\times n$ 的表格，求是否能通过初始表格执行任意上述旋转操作得到这个表格。($5\le n\le10^5$)</p>
<p>思维神题orz，不知道为啥学长之前写的写法比我照着题解写的少一个 $\log$。首先我们把旋转操作转化一下就是交换相隔的两列，并把这两列和它们中间的那一列上下颠倒。我们可以通过这个性质排除掉一些很傻的情况，首先这么交换每一列的数跟初始时不会有变化，只是可能会颠倒顺序，其次因为交换是相隔交换，所以每一列所在的列奇偶性不会变化。具体来讲，对于任意非负整数 $l$，$6l+1,6l+2,6l+3$ 一定一直在奇数列中，$6l+4,6l+5,6l+6$ 一定一直在偶数列中。显然这个条件是必要条件，但它充分吗？打表 <del>（或者随便猜一下这题不可能这么简单）</del> 可以发现，对于 $n=10$ 的情况，通过初始状态一共可以得到 $368,6400$ 种情况，而通过上述过程的计算，我们能得到 $120 \times 120 \times 2^{10} = 1474,5600$ 种情况（数据来自 AT 题解），容易发现多了 $4$ 倍，说明我们刚刚讨论出来的条件只是必要不充分条件。</p>
<p>我们重新审视一下刚刚操作的过程。对于奇数列而言，我们考虑两种操作：交换两个相邻的奇数列，颠倒一个奇数列。显然如果不能通过这两种操作达到最终情况，答案一定是不可能。如果能通过这两种操作达到最终情况，我们就设 $inv_o$ 表示第一种操作操作的次数，$flip_o$ 表示第二种操作操作的次数。注意到我们虽然不能准确确定它们的值，但可以确定奇偶性。考虑第一种操作，如果我们把奇数列按顺序依次从 $1$ 到 $\dfrac{n}{2}$ 编号，则一次操作要么减少一个逆序对，要么增加一个逆序对，均会导致逆序对奇偶性的改变，而同时这一次操作也会改变 $inv_o$ 的奇偶性，所以我们能用最终逆序对的个数奇偶性反映 $inv_o$ 的奇偶性。对于第二种操作，一次操作要么增加一个（与初始状态比较）颠倒的列，要么减少一个颠倒的列，均会导致颠倒列数奇偶性的改变，所以类似地，我们可以用最终颠倒列的数目的奇偶性反映 $flp_o$ 的奇偶性。我们用类似的操作，求出对于偶数列的 $inv_e$ 和 $flp_e$。</p>
<p>求出来之后有什么用呢？注意到每次旋转操作，会导致一下两种结果之一：</p>
<ul>
<li>$inv_o$ 和 $flp_e$ 的奇偶性改变了。</li>
<li>$flp_o$ 和 $inv_e$ 的奇偶性改变了。</li>
</ul>
<p>取决于在哪旋转的。所以最终 $inv_o$ 和 $flp_e$，$flp_o$ 和 $inv_e$ 的奇偶性一定相同。那么这是不是充分条件呢？考虑以下构造（小写字母表示初始顺序，大写字母表示逆序）：</p>
<ul>
<li>$\tt a\ b\ c\ d\ e$ </li>
<li>$\tt c\ B\ a\ d\ e$</li>
<li>$\tt c\ B\ e\ D\ a$</li>
<li>$\tt e\ b\ c\ D\ a$</li>
<li>$\tt e\ b\ a\ d\ c$</li>
<li>$\tt a\ B\ e\ d\ c$</li>
<li>$\color{red}{\tt a\ B\ c\ D\ e}$</li>
<li>$\tt a\ D\ C\ B\ e$</li>
<li>$\tt C\ d\ a\ B\ e$</li>
<li>$\tt C\ B\ A\ d\ e$</li>
<li>$\color{red}{\tt A\ b\ C\ d\ e}$</li>
</ul>
<p>注意到红色的两列，我们可以通过交换和颠倒改变相邻的奇数列或相邻的偶数列的颠倒情况，再加上我们可以交换相邻的两列，所以只要满足以上条件，一定可以构造出相应的方案，充分性得证。最终时间复杂度就是判逆序对的复杂度 $\mathcal{O}(n\log n)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>; <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>][N], b[N], c[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BIT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ll c[N]; <span class="keyword">int</span> len;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>&#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= len; i += <span class="built_in">lowbit</span>(i)) c[i] += v; &#125;</span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; ll ans = <span class="number">0</span>; <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i; i -= <span class="built_in">lowbit</span>(i)) ans += c[i]; <span class="keyword">return</span> ans; &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> lowbit</span></span><br><span class="line">&#125;bit[<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> d[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++i) d[i] = a[i][j] % <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">if</span> (j &amp; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (d[<span class="number">1</span>] == <span class="number">1</span> &amp;&amp; d[<span class="number">2</span>] == <span class="number">2</span> &amp;&amp; d[<span class="number">3</span>] == <span class="number">3</span>)</span><br><span class="line">                b[j] = (a[<span class="number">1</span>][j] - <span class="number">1</span>) / <span class="number">6</span> + <span class="number">1</span>, c[j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (d[<span class="number">1</span>] == <span class="number">3</span> &amp;&amp; d[<span class="number">2</span>] == <span class="number">2</span> &amp;&amp; d[<span class="number">3</span>] == <span class="number">1</span>)</span><br><span class="line">                b[j] = (a[<span class="number">1</span>][j] - <span class="number">3</span>) / <span class="number">6</span> + <span class="number">1</span>, c[j] = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (d[<span class="number">1</span>] == <span class="number">4</span> &amp;&amp; d[<span class="number">2</span>] == <span class="number">5</span> &amp;&amp; d[<span class="number">3</span>] == <span class="number">0</span>)</span><br><span class="line">                b[j] = (a[<span class="number">1</span>][j] - <span class="number">4</span>) / <span class="number">6</span> + <span class="number">1</span>, c[j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (d[<span class="number">1</span>] == <span class="number">0</span> &amp;&amp; d[<span class="number">2</span>] == <span class="number">5</span> &amp;&amp; d[<span class="number">3</span>] == <span class="number">4</span>)</span><br><span class="line">                b[j] = (a[<span class="number">1</span>][j] - <span class="number">6</span>) / <span class="number">6</span> + <span class="number">1</span>, c[j] = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll inv[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;; <span class="keyword">int</span> flp[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;; bit[<span class="number">0</span>].len = bit[<span class="number">1</span>].len = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, d; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        d = i &amp; <span class="number">1</span>; bit[d].<span class="built_in">add</span>(b[i], <span class="number">1</span>);</span><br><span class="line">        inv[d] += bit[d].<span class="built_in">query</span>(n) - bit[d].<span class="built_in">query</span>(b[i]), flp[d] += (c[i] == <span class="number">-1</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    inv[<span class="number">0</span>] %= <span class="number">2</span>; inv[<span class="number">1</span>] %= <span class="number">2</span>; flp[<span class="number">0</span>] %= <span class="number">2</span>; flp[<span class="number">1</span>] %= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (inv[<span class="number">1</span>] == flp[<span class="number">0</span>] &amp;&amp; inv[<span class="number">0</span>] == flp[<span class="number">1</span>]) <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="F-Blackout"><a href="#F-Blackout" class="headerlink" title="F - Blackout"></a>F - Blackout</h4><p>有一个 $n\times n$ 的表格，其中第 $i$ 行第 $j$ 列为 $(i,j)$，其中有 $m$ 个格子为黑色。接下来想根据以下规则把表格里面更多格子涂上黑色：</p>
<ul>
<li>如果格子 $(x,y),(y,z)$ 均为黑色且 $(z,x)$ 为白色，则把 $(z,x)$ 涂上黑色。</li>
</ul>
<p>现在给出初始的 $m$ 个黑色格子，求出最终会有多少格子被涂上黑色。($1\le n,m\le10^5$)</p>
<p>神仙题面，如果直接出图论可能就没这么难了。<del>根据我的吐槽</del>我们考虑把原题面转化成图论问题：</p>
<blockquote>
<p>给出一个 $n$ 个点 $m$ 条边的有向图，如果存在边 $x\rightarrow y,y\rightarrow z$，则加上边 $z\rightarrow x$，可以加边就一直加边，最终图里面会有多少条边？</p>
</blockquote>
<p>显然，不同的弱连通块（也就是不考虑边的方向连通）之间不会相互影响，所以我们可以对每个弱连通块分别统计。以下讨论假设原图弱连通。</p>
<p>（这里是原题解对正解放的引入，虽然我不是很理解为什么要这么引入）我们首先考虑一些特殊情况，比如图是一条链，如果对这张图做上述操作，则我们会发现，最终得到的图上存在一条边 $s\rightarrow t$，当且仅当 $s\equiv t\pmod{3}$。这启发我们这道题肯定跟路径长模 $3$ 有关。</p>
<p>考虑在原图上给每个点打上一个 $\tt A,B,C$ 的其中一个的标记，使得原图满足：</p>
<ul>
<li>对于每一条边 $x\rightarrow y$，对于它端点的标记都有 $\tt A\rightarrow B$，$\tt B\rightarrow C$ 或 $\tt C\rightarrow A$。</li>
</ul>
<p>这样的标记有可能不存在（比如四元环），但一旦存在就是唯一的（排除循环的情况的话）。不管怎么说，我们都可以用 $\rm dfs$ 在 $\mathcal{O}(m)$ 的时间复杂度下打出标记或声明矛盾。接下来根据我们得到的结果会有三种结论，证明下附：</p>
<ul>
<li>当这样的标记不存在时，可以在任意点对直接连边，包括自环</li>
<li>当这样的标记存在，且 $\tt A,B,C$ 标记全部出现了，可以在所有满足 $\tt A\rightarrow B$，$\tt B\rightarrow C$ 和 $\tt C\rightarrow A$ 的点对之间连边，且不能再连其他边。</li>
<li>当这样的标记存在，且 $\tt A,B,C$ 标记没有全部出现，不能在原图的基础上连任何边。</li>
</ul>
<p>根据这些结论我们就可以直接得到结果了，最终时间复杂度即为 $\rm dfs$ 的复杂度 $\mathcal{O}(m)$。</p>
<p>证明（感性理解罢）：</p>
<ol>
<li><strong>当这样的标记存在，且 A,B,C 标记没有全部出现</strong>  如果边 $x\rightarrow y$ 和边 $y\rightarrow z$ 同时存在的话，所有标记应该会全部出现，所以在这种情况下不存在这样的边，你也就无法做任何操作了。</li>
<li><p><strong>当这样的标记存在，且 A,B,C 标记全部出现了</strong>  这种情况下，存在 $x,y,z$ 满足边 $x\rightarrow y$ 和 $y\rightarrow z$ 存在，自然我们可以加 $z\rightarrow x$ 这条边，这样 $x,y,z$ 就会形成一个三角形。假设 $x,y,z$ 的标记分别是 $\tt A,B,C$，则考虑一个点 $v$ 与 $x,y,z$ 中的一个相邻，比如存在边 $v\rightarrow x$，则显然又会形成一个三角形 $v,x,y$。而画图可以发现，$v$ 至少会和 $x,y,z$ 中的两个相邻：</p>
<p> <img src="https://cdn.luogu.com.cn/upload/image_hosting/ihf7ua2y.png" alt=""></p>
<p> 如果我们再考虑一个与 $v$ 相邻的 $w$，我们也能证明 $w$ 至少和 $x,y,z$ 中的两个相邻：</p>
<p> <img src="https://cdn.luogu.com.cn/upload/image_hosting/p2ey80s0.png" alt=""></p>
<p> 一直重复这个过程我们就可以证明任意点都和 $x,y,z$ 中的两个相邻，这样我们就可以在所有满足 $\tt A\rightarrow B$，$\tt B\rightarrow C$ 和 $\tt C\rightarrow A$ 的点对之间连边，且显然不能再连其他边。</p>
</li>
<li><strong>这样的标记不存在时，可以在任意点对直接连边，包括自环</strong>  我们首先证明至少一个自环存在且满足条件，这样剩余的证明跟这个证明就几乎相同了。首先考虑找到一个会引起矛盾的环，这个环一定存在边 $x\rightarrow y$ 和边 $y \rightarrow z$，而我们可以通过加边 $z\rightarrow x$ 来缩小这个环，且这个小的环也会引起矛盾。一直重复这个过程，我们就可以得到一个自环。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span> <span class="keyword">int</span> v, next, w; &#125;E[N &lt;&lt; <span class="number">1</span>]; <span class="keyword">int</span> p[N], cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(p, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span> (p)); cnt = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123; E[cnt].w = w; E[cnt].v = v; E[cnt].next = p[u]; p[u] = cnt++; &#125;</span><br><span class="line"><span class="keyword">int</span> vis[N], tag[N], c[N], col[N], sum, ok, tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[u] = <span class="number">1</span>; ++c[col[u]]; ++sum; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = p[u], v; i + <span class="number">1</span>; i = E[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        v = E[i].v; tot += (E[i].w == <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (!vis[v]) col[v] = (col[u] + E[i].w + <span class="number">3</span>) % <span class="number">3</span>, <span class="built_in">dfs</span>(v);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (col[v] != (col[u] + E[i].w + <span class="number">3</span>) % <span class="number">3</span>) ok = <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>(); <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= m; ++i) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y), <span class="built_in">insert</span>(x, y, <span class="number">1</span>), <span class="built_in">insert</span>(y, x, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>; sum = tot = <span class="number">0</span>; ok = <span class="number">1</span>;</span><br><span class="line">        c[<span class="number">0</span>] = c[<span class="number">1</span>] = c[<span class="number">2</span>] = <span class="number">0</span>; <span class="built_in">dfs</span>(i); </span><br><span class="line">        <span class="keyword">if</span> (!ok) ans += <span class="number">1ll</span> * sum * sum;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c[<span class="number">0</span>] &amp;&amp; c[<span class="number">1</span>] &amp;&amp; c[<span class="number">2</span>]) </span><br><span class="line">            ans += <span class="number">1ll</span> * c[<span class="number">0</span>] * c[<span class="number">1</span>] + <span class="number">1ll</span> * c[<span class="number">0</span>] * c[<span class="number">2</span>] + <span class="number">1ll</span> * c[<span class="number">1</span>] * c[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">else</span> ans += tot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这一把很大程度上运用了转化的思想，比如 C 题中对差分序列的转化（有时候推出来一个式子无从下手可以考虑从差分或前缀和的思想讨论）， D 题中二分后转化为判定性问题的 $0,1$ 转化，E 题中对原操作的转化（对于不熟悉的操作运用这种转化通常是有效的），F 题中对原题目的转化（这种 $10^5\times10^5$ 的表格一看就不是什么应该正常做的题目）。在之后的题目中，如果遇到无从下手的问题，不放发散一下思维，想想有没有熟悉的题目能跟它联系起来或者原题面有没有另一种表述方法 <del>（然后还是不会）</del> ，说不定就茅塞顿开了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhiyangfan1234.github.io/2022/01/24/AtCoder%20Grand%20Contest%20009/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhiyangfan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhiyangfan 的博客小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/24/AtCoder%20Grand%20Contest%20009/" class="post-title-link" itemprop="url">AtCoder Grand Contest 009</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-01-24 17:00:23 / 修改时间：17:11:46" itemprop="dateCreated datePublished" datetime="2022-01-24T17:00:23+08:00">2022-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="AtCoder-Grand-Contest-009-补题总结"><a href="#AtCoder-Grand-Contest-009-补题总结" class="headerlink" title="AtCoder Grand Contest 009 补题总结"></a>AtCoder Grand Contest 009 补题总结</h2><p>whk 选手，时不时发点博客.jpg</p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="A-Multiple-Array"><a href="#A-Multiple-Array" class="headerlink" title="A - Multiple Array"></a>A - Multiple Array</h4><p>有一个长为 $n$ 的序列 $a$，我们对 $a$ 定义如下操作：</p>
<ul>
<li>对第 $a_i$ 操作一次会导致 $a_{k}(1\le k\le i)$ 的值加上 $k$。</li>
</ul>
<p>再给出一个长为 $n$ 的序列 $b$，求至少需要多少次操作才能使 $\forall i$ 都有 $b_i|a_i$。<br>($1\le n\le10^5,0\le a_i\le 10^9,1\le b_i\le10^9$)</p>
<p>注意到一次操作只会影响到编号比它小的元素，所以我们倒序（这样才能让每次操作时 $a_i$ 的值已经确定了）处理 $a_i$，每次贪心选取在 $a_i$ 处操作最少的次数，这样就能最小化整体操作次数。（正确性方面不太会证明，如果有会的请指教qwq）总时间复杂度 $\mathcal{O}(n)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>; <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll a[N], b[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n); ll tot = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;a[i], &amp;b[i]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">	&#123;</span><br><span class="line">		a[i] += tot; <span class="keyword">if</span> (a[i] % b[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">		tot += <span class="built_in">ceil</span>(<span class="number">1.0</span> * a[i] / b[i]) * b[i] - a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, tot); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="B-Tournament"><a href="#B-Tournament" class="headerlink" title="B - Tournament"></a>B - Tournament</h4><p>有 $n$ 个人正在参加锦标赛，共进行 $n-1$ 轮比赛，每轮比赛淘汰一名选手。但因为某种原因，每个人如果想要获胜需要进行的比赛轮数不同，我们定义一场锦标赛的深度为所有选手中需要获胜所要进行的比赛轮数最多的。选手从 $1\sim n$ 编号，$1$ 为最终的获胜者，第 $i$ 名选手被 $a_i$ 在某场比赛中打败。问所有可能的锦标赛中深度最小的深度。($2\le n\le 10^5,1\le a_i\le n(2\le i\le n)$)</p>
<p>显然锦标赛模型可以转化为树模型，但不能直接建一棵硬模拟的树啊，我因为这个想法浪费了不少的光阴。我们来简化一下树的模型，对于 $i$，我们让 $a_i$ 是 $i$ 的父亲。建出来这样一棵树后我们来尝试在这上面统计答案。</p>
<p>设 $f_u$ 表示 $u$ 结点对应的子树中需要获胜所要进行的比赛轮数最多的值。我们对原树进行一遍 $\rm dfs$，当进行到 $u$ 结点时，我们先处理出来它所有子节点对应的 $f_v$。然后对每个儿子 $v$ <strong>分别</strong>（意思就是这次一次更新过的 $f_u$ 会在下一次的转移用上）做如下转移：</p>
<script type="math/tex; mode=display">f_u=\max(f_v,f_u)+1</script><p>意思就是 $u,v$ 都有可能是需要获胜的比赛轮数最多的选手，哪个更多需要取个 $\max$ 看看。然后不管哪个更多，$a_i-i$ 这场总得打吧，所以要 $+1$。注意到这里为了转移的正确性需要从小到大转移，也就是要先对儿子结点 $v$ 按照 $f_v$ 从小到大排序。总时间复杂度 $\mathcal{O}(n\log n)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>; <span class="keyword">int</span> a[N], f[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span> <span class="keyword">int</span> v, next; &#125;E[N]; <span class="keyword">int</span> p[N], cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(p, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span> (p)); cnt = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123; E[cnt].v = v; E[cnt].next = p[u]; p[u] = cnt++; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = p[u]; i + <span class="number">1</span>; i = E[i].next) <span class="built_in">dfs</span>(E[i].v), vec.<span class="built_in">push_back</span>(E[i].v);</span><br><span class="line">	std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="keyword">const</span> <span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp; b) &#123; <span class="keyword">return</span> f[a] &lt; f[b]; &#125;);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); ++i) f[u] = std::<span class="built_in">max</span>(f[u], f[vec[i]]) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">init</span>(); <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, x; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x), <span class="built_in">insert</span>(x, i);</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>); <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[<span class="number">1</span>]); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="C-Division-into-Two"><a href="#C-Division-into-Two" class="headerlink" title="C - Division into Two"></a>C - Division into Two</h4><p>给出一个大小为 $n$ 的集合 $S$，$\forall i&lt;j$，都有 $S_i&lt;S_j$。现在想把它分为两个满足以下条件的可空集合 $X,Y$：</p>
<ul>
<li>$X$ 中的元素两两之差的绝对值大于等于 $A$。</li>
<li>$Y$ 中的元素两两之差的绝对值大于等于 $B$。</li>
</ul>
<p>求出分割的方法有多少种，答案对<br>$10^9+7$ 取模。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhiyangfan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhiyangfan</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
