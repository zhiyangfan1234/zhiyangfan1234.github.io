<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zhiyangfan1234.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="zhiyangfan 的博客小窝">
<meta property="og:url" content="https://zhiyangfan1234.github.io/index.html">
<meta property="og:site_name" content="zhiyangfan 的博客小窝">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="zhiyangfan">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://zhiyangfan1234.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>zhiyangfan 的博客小窝</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">zhiyangfan 的博客小窝</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhiyangfan1234.github.io/2022/01/24/abc213/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhiyangfan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhiyangfan 的博客小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/24/abc213/" class="post-title-link" itemprop="url">AtCoder Beginner Contest 213</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-01-24 17:00:23 / 修改时间：17:05:28" itemprop="dateCreated datePublished" datetime="2022-01-24T17:00:23+08:00">2022-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Atcoder-Beginner-Contest-213"><a href="#Atcoder-Beginner-Contest-213" class="headerlink" title="Atcoder Beginner Contest 213"></a>Atcoder Beginner Contest 213</h2><p>发挥稳定，依然是做到D题，依然是rk 1400。</p>
<h3 id="A-Bitwise-Exclusive-Or"><a href="#A-Bitwise-Exclusive-Or" class="headerlink" title="A - Bitwise Exclusive Or"></a>A - Bitwise Exclusive Or</h3><p>给定两个整数 $A,B$​ ，求出一个 $C$​ 使得 $A \operatorname{xor}C=B$​ 。（ $0\le A,B\le 255$​ ​）</p>
<p>注意到 $A \operatorname{xor} C=B$​​ 等价于 $A\operatorname{xor}B=C$​​ ， $\mathcal{O}(1)$ 计算即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a, b; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a ^ b);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="B-Booby-Prize"><a href="#B-Booby-Prize" class="headerlink" title="B - Booby Prize"></a><strong>B - Booby Prize</strong></h3><p>给出长度为 $n$ 的序列 $a$ ，求序列第 $2$ 大元素的编号。（ $2\le n\le 2\times10^5,1\le a_i\le10^9,\forall i\neq j,a_i\neq a_j$​ ）</p>
<p>建立结构体记录权值$a_i$​​ 和 $i$​​ ，按 $a_i$​​ 为第一关键字排序后输出第 $2$​​ 大元素记录的编号即可，复杂度 $\mathcal{O}(n\log n)$​</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line">std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p[i].first), p[i].second = i;</span><br><span class="line">	std::<span class="built_in">sort</span>(p + <span class="number">1</span>, p + <span class="number">1</span> + n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, p[n - <span class="number">1</span>].second);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="C-Reorder-Cards"><a href="#C-Reorder-Cards" class="headerlink" title="C - Reorder Cards"></a><strong>C - Reorder Cards</strong></h3><p>给出一个 $H\times W$​​ 的网格图，给出 $n$​​ 个互不相同的点，对于第 $i$​ 个点 $(a_i,b_i)$​ 上有数字 $i$​ ，其余点无数字。之后不断执行以下操作：</p>
<ul>
<li><p>如果一行没有任何有数字的点，就将其删去，并将其余的点向上移动来填补空隙；</p>
</li>
<li><p>如果一列没有任何有数字的点，就将其删去，并将其余的点向左移动来填补空隙。</p>
</li>
</ul>
<p>问在最终的网格图中，数字 $i(1\le i\le n)$​ 所在的点。（ $1\le H,W\le10^9,1\le n \le \min(10^5,H\times W)$​ ）</p>
<p>注意到如果最终能留下来的行或列都是最初存在数字的行或列，其余的都会被删去，所以这些存在数字的行或列就会挨在一起。这个过程非常类似离散化的过程。所以我们将 $a_i,b_i$​ 分别离散化后输出即可，复杂度 $\mathcal{O}(n\log n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>; std::map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp1, mp2;</span><br><span class="line"><span class="keyword">int</span> ai[N], bi[N]; <span class="class"><span class="keyword">struct</span> <span class="title">pnt</span> &#123;</span> <span class="keyword">int</span> x, y; &#125;p[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> h, w, n; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;h, &amp;w, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;ai[i], &amp;bi[i]), p[i].x = ai[i], p[i].y = bi[i];</span><br><span class="line">	std::<span class="built_in">sort</span>(ai + <span class="number">1</span>, ai + <span class="number">1</span> + n); std::<span class="built_in">sort</span>(bi + <span class="number">1</span>, bi + <span class="number">1</span> + n);</span><br><span class="line">	<span class="keyword">int</span> x1 = std::<span class="built_in">unique</span>(ai + <span class="number">1</span>, ai + <span class="number">1</span> + n) - ai - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> x2 = std::<span class="built_in">unique</span>(bi + <span class="number">1</span>, bi + <span class="number">1</span> + n) - bi - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x1; i++) mp1[ai[i]] = i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x2; i++) mp2[bi[i]] = i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, mp1[p[i].x], mp2[p[i].y]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="D-Takahashi-Tour"><a href="#D-Takahashi-Tour" class="headerlink" title="D - Takahashi Tour"></a><strong>D - Takahashi Tour</strong></h3><p>给出一棵有 $n$  个结点的树，从 $1$ 结点出发。每到一个结点 $i$ 执行以下操作：</p>
<ul>
<li><p>如果存在还未访问的，直接与 $i$ 相连的结点，移动到所有这样的结点中编号最小的那个；</p>
</li>
<li><p>否则：如果 $i=1$​ ，结束整个过程；否则，返回上一个到达的结点。</p>
</li>
</ul>
<p>问访问序列。（ $2\le n\le 2\times10^5$​ ）</p>
<p>注意到如果没有编号最小的限制，这个题就是个dfs的裸题，每到一个结点和回溯时输出当前结点的编号即可。加上编号最小的限制后可以每次寻找可以到达的点时不着急访问，而是存到堆里。等到全部找完后再从不断堆顶访问即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span> <span class="keyword">int</span> v, next; &#125;E[N &lt;&lt; <span class="number">1</span>]; <span class="keyword">int</span> p[N], cnt, vis[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(p, <span class="number">-1</span>, <span class="keyword">sizeof</span> p); cnt = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123; E[cnt].v = v; E[cnt].next = p[u]; p[u] = cnt++; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vis[u] = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, u); std::priority_queue&lt;<span class="keyword">int</span>, std::vector&lt;<span class="keyword">int</span>&gt;, std::greater&lt;<span class="keyword">int</span>&gt; &gt; pq;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = p[u], v; i + <span class="number">1</span>; i = E[i].next)</span><br><span class="line">	&#123;</span><br><span class="line">		v = E[i].v; <span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">		pq.<span class="built_in">push</span>(v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) <span class="built_in">dfs</span>(pq.<span class="built_in">top</span>()), pq.<span class="built_in">pop</span>(), <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">init</span>(); <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt; n; i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y), <span class="built_in">insert</span>(x, y), <span class="built_in">insert</span>(y, x);</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="E-Stronger-Takahashi"><a href="#E-Stronger-Takahashi" class="headerlink" title="E - Stronger Takahashi"></a><strong>E - Stronger Takahashi</strong></h3><p>给出一个 $H\times W$​ 的网格图，每个点有两种值，一种是 <code>.</code> 表示可以通过，一种是 <code>#</code> 表示无法通过。现在要从左上角到右下角，在行进的过程中，可以选择使用能力将一个$2\times 2$​ 的区域全部变成 <code>.</code> 。问想要到达目的地最少需要使用能力的次数。（ $2\le H,W\le 500$ ）</p>
<p>假设只在行进需要时使用能力，这样释放能力的位置就一定是挨着当前结点了。那么注意到如果在编号为 $T$ 的点使用能力后，下图中所有标号为 <code>*</code> 的点都可以走到。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.***.</span><br><span class="line">*****</span><br><span class="line">**T**</span><br><span class="line">*****</span><br><span class="line">.***.</span><br></pre></td></tr></table></figure>
<p>这样，我们发现直接走到相邻的位置花费为 $0$ ，使用能力后走到 <code>*</code> 花费为 $1$ 。01-BFS 求解即可，复杂度 $\mathcal{O}(HW)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="F-Common-Prefixes"><a href="#F-Common-Prefixes" class="headerlink" title="F - Common Prefixes"></a><strong>F - Common Prefixes</strong></h3><p>对于两个字符串 $X,Y$​​ 定义 $f(X,Y)$​​ 表示它们最长公共前缀的长度。给出一个长为 $n$​​ 的字符串 $S$​​ ，设 $S_i$​​ 表示 $S$​​ 以 $i$​​ 开头的后缀，求 $\sum_{k=1}^n \sum_{i=1}^n f(S_i,S_k)$​​​ 。（ $1\le n\le10^6$​​ ）</p>
<p>注意到对于三个字符串$A,B,C$ ，如果字典序满足 $A&lt;B&lt;C$ ，则 $f(A,C)=\min(f(A,B),f(B,C))$ 。如果要利用这条性质，我们就要对原字符串的后缀进行排序，自然想到 SA，可以在 $\mathcal{O}(n)$ 的时间求出。排好序后，就有对于所有 $i&lt;j$ $f(S_{SA_i},f_{SA_j})=\min(f(S_{SA_i},S_{SA_{i+1}}),\cdot\cdot\cdot,f(S_{SA_{j-1}},S_{SA_j})$  ，注意到所有的 $f$ 函数的两个参数在 SA 数组中均相邻，这个可以用 LCPA 预处理，可以在 $\mathcal{O}(n)$ 的时间求出。这样，$f(S_{SA_i},S_{SA_j})=\min(LCPA_i,\cdot\cdot\cdot LCPA_{j-1})$​ 。原问题就变为了：给出一个长为 $n$ 的序列 $A$ ，对于 $i&lt;j$ 令$g(i,j)=\min(A_i,A_{i+1},\cdot\cdot\cdot,A_{j-1})$ ，求 $\sum_{k=1}^n\sum_{i=}^n g(k,i)$ 。</p>
<p>我们令 $B_k=g(1,k)+g(2,k)+\cdot\cdot\cdot+g(k-1,k)$ ，也就是原问题的前半部分，后半部分可以用类似的方式求出。我们尝试从 $k=1$ 递推求出$B$ 。考虑如何从 $B_k$ 递推至 $B_{k+1}$ 。</p>
<p>$B_k=g(1,k)+\cdot\cdot\cdot+g(k-1,k)$</p>
<p>$B_{k+1}=g(1,k+1)+\cdot\cdot\cdot+g(k-1,k+1)+g(k,k+1)$</p>
<p>​           $=\min(g(1,k),A_k)+\cdot\cdot\cdot\min(g(k-1,k),A_k)+A_k$ </p>
<p>也就是在 $B_k$ 的基础上先区间跟 $A_k$ 取 $\min$ 再加上 $A_k$ 。如果暴力实现是 $\mathcal{O}(n^2)$ ，而使用吉司机线段树，有序可重集合，或优先队列实现，复杂度为 $\mathcal{O}(n\log n)$ ​（后两种的实现原理是，记录每个值和它们的出现次数，每次操作会至多减少 $\mathcal{O}(n)$ 的不同数字，所以最坏复杂度为 $\mathcal{O}(n\log n)$）。注意到新增的数字 $A_k$ 大于等于取完 $\min$ 后的原序列的最大值，所以我们可以只用栈来维护，复杂度 $\mathcal{O}(n)$ 。总复杂度 $\mathcal{O}(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="G-Connectivity-2"><a href="#G-Connectivity-2" class="headerlink" title="G - Connectivity 2"></a><strong>G - Connectivity 2</strong></h3><p>给出一个 $n$ 个点 $m$ 条边的无向图 $G$。考虑从 $G$ 中删除 $0$ 条或更多条边，这样总共可以得到 $2^m$​ 张图，在它们之中，对于所有 $2\le k\le n$ ，找出所有满足结点 $1$ 和 $k$ 连通的图的个数，答案对 $998244353$ 取模。（ $2\le n\le 17 ,0\le m\le \frac{n(n-1)}{2}$ ，无重边，自环 ）</p>
<p>这道题是连通图上的组合问题，需要用到状压DP 。首先注意到我们可以在 $\mathcal{O}(3^n)$ 的时间内枚举子集。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; N); i++)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">  &#123;</span><br><span class="line">    j &amp;= i;</span><br><span class="line">    <span class="comment">// j是i的子集</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>首先注意到 $1$​​ 和 $k$​​ 连通这个条件不好求，所以我们考虑转化。设 $V={1,2,\cdot\cdot\cdot,n}$​​ 表示 $G$​​ 的点集。对于 $S\subseteq V$​​ ，我们定义 $f_S$​​ 和 $g_S$​​ ：</p>
<ul>
<li><p>$f_S$ 表示图 $G$ 以 $S\subseteq V$ 为点集的连通子图个数；</p>
</li>
<li><p>$g_S$​ 表示图 $G$​ 以 $S\subseteq V$​ 为点集的子图个数。</p>
</li>
</ul>
<p>接着，我们以图论的方式形式化我们要求的答案：求一个图所有 $1$​ 和 $k$​ 连通的支撑子图的数量，我们把它定义为 $C_k$​ ，然后考虑怎么利用 $f_S$ 和 $g_S$ 来计算 $C_k$。易得有 $C_k=\sum_{\{1,k\}\subseteq S\subseteq V}f_Sg_{V/S}$ ，其中 $V/S$ 表示全集为 $V$ ，$S$ 的补集。这样，只要我们对于所有 $S\subseteq V$ 求出 $f_S,g_S$ ，就能在 $\mathcal{O}(n2^n)$ 的时间求出 $C$ 。</p>
<p>考虑如何计算 $f_S,g_S$ 。显然，计算 $g_S$ 来的更简单一些。我们设 $e$ 表示连接 $S$ 中顶点的边的个数，则 $g_S=2^e$ 。所以我们设 $E_S$ 表示 $G$ 中所有只连接 $S$​ 内点的边的个数​ 。接着我们就可以在 $\mathcal{O}(m)$ 的时间计算 $E_S$​ （枚举每一条边是否符合条件）。这样求出 $g_S$ 算上枚举 $S$ 的复杂度为$\mathcal{O}(m2^n)$​ 。</p>
<p>最后考虑如何计算 $f_S$ ，它可以用带有容斥思想的DP求出。当  $S=\emptyset$ 时，显然有 $f_S=g_S$ 。而在其他情况，我们注意到 $f_S=g_S-k_S$ ，其中 $k_S$ 表示以 $S$ 为点集的图中不连通的个数。考虑用 $f,g$ 来表示 $k$ 。易得有 $k_S=\sum_{v\in T\subsetneq S}f_Tg_{S/T}$ ，则 $f_S=g_S-\sum_{v\in T\subsetneq S}f_Tg_{S/T}$  。这样我们就能递推出 $f_S$ ，总复杂度 $\mathcal{O}(3^n)$ 。最终复杂度 $\mathcal{O}(3^n+m2^n+n2^n)$ 。</p>
<p>注意到可以用 <code>Fast Zeta Transform</code> 来加速 $g$ 的计算至 $\mathcal{O}(n2^n)$ 。求 $f_S$ 还有一种更快的 $\mathcal{O}(n^22^n)$ 的方式。这里都不再讨论。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="H-Stroll"><a href="#H-Stroll" class="headerlink" title="H - Stroll"></a><strong>H - Stroll</strong></h3><p>给出一个有 $n$​ 个结点的图，有 $m$​ 对点被无向边连接，如果设第 $i$​ 对点是 $(a_i,b_i)$​ ，则共有 $p_{i,d}$​ 条长度为 $d$​ 的边连接点 $a_i$​ 和 $b_i$​​ 。现在询问满足以下条件的序列共有多少个：</p>
<ul>
<li><p>形式形如 $\left\langle v_0,e_0,v_1,\cdot\cdot\cdot,e_{k-1},v_k\right\rangle$ ，其中 $v_i$ 表示一个顶点，$e_i$​ 表示一条边；</p>
</li>
<li><p>$e_i$​ 连接 $v_i$​ 和 $v_{i+1}$​ ，$v_0=v_k=1$；</p>
</li>
<li><p>$\sum_{i=0}^{k-1} d_i=T$​ ，其中 $d_i$ 表示 $e_i$​ 的长度。</p>
</li>
</ul>
<p>答案对 $998244353$​ 取模。（ $2\le n\le 10,1\le m\le \min(10,\frac{n(n-1)}{2}),1\le T\le 4\times 10^4,0\le p_{i,j}&lt;998244353$ ，无重边，自环 ）</p>
<p>这个题用到了分块FFT，它是一个找一个序列的值的强有力的工具。这是FFT或者说卷积一种比较难的应用，但一旦理解，它能在大概 $20$ 行内实现。</p>
<p>首先先考虑朴素的DP。我们定义 $dp_{s,t}$​​ 表示路程为 $t$​ 且在 $s$​ 点结束的序列个数，答案即为 $dp_{1,T}$​ 。显然 $dp_{s,t}$​ 可以由 $dp_{v,u}$ 递推而来（ $u&lt;t$ ） ，所以我们可以以 $u$ 递增的顺序递推 $dp$ 。更严谨的讲，$dp$ 可以被以下方式计算：</p>
<script type="math/tex; mode=display">\boxed{dp_{s,t}=\sum_{1\le i\le m,b_i=s}\left(\sum_{0\le u<t}dp_{a_i,u} \times p_{i,t-u}\right) +\sum_{1\le i\le m,a_i=s}\left(\sum_{0\le u<t}dp_{b_i,u}\times p_{i,t-u}\right)}</script><p>这个算法的时间复杂度是 $\mathcal{O}(mT^2)$​​ （稍后解释），加上它巨大的常数，不足以通过本题。尝试消除 $T^2$​ 的计算是本题算法的关键。</p>
<p>接下来的讨论中，我们均假设 $n=2$ 以简化问题 ，因为 $n\ge 3$ 的情况是基本类似的，除了 $\mathcal{O}(m)$​ 会有变化。设 $p_u$ 表示连接 $1,2$ 的长度为 $u$ 的边数，则DP转移可以表示为：</p>
<script type="math/tex; mode=display">\boxed{d_{1,t}=\sum_{0\le u<t}d_{2,u}\times p_{t-u};dp_{2,t}=\sum_{0\le u<t}d_{1,u}\times p_{t-u}}</script><p>观察到这个式子很像卷积。但如果直接用FFT进行计算，我们会发现 $d_1$ 和 $d_2$ 之间有相互依赖的关系，导致我们无法计算。类似这题的题目中，一些DP值依赖于其他的DP值，这种DP被称为在线DP。一般来说，解决这类问题的唯一方法是在DAG上用拓扑序朴素求解。而如果我们用这种方法求解上面的式子，会花费 $\mathcal{O}(T^2)$ 的时间。这样我们似乎走到死胡同里了，但事实上，只要在线DP有良好的性质，我们可以优化朴素算法到达更好的时间复杂度。在本题中，我们可以利用贡献可以以卷积的形式展这样良好的性质。为了实现在线卷积，我们需要分治和卷积的结合——分治FFT。</p>
<p>接下来进入正题了，对于分治FFT的讲解（它也被称为cdq分治FFT，在线FFT，在线卷积等等 ）。首先我们先想象一下对于 $[l,r)$​​​ 计算 DP数组的过程，其中最左边的圆相当于 $dp_{v,l}$ ，最右边的相当于 $dp_{v,r-1}$。（图片来自AtCoder）</p>
<p><img src="https://img.atcoder.jp/ghi/0bece76ac097ab765a3a47bb7ac8121c.png" alt="DP转移"></p>
<p>注意到上面的图是把无向图的完全图的边换成有向边后得到的，所以朴素DP时间复杂度为 $\mathcal{O}(T^2)$​​​ 。而分治FFT就是一种一步步计算上述转移过程的算法。类似cdq分治的思路，它分为三步：首先计算 $[l,m)$ ，然后计算 $[l,m)$ 对 $[m,r)$ 的贡献，最后计算 $[m,r)$ 。其中 $m=\left\lfloor\dfrac{l+r}{2}\right\rfloor$​​ ，而且保证在计算 $[l,r)$ 时，$[0,l)$ 的值已经确定，$[0,l)$ 对 $[l,r)$ 的贡献已经被计算在DP数组上了。接下来具体描述一下。</p>
<p>1.递归计算 $[l,m)$ 的值（图片来自AtCoder）。</p>
<p><img src="https://img.atcoder.jp/ghi/a5bf1fb11f7625ac9f4f55c2ed613799.png" alt="计算左半边"></p>
<p>首先，我们递归计算 $[l,m)$ 。注意到根据上面的条件，$[l,r)$ 外部的贡献已经被加上了，所以我们可以直接计算 $[l,m)$ 而无需任何讨论。</p>
<p>2.计算 $[l,m)$ 对 $[m,r)$​ 的贡献（图片来自AtCoder）</p>
<p><img src="https://img.atcoder.jp/ghi/33c3cad73feb06d6fb61a55d6f4755ee.png" alt="计算贡献"></p>
<p>接着，计算 $[l,m)$ 对 $[m,r)$ 的贡献。当 $n=2$​ 时，符合描述的贡献计算是这样的：</p>
<script type="math/tex; mode=display">\boxed{dp_{1,t}=dp_{1,t}+\sum_{l\le u<m}dp_{2,u}\times p_{t-u};dp_{2,t}=dp_{2,t}+\sum_{l\le u<m}dp_{1,u}\times p_{t-u}}</script><p>之前我们说这个转移不能用FFT实现是因为 $dp_{1,u},dp_{2,u}$ 还没有被确定。但这次，我们已经分治算出了 $[l,m)$​ 所以我们就可以用卷积来实现 $\sum$ 的计算。这样，这一个部分可以以 $\mathcal{O}(B\log B)$ 计算，其中 $B=r-l$ 。</p>
<p>3.递归计算 $[m,r)$​ 的值。（图片来自AtCoder）</p>
<p><img src="https://img.atcoder.jp/ghi/07b11ffb55d27dd226016ce99cd12f22.png" alt="计算右边"></p>
<p>左边的都已经全部计算完毕，最终我们只需要递归计算 $[m,r)$ 即可。</p>
<p>接下来考虑分析一下该算法的复杂度，设 $T(B)$ 表示用分治算法计算长度为 $B$ 的序列时的时间复杂度，则有 $T(B)=2T\left(\dfrac{B}{2}\right)+\mathcal{O}(B\log B)$​ 。严谨的计算含有递归关系的复杂度是很难的，所以我们以一种简单的方式来解释。我们令  $b=\log B,U(b)=\dfrac{T(2^b)}{2^b}=\dfrac{T(B)}{B}$ ，原式两边同时除以 $B$ 得到：$U(b)=U(b-1)+\mathcal{O}(b)$ ，这样可以证明 $U(b)=\mathcal{O}(b^2)=\mathcal{O}(\log^2 b)$ 。这样，$T(B)=B\times U(b)=\mathcal{O}(B\log^2 B)$ 。所以算法总复杂度为 $\mathcal{O}(mT\log^2T)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="经验知识总结"><a href="#经验知识总结" class="headerlink" title="经验知识总结"></a>经验知识总结</h2><ol>
<li>$a\operatorname{xor}b=c\leftrightarrow a\operatorname{xor}c=b$</li>
<li>对于权值均为 $0/1$​​ 的最短路，使用一般的算法会浪费资源，可以用01-BFS来$\mathcal{O}(V+E)$​​ 的解决。具体来讲，使用双端队列，对于边权为 $0$​​​ 的边转移到的点 $v$​​，执行 <code>q.push_front(v)</code> ；对于边权为 $1$​​ 的边转移到的 $v$​ ，执行<code>q.push_back(v)</code> 。每次取出队首，尝试松弛并加入队列，直到访问到第一次目标点 $(x,y)$​ ，输出 <code>dis[x][y]</code> 即可。</li>
<li>可以用栈 $\mathcal{O}(n)$ 维护以下操作：共 $n$ 次操作，每次操作对于集合内所有元素与 $a$ 取 $\min$ ，然后将 $a$ 加入集合中，最后询问集合内的元素和。注意到 $a$ 每次加入时一定大于等于原集合的最大值，可以 $\mathcal{O}(1)$ 维护原栈有序。其他操作就跟单调队列或者有序可重集类似了。</li>
<li>当原问题不好求时，可以转化为若干个子问题，再用容斥等方式合到一起。</li>
<li>对于存在依赖的在线DP，如果它有卷积的形式，则可以利用分治FFT消除依赖，在 $\mathcal{O}(B\log^2B)$ 的时间复杂度内求解（其中 $B$ 表示求解DP数组的长度）。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhiyangfan1234.github.io/2022/01/24/AtCoder%20Beginner%20Contest%20227%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhiyangfan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhiyangfan 的博客小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/24/AtCoder%20Beginner%20Contest%20227%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">AtCoder Beginner Contest 227</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-01-24 17:00:23 / 修改时间：17:10:42" itemprop="dateCreated datePublished" datetime="2022-01-24T17:00:23+08:00">2022-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="AtCoder-Beginner-Contest-227"><a href="#AtCoder-Beginner-Contest-227" class="headerlink" title="AtCoder Beginner Contest 227"></a>AtCoder Beginner Contest 227</h2><p>这把广告场的 H 题码量真的阴间，我写了 $\rm 4KB$ 左右。因为我没广告费，所以比赛标题不打全（</p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="A-Last-Card"><a href="#A-Last-Card" class="headerlink" title="A - Last Card"></a>A - Last Card</h4><p>想把 $k$ 张卡片分给 $n$ 个人，人从 $1\sim n$ 编号。现在从编号为 $a$ 的人开始发卡片，在 $x(1\le x&lt;n)$ 拿到卡片后，下一个会发给 $x+1$，特别地，在 $n$ 拿到卡片后，下一个会发给 $1$。问拿到最后一张卡片的人编号。($1\le n,k\le1000,1\le a\le n$)</p>
<p>非常签到的一道题。可以直接 $\mathcal{O}(k)$ 朴素枚举，当然也可以利用取模相关知识 $\mathcal{O}(1)$ 得出：</p>
<script type="math/tex; mode=display">ans=\begin{cases}n&(a+k-1\equiv0\pmod{n})\\(a+k-1)\bmod{n}&\tt otherwise\end{cases}</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, k, a; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;k, &amp;a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (a + k - <span class="number">1</span>) % n == <span class="number">0</span> ? n : (a + k - <span class="number">1</span>) % n);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="B-KEYENCE-building"><a href="#B-KEYENCE-building" class="headerlink" title="B - KEYENCE building"></a>B - KEYENCE building</h4><p>给出长为 $n$ 的序列 $S$，问其中有多少个 $S_i$ 不能被表示为 $4ab+3a+3b(a,b\in \mathbb{N}_+)$ 的形式。($1\le n\le20,1\le S_i\le1000$)</p>
<p>依然是签到题。对于 $S_i$ 直接枚举所有可能的 $a,b$ 判断即可，时间复杂度 $\mathcal{O}(nS_i^2)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> s[<span class="number">30</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">1</span>; a &lt;= <span class="number">1000</span>; ++a)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">1</span>; b &lt;= <span class="number">1000</span>; ++b)</span><br><span class="line">			<span class="keyword">if</span> (<span class="number">4</span> * a * b + <span class="number">3</span> * a + <span class="number">3</span> * b == S) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, ans = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[i]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">check</span>(s[i])) ++ans;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="C-ABC-conjecture"><a href="#C-ABC-conjecture" class="headerlink" title="C - ABC conjecture"></a>C - ABC conjecture</h4><p>给出一个正整数 $n$，求满足 $a\le b\le c,abc\le n$ 的三元组 $(a,b,c)$ 的数量。($1\le n\le10^{11}$)</p>
<p>稍微复杂一点的签到题。直接枚举 $a,b$ 然后求出对应的 $c$ 的个数（令 $k=\left\lfloor\dfrac{n}{ab}\right\rfloor$，则 $c$ 的个数为 $\max(0,k-b+1)$）。虽然这个做法很简单，但是时间复杂度不是很好分析，原题解一通分析得出复杂度为 $\mathcal{O}(n^{\frac{2}{3}})$，因为涉及到的数学知识比较复杂这里不再深究，总之写完拿极限数据试一下就大概明白复杂度行不行了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll n, ans = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (ll a = <span class="number">1</span>; a * a &lt;= n; ++a)</span><br><span class="line">		<span class="keyword">for</span> (ll b = a; a * b &lt;= n; ++b)</span><br><span class="line">		&#123;</span><br><span class="line">			ll c = n / a / b; <span class="keyword">if</span> (c &lt; b) <span class="keyword">break</span>;</span><br><span class="line">			ans += c - b + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="D-Project-Planning"><a href="#D-Project-Planning" class="headerlink" title="D - Project Planning"></a>D - Project Planning</h4><p>给出一个长为 $n$ 的序列 $a$ 和一个正整数 $k$。我们定义一轮操作为从 $a$ 中选恰好 $k$ 个非 $0$ 数，把它们全部 $-1$。问最多能进行多少轮操作。($1\le k\le n\le2\times10^5,1\le a_i\le10^{12}$)</p>
<p>开始难起来了。如果你像我一样一直想找到一个最优策略，就会罚坐很久。注意到答案具有单调性，所以我们考虑用二分把题目转化为一个判断性问题，即对于当前二分到的值 $p$，询问能否进行 $p$ 轮。我们令 $sum=\sum_{i=1}^n\min(a_i,p)$，则当 $p\times k&gt;sum$ 时，显然不可能进行 $p$ 轮，因为连最优情况全部都能取完都不满足。而当 $p\times k\le sum$ 时，我们能证明，一定能进行 $p$ 轮。当 $p\times k\le sum$ 时，如果有至少 $k$ 个 $a_i$ 满足 $a_i\ge p$，显然能进行 $p$ 轮，如果没有，我们可以选择最大的 $k$ 个数操作一轮，这会把 $sum$ 减掉最多 $k$，这样一直进行下去，也能进行 $p$ 轮。直接二分查找即可，时间复杂度 $\mathcal{O}(n\log w)$，其中 $w=\dfrac{\sum a_i}{k}$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>; <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll; ll a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">    ll l = <span class="number">1</span>, r = <span class="number">3e17</span> / k, mid, sum, ans;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>; sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) sum += std::<span class="built_in">min</span>(mid, a[i]);</span><br><span class="line">        <span class="keyword">if</span> (mid * k &gt; sum) r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> ans = mid, l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="E-Swap"><a href="#E-Swap" class="headerlink" title="E - Swap"></a>E - Swap</h4><p>给出一个仅含有 <code>K</code>，<code>E</code>，<code>Y</code> 三个字符组成的字符串 $S$，问在交换至多 $k$ 次后能得到的不同字符串个数（本题中的交换指交换相邻字符）。($1\le|S|\le30,0\le k\le10^9$)</p>
<p>考虑这样一个问题，给定字符串 $S$ 和 $T$，问至少需要多少次交换才能使 $S,T$ 相同。这个问题很简单，我们可以通过贪心交换使每一位都相同来做。现在来看原题，受上述做法的启发我们可以在 $S$ 上一位一位确定。</p>
<p>考虑设 $f_{i,x,e,y}$ 表示 $S$ 前 $i$ 个字符中有 $e$ 个 <code>E</code>，$y$ 个 <code>Y</code>，通过 $x$ 次交换能得到的字符串个数。转移的时候我们尝试在第 $i$ 位放上 <code>K</code>，<code>E</code> 或 <code>Y</code>，并通过上述贪心算出需要的操作次数，就可以转移了。通过一些预处理可以达到最终 $\mathcal{O}(|S|^5)$ 的时间复杂度。注意转移的时候 $x$ 上界没必要到 $k$，到 $n^2$ 就足够了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">40</span>, B = <span class="number">1e3</span>; <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll; ll dp[N][B + <span class="number">10</span>][N][N]; </span><br><span class="line"><span class="keyword">char</span> s[N]; <span class="keyword">int</span> n, K[N], E[N], Y[N], Ki[N], Ei[N], Yi[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> kk; <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, s + <span class="number">1</span>, &amp;kk); n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        K[i] = K[i - <span class="number">1</span>] + (s[i] == <span class="string">&#x27;K&#x27;</span>);</span><br><span class="line">        E[i] = E[i - <span class="number">1</span>] + (s[i] == <span class="string">&#x27;E&#x27;</span>);</span><br><span class="line">        Y[i] = Y[i - <span class="number">1</span>] + (s[i] == <span class="string">&#x27;Y&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;K&#x27;</span>) Ki[K[i]] = i;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;E&#x27;</span>) Ei[E[i]] = i;</span><br><span class="line">        <span class="keyword">else</span> Yi[Y[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> e = <span class="number">0</span>; e &lt; i; ++e)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; e + y &lt; i; ++y)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> k = i - e - y - <span class="number">1</span>; </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; B; ++x)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!dp[i - <span class="number">1</span>][x][e][y]) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (Ki[k + <span class="number">1</span>])</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">int</span> pos = Ki[k + <span class="number">1</span>], add = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">if</span> (E[pos] &gt; e) add += E[pos] - e;</span><br><span class="line">                        <span class="keyword">if</span> (Y[pos] &gt; y) add += Y[pos] - y;</span><br><span class="line">                        dp[i][x + add][e][y] += dp[i - <span class="number">1</span>][x][e][y]; </span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (Ei[e + <span class="number">1</span>])</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">int</span> pos = Ei[e + <span class="number">1</span>], add = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">if</span> (K[pos] &gt; k) add += K[pos] - k;</span><br><span class="line">                        <span class="keyword">if</span> (Y[pos] &gt; y) add += Y[pos] - y;</span><br><span class="line">                        dp[i][x + add][e + <span class="number">1</span>][y] += dp[i - <span class="number">1</span>][x][e][y]; </span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (Yi[y + <span class="number">1</span>])</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">int</span> pos = Yi[y + <span class="number">1</span>], add = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">if</span> (K[pos] &gt; k) add += K[pos] - k;</span><br><span class="line">                        <span class="keyword">if</span> (E[pos] &gt; e) add += E[pos] - e;</span><br><span class="line">                        dp[i][x + add][e][y + <span class="number">1</span>] += dp[i - <span class="number">1</span>][x][e][y];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e = <span class="number">0</span>; e &lt;= n; ++e)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; e + y &lt;= n; ++y)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt;= B &amp;&amp; x &lt;= kk; ++x) ans += dp[n][x][e][y];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="F-Treasure-Hunting"><a href="#F-Treasure-Hunting" class="headerlink" title="F - Treasure Hunting"></a>F - Treasure Hunting</h4><p>给出一个 $n\times m$ 的网格 $a$，每一个的权值为 $a_{i,j}$。现在从 $(1,1)$ 出发，只能往下或往右走到 $(n,m)$。这样一条路径的权值为经过的 $n+m-1$ 个格子中权值前 $k$ 大的格子的权值之和。求出所有可能的路径中权值最小为多少。($1\le n,m\le30,1\le k\le n+m,1\le a_{i,j}\le10^9$)</p>
<p>$n,m$ 都比较小，我们考虑枚举一下路径上第 $k$ 大的权值到底是多少。固定下来这个值 $x$ 之后，就可以进行 $\rm dp$ 了。考虑设 $f_{i,j,k}$ 表示当前路径到 $(j,k)$ 了，路径上的权值有 $i$ 个大于等于 $x$。转移比较显然，但注意一个细节，当 $a_{j,k}=x$ 时，既可以算到那 $i$ 个数里面，也可以不算。总之可以 $\mathcal{O}(nmk)$ 转移，算上枚举 $x$ 的复杂度，最近时间复杂度 $\mathcal{O}(n^2m^2k)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">40</span>; <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll dp[N &lt;&lt; <span class="number">1</span>][N][N], ans = <span class="number">1e18</span>; <span class="keyword">int</span> mp[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, k; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;mp[i][j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n; ++i) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        x = mp[i][j]; <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span> (dp));</span><br><span class="line">        <span class="keyword">if</span> (mp[<span class="number">1</span>][<span class="number">1</span>] &gt;= x) dp[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] = mp[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (mp[<span class="number">1</span>][<span class="number">1</span>] &lt;= x) dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt;= k; ++a) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">1</span>; b &lt;= n; ++b) <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">1</span>; c &lt;= m; ++c)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (b != n)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (a != k &amp;&amp; mp[b + <span class="number">1</span>][c] &gt;= x) </span><br><span class="line">                        dp[a + <span class="number">1</span>][b + <span class="number">1</span>][c] = std::<span class="built_in">min</span>(dp[a + <span class="number">1</span>][b + <span class="number">1</span>][c], dp[a][b][c] + mp[b + <span class="number">1</span>][c]);</span><br><span class="line">                    <span class="keyword">if</span> (mp[b + <span class="number">1</span>][c] &lt;= x)</span><br><span class="line">                        dp[a][b + <span class="number">1</span>][c] = std::<span class="built_in">min</span>(dp[a][b + <span class="number">1</span>][c], dp[a][b][c]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (c != m)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (a != k &amp;&amp; mp[b][c + <span class="number">1</span>] &gt;= x)</span><br><span class="line">                        dp[a + <span class="number">1</span>][b][c + <span class="number">1</span>] = std::<span class="built_in">min</span>(dp[a + <span class="number">1</span>][b][c + <span class="number">1</span>], dp[a][b][c] + mp[b][c + <span class="number">1</span>]);</span><br><span class="line">                    <span class="keyword">if</span> (mp[b][c + <span class="number">1</span>] &lt;= x)</span><br><span class="line">                        dp[a][b][c + <span class="number">1</span>] = std::<span class="built_in">min</span>(dp[a][b][c + <span class="number">1</span>], dp[a][b][c]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ans = std::<span class="built_in">min</span>(ans, dp[k][n][m]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="G-Divisors-of-Binomial-Coefficient"><a href="#G-Divisors-of-Binomial-Coefficient" class="headerlink" title="G - Divisors of Binomial Coefficient"></a>G - Divisors of Binomial Coefficient</h4><p>求 $\dbinom{n}{k}$ 的约数个数对 $998,244,353$ 取模的结果。($1\le n\le10^{12},0\le k\le\min(10^6,n)$)</p>
<p>对于一个正整数 $n$，根据唯一分解定理，有 $n=\prod_{p_i} p_i^{e_i}$，则 $n$ 的约数个数为 $\prod_{p_i}(e_i+1)$，证明用乘法原理显然。则我们把二项式系数拆成下降幂 $\dfrac{n^{\underline{k}}}{k!}$ 的形式后，分别求出 $n,n-1,\cdot\cdot\cdot,n-k+1$ 和 $k,k-1,\cdot\cdot\cdot,1$ 这 $2k$ 个数分解质因数后的结果，即能套上述式子得到答案。当然 $n$ 的范围很大，不能直接分解质因数。不过我们可以利用 $n$ 大于 $\sqrt{n}$ 的质因数至多只有一个的性质，只判断 $\sqrt{n}$ 范围内的质数。如果朴素分解质因数得到的复杂度为 $\mathcal{O}(\dfrac{k^2}{\log k})$，不足以通过本题。但注意到，需要分解质因数的数是一些连续正整数，这样我们不去一一枚举每个数，而是去枚举每个质数，找到在对应范围内质数的所有倍数对其最终指数贡献即可。时间复杂度类似埃氏筛的时间复杂度 $\mathcal{O}(k\log \log k)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>, mod = <span class="number">998244353</span>; <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> p[N], vis[N], tp; ll a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n, k; <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) vis[i] = <span class="number">1</span>, p[++tp] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tp &amp;&amp; <span class="number">1ll</span> * p[j] * i &lt; N; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[i * p[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll d = n - k, ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) a[i] = i + d; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, e; i &lt;= tp; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        e = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = p[i], tmp; j &lt;= k; j += p[i])</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = j;</span><br><span class="line">            <span class="keyword">while</span> (tmp % p[i] == <span class="number">0</span>) --e, tmp /= p[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (ll j = (d + p[i]) / p[i] * p[i]; j &lt;= n; j += p[i])</span><br><span class="line">            <span class="keyword">while</span> (a[j - d] % p[i] == <span class="number">0</span>) ++e, a[j - d] /= p[i];</span><br><span class="line">        (ans *= (e + <span class="number">1</span>)) %= mod;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) <span class="keyword">if</span> (a[i] &gt; <span class="number">1</span>) (ans *= <span class="number">2</span>) %= mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="H-Eat-Them-All"><a href="#H-Eat-Them-All" class="headerlink" title="H - Eat Them All"></a>H - Eat Them All</h4><p>给出一个 $3\times 3$ 的网格，第 $i$ 行第 $j$ 列上有 $a_{i,j}$ 个物品。从 $(1,1)$ 出发，每次移动时先取走当前格子的一个物品，再移动到上下左右相邻的任意一个位置。当当前格子没有物品时便停止移动。找到满足以下条件的路径或报告无解：</p>
<ul>
<li>最后停在 $(1,1)$。</li>
<li>每个格子上都没有物品了。</li>
</ul>
<p>($1\le a_{i,j}\le100$)</p>
<p>细节挺多的一道题，但是一点点分析还是很有条理的。首先显然我们能把题中给出的网格图换成 $9$ 个点 $12$ 条边的二分图（在相邻两个点之间连无向边，建图可以黑白染色建）。则原问题要求找到的路径满足的条件即为：</p>
<ol>
<li>对于每个点，与它相邻的边被经过的次数和恰好为 $2\times a_{i,j}$（因为到这里需要一次，拿走又需要一次）</li>
<li>去掉经过次数为 $0$ 的边后原图仍然连通（保证最终能回到 $(1,1)$）</li>
</ol>
<p>在构造出最终的路径前，我们需要给每条边定一个经过次数，使得 1,2 条件均被满足，再根据这个经过次数找一条欧拉回路。对于条件 1 的限制，发现可以通过最大流模型解决，即源点向左部点连容量为 $2\times a_{i,j}$ 的边，右部点向汇点连 $2\times a_{i,j}$ 的边，有边相连的左右部点连容量为 $\infty$ 的边，如果源汇点相邻的边容量之和不相等，则无解。但这样有个问题，不能保证去掉 $0$ 边后原图仍然连通。所以我们考虑枚举边集的 $2^{12}$ 个子集中能使得原图连通的若干子集。我们钦定枚举到的子集内所有边均为非 $0$ 边，即已经通过一次了。假如当前与 $u$ 相邻的边中有 $deg_u$ 个已经被钦定经过了，则它与源点或汇点之间连的边容量改为 $2\times a_{i,j}-deg_u$，如果容量为负数则无解。我们跑出来个最大流，就能获得每条边被经过的次数了。</p>
<p>有了经过次数之后，直接 $\rm dfs$ 一遍同时记录一下路径就能找到答案了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> id(x, y) ((x - 1) * 3 + y)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200</span>, inf = <span class="number">1e9</span>; <span class="keyword">int</span> d[N], a[<span class="number">5</span>][<span class="number">5</span>], s, t;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span> <span class="keyword">int</span> v, next, c; &#125;E[N]; <span class="keyword">int</span> p[N], cur[N], cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(p, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span> (p)); cnt = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123; E[cnt].c = c; E[cnt].v = v; E[cnt].next = p[u]; p[u] = cnt++; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123; <span class="built_in">insert</span>(u, v, c); <span class="built_in">insert</span>(v, u, <span class="number">0</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span> (d)); d[s] = <span class="number">0</span>; cur[s] = p[s];</span><br><span class="line">    std::queue&lt;<span class="keyword">int</span>&gt; q; q.<span class="built_in">push</span>(s); <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = p[u], v; i + <span class="number">1</span>; i = E[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            v = E[i].v; cur[v] = p[v];</span><br><span class="line">            <span class="keyword">if</span> (d[v] == <span class="number">-1</span> &amp;&amp; E[i].c) d[v] = d[u] + <span class="number">1</span>, q.<span class="built_in">push</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[t] != <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> flow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == t) <span class="keyword">return</span> flow; <span class="keyword">int</span> ans = <span class="number">0</span>, ret;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cur[u], v; i + <span class="number">1</span>; i = E[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        v = E[i].v; cur[u] = i;</span><br><span class="line">        <span class="keyword">if</span> (d[v] == d[u] + <span class="number">1</span> &amp;&amp; E[i].c)</span><br><span class="line">        &#123;</span><br><span class="line">            ret = <span class="built_in">dfs</span>(v, std::<span class="built_in">min</span>(flow, E[i].c));</span><br><span class="line">            E[i].c -= ret; E[i ^ <span class="number">1</span>].c += ret;</span><br><span class="line">            ans += ret; flow -= ret; <span class="keyword">if</span> (!flow) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ans) d[u] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dinic</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> ans = <span class="number">0</span>; <span class="keyword">while</span> (<span class="built_in">bfs</span>()) ans += <span class="built_in">dfs</span>(s, inf); <span class="keyword">return</span> ans; &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DSU</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> f[N], size[N], len;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; len = n; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) f[i] = i, size[i] = <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> f[x] == x ? f[x] : f[x] = <span class="built_in">getf</span>(f[x]); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tx = <span class="built_in">getf</span>(x), ty = <span class="built_in">getf</span>(y); <span class="keyword">if</span> (tx == ty) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span> (size[tx] &lt; size[ty]) f[tx] = ty, size[ty] += size[tx];</span><br><span class="line">        <span class="keyword">else</span> f[ty] = tx, size[tx] += size[ty];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;dsu;</span><br><span class="line">std::vector&lt;std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; e; <span class="keyword">int</span> deg[N], f[N][N];</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= <span class="built_in">id</span>(<span class="number">3</span>, <span class="number">3</span>); ++v)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!f[u][v]) <span class="keyword">continue</span>;</span><br><span class="line">        --f[u][v]; --f[v][u];</span><br><span class="line">        <span class="built_in">dfs</span>(v); path.<span class="built_in">push_back</span>(v); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">3</span>; ++j) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">    s = <span class="number">0</span>; t = <span class="built_in">id</span>(<span class="number">3</span>, <span class="number">3</span>) + <span class="number">1</span>; <span class="keyword">int</span> lim = (<span class="number">1</span> &lt;&lt; <span class="number">12</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">3</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &lt;= <span class="number">3</span>) e.<span class="built_in">emplace_back</span>(<span class="built_in">id</span>(i, j), <span class="built_in">id</span>(i + <span class="number">1</span>, j));</span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= <span class="number">3</span>) e.<span class="built_in">emplace_back</span>(<span class="built_in">id</span>(i, j), <span class="built_in">id</span>(i, j + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> S = <span class="number">0</span>; S &lt;= lim; ++S)</span><br><span class="line">    &#123;</span><br><span class="line">        dsu.<span class="built_in">init</span>(<span class="built_in">id</span>(<span class="number">3</span>, <span class="number">3</span>)); </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">id</span>(<span class="number">3</span>, <span class="number">3</span>); ++i) deg[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, u, v; i &lt; <span class="number">12</span>; ++i)</span><br><span class="line">            <span class="keyword">if</span> (S &amp; (<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">            &#123;</span><br><span class="line">                u = e[i].first; v = e[i].second;</span><br><span class="line">                dsu.<span class="built_in">merge</span>(u, v); ++deg[u]; ++deg[v];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">id</span>(<span class="number">3</span>, <span class="number">3</span>) &amp;&amp; flag; ++i)</span><br><span class="line">            <span class="keyword">if</span> (dsu.<span class="built_in">getf</span>(i) != dsu.<span class="built_in">getf</span>(<span class="number">1</span>)) flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span> &amp;&amp; flag; ++i) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">3</span> &amp;&amp; flag; ++j)</span><br><span class="line">            <span class="keyword">if</span> (a[i][j] * <span class="number">2</span> &lt; deg[<span class="built_in">id</span>(i, j)]) flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!flag) <span class="keyword">continue</span>; <span class="built_in">init</span>(); <span class="keyword">int</span> lef = <span class="number">0</span>, rig = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= <span class="number">3</span>; ++i) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">3</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            x = <span class="built_in">id</span>(i, j);</span><br><span class="line">            <span class="keyword">if</span> (x &amp; <span class="number">1</span>) <span class="built_in">addedge</span>(s, x, a[i][j] * <span class="number">2</span> - deg[x]), lef += a[i][j] * <span class="number">2</span> - deg[x];</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">addedge</span>(x, t, a[i][j] * <span class="number">2</span> - deg[x]), rig += a[i][j] * <span class="number">2</span> - deg[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lef != rig) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, u, v; i &lt; <span class="number">12</span>; ++i)</span><br><span class="line">            <span class="keyword">if</span> (S &amp; (<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">            &#123;</span><br><span class="line">                u = e[i].first; v = e[i].second;</span><br><span class="line">                <span class="keyword">if</span> (v &amp; <span class="number">1</span>) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">                <span class="built_in">addedge</span>(u, v, inf);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="built_in">dinic</span>(); <span class="keyword">if</span> (ret != lef) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">id</span>(<span class="number">3</span>, <span class="number">3</span>); ++i) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="built_in">id</span>(<span class="number">3</span>, <span class="number">3</span>); ++j) f[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, u, v; i &lt; cnt; i += <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            u = E[i ^ <span class="number">1</span>].v; v = E[i].v;</span><br><span class="line">            f[u][v] = f[v][u] = inf - E[i].c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, u, v; i &lt; <span class="number">12</span>; ++i)</span><br><span class="line">            <span class="keyword">if</span> (S &amp; (<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">            &#123;</span><br><span class="line">                u = e[i].first; v = e[i].second;</span><br><span class="line">                ++f[u][v]; ++f[v][u];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>); std::<span class="built_in">reverse</span>(path.<span class="built_in">begin</span>(), path.<span class="built_in">end</span>());</span><br><span class="line">        std::string ans; <span class="keyword">int</span> x = <span class="number">1</span>, y = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; path.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tx = path[i] / <span class="number">3</span> + <span class="number">1</span>, ty = path[i] % <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">if</span> (ty == <span class="number">0</span>) --tx, ty = <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">if</span> (tx + <span class="number">1</span> == x) ans += <span class="string">&quot;U&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (tx - <span class="number">1</span> == x) ans += <span class="string">&quot;D&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (ty - <span class="number">1</span> == y) ans += <span class="string">&quot;R&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (ty + <span class="number">1</span> == y) ans += <span class="string">&quot;L&quot;</span>;</span><br><span class="line">            x = tx; y = ty;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; ans &lt;&lt; std::endl; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本场没什么特别的科技之类的。但 H 题我认为比较有价值，它给我们带来的经验是面对一道无从下手的题，可以尝试转化后，分步一点点解决。虽然这样码量会很大，但如果思路清晰码起来也不算太难。当然 E,F 的 $\rm dp$ 也很精彩，可以为我们解决类似问题提供思路。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhiyangfan1234.github.io/2022/01/24/AtCoder%20Beginner%20Contest%20233/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhiyangfan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhiyangfan 的博客小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/24/AtCoder%20Beginner%20Contest%20233/" class="post-title-link" itemprop="url">AtCoder Beginner Contest 233</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-01-24 17:00:23 / 修改时间：17:10:50" itemprop="dateCreated datePublished" datetime="2022-01-24T17:00:23+08:00">2022-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="AtCoder-Beginner-Contest-233"><a href="#AtCoder-Beginner-Contest-233" class="headerlink" title="AtCoder Beginner Contest 233"></a>AtCoder Beginner Contest 233</h2><p>F 写了个奇妙的类似模拟退火的玩意，最终肯定是没过。</p>
<p>还有 Ex 一眼 KD-tree，kuai 了个板子一交发现 $\tt TLE$ 才看到数据范围。</p>
<h3 id="A-10yen-Stamp"><a href="#A-10yen-Stamp" class="headerlink" title="A - 10yen Stamp"></a>A - 10yen Stamp</h3><p>给出 $x,y$，求使得 $x+10k\ge y$ 的最小非负整数 $k$。($1\le x,y\le 10^3$)</p>
<p>稍微变一下就有：$10k=\max(y-x,0)$，即：</p>
<script type="math/tex; mode=display">k=\left\lceil\dfrac{\max(y-x,0)}{10}\right\rceil</script><p>直接算即可，时间复杂度 $\mathcal{O}(1)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in"><span class="keyword">int</span></span>(<span class="built_in">ceil</span>(std::<span class="built_in">max</span>(<span class="number">0</span>, y - x) / <span class="number">10.0</span>)));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="B-A-Reverse"><a href="#B-A-Reverse" class="headerlink" title="B - A Reverse"></a>B - A Reverse</h3><p>给出一个字符串 $S$，和两个整数 $L,R$，输出将 $S$ 中第 $L$ 个字符到第 $R$ 个字符反转后得到的字符串。($1\le |S|\le 10^5$)</p>
<p><code>std::reverse(lef, rig)</code> 函数，能把 <code>lef</code> 到 <code>rig - 1</code> 地址区间内的元素反转。直接套用即可，时间复杂度 $\mathcal{O}(|S|)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l, r; std::string s;</span><br><span class="line">    std::cin &gt;&gt; l &gt;&gt; r &gt;&gt; s;</span><br><span class="line">    std::<span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + l - <span class="number">1</span>, s.<span class="built_in">begin</span>() + r);</span><br><span class="line">    std::cout &lt;&lt; s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="C-Product"><a href="#C-Product" class="headerlink" title="C - Product"></a>C - Product</h3><p>有 $n$ 个袋子，每个袋子里面有 $L_i$ 个球，第 $i$ 个袋子里的第 $j$ 个球上写着 $a_{ij}$。问从每个袋子各拿出一个球使得上面写的数积为 $x$ 的方案数。($n,L_i\ge 2,\prod_{i=1}^n L_i\le 10^5,1\le a_{ij}\le 10^9,1\le x\le 10^{18}$)</p>
<p>注意到所有可能的情况是 $\prod_{i=1}^n L_i$ 而题目保证它在一个合理范围内，所以我们可以直接用 $\rm dfs$ 枚举全部的情况计算。时间复杂度 $\mathcal{O}(\prod L_i)$，注意有符号整型溢出问题。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>; std::vector&lt;<span class="keyword">int</span>&gt; a[N]; <span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">long</span> <span class="keyword">long</span> aim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (now == n + <span class="number">1</span>) <span class="keyword">return</span> (aim == <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>, k = a[now][<span class="number">0</span>]; <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//这个是把连续的 a_&#123;ij&#125; 都合并</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a[now].<span class="built_in">size</span>(); ++i)</span><br><span class="line">        <span class="keyword">if</span> (a[now][i] != k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (aim % k == <span class="number">0</span>) ret += cnt * <span class="built_in">work</span>(now + <span class="number">1</span>, aim / k);</span><br><span class="line">            cnt = <span class="number">1</span>; k = a[now][i];</span><br><span class="line">        &#125; <span class="keyword">else</span> ++cnt;</span><br><span class="line">    <span class="keyword">if</span> (cnt &amp;&amp; aim % k == <span class="number">0</span>) ret += cnt * <span class="built_in">work</span>(now + <span class="number">1</span>, aim / k);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x; <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>, &amp;n, &amp;x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;l);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, x; j &lt;= l; ++j) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x), a[i].<span class="built_in">push_back</span>(x);</span><br><span class="line">        std::<span class="built_in">sort</span>(a[i].<span class="built_in">begin</span>(), a[i].<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">work</span>(<span class="number">1</span>, x));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="D-Count-Interval"><a href="#D-Count-Interval" class="headerlink" title="D - Count Interval"></a>D - Count Interval</h3><p>给出一个长为 $n$ 的序列 $a$ 和一个整数 $k$，求满足以下条件的有序二元组 $(l,r)$ 个数：</p>
<ul>
<li>$1\le l\le r\le n$。</li>
<li>$\sum_{i=l}^r a_i=k$</li>
</ul>
<p>($1\le n\le 2\times10^5,|a_i|\le 10^9,|k|\le 10^{15}$)</p>
<p>这个就显然可以转化成前缀和上的问题，设 $s_i=\sum_{j=1}^i a_j$。则原问题的第二个条件相当于：</p>
<script type="math/tex; mode=display">s_r-s_{l-1}=k</script><p>即 $s_{l-1}=s_r-k$，所以我们可以对于每个 $r$ 考虑对应的 $l-1$ 个数，即对于每个 $r$ 我们找到满足 $1\le i<r,s_i=s_r-k$ 的 $i$ 个数。统计可以用 `std::map` 轻松完成。时间复杂度 $\mathcal{O}(n\log n)$。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>; <span class="keyword">int</span> a[N]; <span class="keyword">long</span> <span class="keyword">long</span> sum[N]; std::map&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="keyword">long</span> <span class="keyword">long</span> k; <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]), sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    mp[<span class="number">0</span>] = <span class="number">1</span>; <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mp.<span class="built_in">count</span>(sum[i] - k) &gt; <span class="number">0</span>) ans += mp[sum[i] - k];</span><br><span class="line">        ++mp[sum[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="E-Σ-k-0-10-100-floor-X／10-k"><a href="#E-Σ-k-0-10-100-floor-X／10-k" class="headerlink" title="E - Σ[k=0..10^100]floor(X／10^k)"></a>E - Σ[k=0..10^100]floor(X／10^k)</h3><p>求：</p>
<script type="math/tex; mode=display">\sum_{k=0}^{10^{100}}\left\lfloor\dfrac{x}{10^k}\right\rfloor</script><p>的值。($1\le x\le 10^{5\times 10^5}$)</p>
<p>如果我们把 $x$ 表示为多项式的形式：</p>
<script type="math/tex; mode=display">x=\sum_{i=0}^{L}a_i10^i</script><p>其中 $L=\lfloor\log_{10}x\rfloor$。则式子其实相当于：</p>
<script type="math/tex; mode=display">\sum_{k=0}^{L}\sum_{i=k}^La_i10^{i-k}</script><p>简单变换有：</p>
<script type="math/tex; mode=display">\sum_{k=0}^{L}\sum_{i=0}^{L-k}a_{i+k}10^{i}</script><p>交换求和顺序：</p>
<script type="math/tex; mode=display">\sum_{i=0}^L10^i\sum_{k=0}^{L-i}a_{i+k}=\sum_{i=0}^L10^i\sum_{k=i}^{L}a_{k}</script><p>后面的就是个前缀和（看起来是后缀，但其实我们按照字符串读入的时候已经反转过了，所以是前缀），预处理之后可以直接求。这道题唯一麻烦的一点是需要高精度，简单实现一下就好。时间复杂度 $\mathcal{O}(\log x)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">10</span>; <span class="keyword">char</span> s[N]; <span class="keyword">int</span> a[N], sum[N], ans[N &lt;&lt; <span class="number">1</span>], tp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>); <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = s[i] - <span class="string">&#x27;0&#x27;</span>, sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        ans[++tp] = (sum[i] + k) % <span class="number">10</span>, k = (sum[i] + k) / <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (k) ans[++tp] = k % <span class="number">10</span>, k /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = tp; i &gt;= <span class="number">1</span>; --i) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="F-Swap-and-Sort"><a href="#F-Swap-and-Sort" class="headerlink" title="F - Swap and Sort"></a>F - Swap and Sort</h3><p>有一个 $1\sim n$ 的排列 $\mathcal{P}$。一共能在上面执行 $m$ 种操作，每种操作用一个二元组 $(a_i,b_i)$ 描述，表示交换 $\mathcal{P}_{a_i},\mathcal{P}_{b_i}$。求能否在 $5\times10^5$ 次操作内将 $\mathcal{P}$ 按升序排列，如果能构造出方案，否则报告无解。($2\le n\le 10^3,1\le m\le \min(2\times10^5,\frac{n(n-1)}{2}),\forall i\ne j$，都有 $(a_i,b_i)\ne (a_j,b_j)$)</p>
<p>我们首先从报告无解的角度思考，即什么样的情况是无解的。注意到操作与操作之间是有传递性的，即 $\mathcal{P}_i,\mathcal{P}_j$ 可交换，$\mathcal{P}_j,\mathcal{P}_k$ 可交换，则 $\mathcal{P}_i,\mathcal{P}_k$ 可交换，可以通过构造方案证明。满足这种性质的条件通常可以建模为图论模型，用连通性的传递性来表示可交换的传递性。具体来讲，对于每个操作 $(a_i,b_i)$，我们在 $\mathcal{P}_{a_i},\mathcal{P}_{b_i}$ 之间连一条无向边，这样原图会被分为若干个连通块。同一连通块之中的点两两可以相互交换，不同连通块之间的点不能交换。所以如果存在一个连通块使得存在一个 $i$ 满足 $\mathcal{P}_i$ 不属于该连通块，则原问题无解。</p>
<p>接下来考虑构造方案。在形成的无向图中，注意到我们找到它的一个生成森林不会影响结果（因为连通性不变）。这样，在生成森林中我们优先考虑叶子结点，因为它们能进行的操作最少，不需要枚举考虑。并暴力 $\rm dfs$ 找到一种方案把这个点换到该换的位置，如果找不到（其实就是上文讨论过的 $i,\mathcal{P}_i$ 不在同一连通块）则无解。否则记录下该方案并将这个点删去，表示以后不再影响。这个方法看起来很暴力，但是细细分析，每次最多进行的操作次数为 $999,998,\cdot\cdot\cdot,1$，和为 $499,500$ 满足题目要求。时间复杂度 $\mathcal{O}(n^3)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">10</span>, M = <span class="number">5e5</span> + <span class="number">10</span>; </span><br><span class="line"><span class="keyword">int</span> deg[N], p[N], rev[N], ans[M], tp; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DSU</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> f[N], len;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; len = n; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) f[i] = i; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x == f[x] ? x : f[x] = <span class="built_in">getf</span>(f[x]); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tx = <span class="built_in">getf</span>(x), ty = <span class="built_in">getf</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (tx != ty) &#123; f[tx] = ty; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;dsu;</span><br><span class="line">std::vector&lt;std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; vec[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> aim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == aim) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : vec[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (v.first == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dfs</span>(v.first, u, aim))</span><br><span class="line">        &#123;</span><br><span class="line">            ans[++tp] = v.second;</span><br><span class="line">            std::<span class="built_in">swap</span>(rev[p[v.first]], rev[p[u]]);</span><br><span class="line">            std::<span class="built_in">swap</span>(p[v.first], p[u]);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n); dsu.<span class="built_in">init</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p[i]), rev[p[i]] = i;</span><br><span class="line">    <span class="keyword">int</span> m; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span> (dsu.<span class="built_in">merge</span>(x, y))</span><br><span class="line">        &#123;</span><br><span class="line">            ++deg[x]; ++deg[y];</span><br><span class="line">            vec[x].<span class="built_in">emplace_back</span>(y, i);</span><br><span class="line">            vec[y].<span class="built_in">emplace_back</span>(x, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t = n;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (deg[i] != <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> x = rev[i];</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(i, <span class="number">-1</span>, x)) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>), <span class="number">0</span>;</span><br><span class="line">            --deg[i]; <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : vec[i]) --deg[v.first];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tp; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ans[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="G-Strongest-Takahashi"><a href="#G-Strongest-Takahashi" class="headerlink" title="G - Strongest Takahashi"></a>G - Strongest Takahashi</h3><p>给出一个 $n\times n$ 的网格，其中一些格子是黑色的，其余的为白色。可以进行若干次以下操作：</p>
<ul>
<li>选择一个 $1\sim n$ 的正整数 $d$，并在网格上选择任意一个 $d\times d$ 的正方形。</li>
<li>花费 $d$ 的代价把这个正方形内所有黑色格子变白。</li>
</ul>
<p>求把所有格子均变为白色的最小代价。($1\le n\le50$)</p>
<p>注意到对于任意一个矩形 $(lx,ly,rx,ry)$（其中 $(lx,ly)$ 表示左上角点的坐标，$(rx,ry)$ 表示右下角点的坐标）我们显然可以用 $\max(ly-lx+1,ry-rx+1)$ 的代价把它之中的所有黑色格子消除。但什么时候存在更小的代价呢？显然，如果矩形内存在一行或一列满足所有的格子均为白色，则我们就可以以这一行或者这一列为分割线将矩形分为两个子矩形分别处理，可以发现，这一定会比最朴素的情况更优。而对于子矩阵的处理就相当于原问题的子问题了，可以用 $\rm dp$ 或记忆化搜索解决。暴力实现是 $\mathcal{O}(n^6)$，实现稍微精细一点可以做到 $\mathcal{O}(n^5)$。但不管哪种，由于有大量状态是无法达到的，所以这个复杂度常数很小，都足以通过。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">60</span>, inf = N * N; <span class="keyword">int</span> f[N][N][N][N]; <span class="keyword">char</span> s[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> lx, <span class="keyword">int</span> ly, <span class="keyword">int</span> rx, <span class="keyword">int</span> ry)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lx &gt; rx || ly &gt; ry) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (f[lx][ly][rx][ry] &lt; inf) <span class="keyword">return</span> f[lx][ly][rx][ry];</span><br><span class="line">    <span class="keyword">int</span> t = std::<span class="built_in">max</span>(ry - ly + <span class="number">1</span>, rx - lx + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lx; i &lt;= rx; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = ly; j &lt;= ry &amp;&amp; flag; ++j) flag &amp;= (s[i][j] == <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (flag) t = std::<span class="built_in">min</span>(t, <span class="built_in">dp</span>(lx, ly, i - <span class="number">1</span>, ry) + <span class="built_in">dp</span>(i + <span class="number">1</span>, ly, rx, ry));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = ly; i &lt;= ry; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = lx; j &lt;= rx &amp;&amp; flag; ++j) flag &amp;= (s[j][i] == <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (flag) t = std::<span class="built_in">min</span>(t, <span class="built_in">dp</span>(lx, ly, rx, i - <span class="number">1</span>) + <span class="built_in">dp</span>(lx, i + <span class="number">1</span>, rx, ry));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[lx][ly][rx][ry] = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s[i] + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k) <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= n; ++l) f[i][j][k][l] = inf;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">dp</span>(<span class="number">1</span>, <span class="number">1</span>, n, n)); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Ex-Manhattan-Christmas-Tree"><a href="#Ex-Manhattan-Christmas-Tree" class="headerlink" title="Ex - Manhattan Christmas Tree"></a>Ex - Manhattan Christmas Tree</h3><p>给出一个平面上的 $n$ 个点，第 $i$ 个点坐标为 $(x_i,y_i)$。现在有 $q$ 次询问，每次询问在曼哈顿距离下距离点 $(a_i,b_i)$ 第 $k_i$ 近的点与 $(a_i,b_i)$ 的距离。($1\le n,q\le 10^5,0\le x_i,y_i,a_i,b_i\le 10^5,1\le k\le n,\forall i\ne j$，都有 $(a_i,b_i)\ne (a_j,b_j)$)</p>
<p>有一个经典的 trick，遇到曼哈顿距离下的一些问题，可以考虑通过旋转坐标系使曼哈顿距离变为切比雪夫距离，而后者往往在某些题目需要的方面有更优的性质。我们定义曼哈顿距离 $d_m((x_1,y_1),(x_2,y_2))=|x_1-x_2|+|y_1-y_2|$，定义切比雪夫距离 $d_q((x_1,y_1),(x_2,y_2))=\max(|x_1-x_2|,|y_1-y_2|)$。如果我们把平面上与 $(x,y)$ 曼哈顿距离不超过 $d$ 的点构成的区域画出来就有：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/74ht6hbh.png" alt=""></p>
<p>这是一个正方形。证明可以考虑上面的点的解析式，不妨先看第一象限。它们的坐标满足 $x+y=d$，即一个与 $x$ 轴夹角为 $45\degree$ 的直线。推广一下，这个图形就是正方形。</p>
<p>如果我们把平面上与 $(x,y)$ 切比雪夫距离不超过 $d$ 的点构成的区域画出来就有：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/u0fsgrux.png" alt=""></p>
<p>这也是一个正方形。证明比较显然。边长是上面曼哈顿距离构成的正方形的 $\sqrt{2}$ 倍。</p>
<p>而我们把每个点看成极坐标 $(\rho,\theta)$，对应的普通坐标为 $(\rho\cos\theta,\rho\sin\theta)$。如果把平面逆时针旋转 $\dfrac{\pi}{4}$，则坐标会变为 $\left(\rho,\theta+\dfrac{\pi}{4}\right)$。而转换成普通坐标就有 $\left(\rho\cos\left(\theta+\dfrac{\pi}{4}\right),\rho\sin\left(\theta+\dfrac{\pi}{4}\right)\right)$，用一下三角函数的和角公式就能得到：$\left(\rho\dfrac{\sqrt{2}}{2}(\cos\theta-\sin\theta),\rho\dfrac{\sqrt{2}}{2}(\cos\theta+\sin\theta)\right)$，代入 $x=\rho\cos\theta,y=\rho\sin\theta$ 并把横纵坐标缩小 $\sqrt{2}$ 倍就能得到旋转后的坐标 $(x-y,x+y)$。那这么旋转有啥用呢？注意到旋转完后，曼哈顿距离的正方形就变为了切比雪夫的正方形，所以曼哈顿距离也就变为了切比雪夫距离。</p>
<p>回到原问题，考虑二分这个距离。我们数出与该点距离小于等于当前二分的答案的点个数，根据它与 $k$ 的大小关系判断。而这个数数其实就是二维数点。但值域太大，我们不能直接用朴素的树状数组维护。但因为 $y$ 可能的值不多，我们把每种 $y$ 的值开一个数组，里面塞上从小到大排的 $x$。这样查询的时候找到对应的数组在里面二分就可以了。时间复杂度 $\mathcal{O}(n\log^2n+q\log^3n)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>; std::vector&lt;std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; p;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BIT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; c[N &lt;&lt; <span class="number">1</span>]; <span class="keyword">int</span> len;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = y; i &lt;= len; i += <span class="built_in">lowbit</span>(i)) c[i].<span class="built_in">push_back</span>(x); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> y, <span class="keyword">int</span> lx, <span class="keyword">int</span> rx)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>; y = std::<span class="built_in">min</span>(std::<span class="built_in">max</span>(y, <span class="number">0</span>), len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = y; i; i -= <span class="built_in">lowbit</span>(i))</span><br><span class="line">            ans += std::<span class="built_in">upper_bound</span>(c[i].<span class="built_in">begin</span>(), c[i].<span class="built_in">end</span>(), rx) - std::<span class="built_in">lower_bound</span>(c[i].<span class="built_in">begin</span>(), c[i].<span class="built_in">end</span>(), lx);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> lx, <span class="keyword">int</span> ly, <span class="keyword">int</span> rx, <span class="keyword">int</span> ry)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">query</span>(ry, lx, rx) - <span class="built_in">query</span>(ly - <span class="number">1</span>, lx, rx); &#125;</span><br><span class="line">&#125;bit;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bit.len = N * <span class="number">2</span>; <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n); </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y), p.<span class="built_in">emplace_back</span>(x - y + <span class="number">1</span>, x + y + <span class="number">1</span>);</span><br><span class="line">    std::<span class="built_in">sort</span>(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : p) bit.<span class="built_in">add</span>(v.first, v.second);</span><br><span class="line">    <span class="keyword">int</span> q; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b, k; i &lt;= q; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;k);</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = N * <span class="number">2</span>, mid, ans;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (bit.<span class="built_in">query</span>(a - b - mid + <span class="number">1</span>, a + b - mid + <span class="number">1</span>, a - b + mid + <span class="number">1</span>, a + b + mid + <span class="number">1</span>) &gt;= k) ans = mid, r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhiyangfan1234.github.io/2022/01/24/AtCoder%20Beginner%20Contest%20232/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhiyangfan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhiyangfan 的博客小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/24/AtCoder%20Beginner%20Contest%20232/" class="post-title-link" itemprop="url">AtCoder Beginner Contest 232</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-01-24 17:00:23 / 修改时间：17:10:47" itemprop="dateCreated datePublished" datetime="2022-01-24T17:00:23+08:00">2022-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="AtCoder-Beginner-Contest-232"><a href="#AtCoder-Beginner-Contest-232" class="headerlink" title="AtCoder Beginner Contest 232"></a>AtCoder Beginner Contest 232</h2><p>F 想到状压没写完转移是这样的。</p>
<h3 id="A-QQ-solver"><a href="#A-QQ-solver" class="headerlink" title="A - QQ solver"></a>A - QQ solver</h3><p>给出一个长为 $3$ 的字符串 $S$，其中 $S_1,S_3$ 为 <code>0-9</code> 的字符之一，$S_2$ 为 <code>x</code>。求出该乘法算式的值。</p>
<p>腾 讯 解 决 者。直接模拟就好了，没什么可说的，时间复杂度 $\mathcal{O}(1)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (s[<span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>) * (s[<span class="number">3</span>] - <span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>ps. 这题还可以这样：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b; <span class="built_in">scanf</span>(<span class="string">&quot;%dx%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a * b); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="B-Caesar-Cipher"><a href="#B-Caesar-Cipher" class="headerlink" title="B - Caesar Cipher"></a>B - Caesar Cipher</h3><p>我们对于一个字符串 $S$ 定义如下操作：</p>
<ul>
<li>选择一个非负整数 $k$，并把 $S$ 的所有字符在模意义下加上 $k$。</li>
</ul>
<p>给出 $S,T$，求 $S$ 能否通过恰好一次操作变为 $T$。($1\le |S|=|T|\le 10^5$) </p>
<p>因为只有一次操作，所以如果可行的话，$\forall 1\le i\le |S|$，$(T_i-S_i)\bmod{26}$ 都应该相等，直接判就好。时间复杂度 $\mathcal{O}(|S|)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>; <span class="keyword">char</span> s[N], t[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, s + <span class="number">1</span>, t + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> n = (<span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> d = (t[<span class="number">1</span>] - s[<span class="number">1</span>] + <span class="number">26</span>) % <span class="number">26</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (d != (t[i] - s[i] + <span class="number">26</span>) % <span class="number">26</span>) &#123; <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="C-Graph-Isomorphism"><a href="#C-Graph-Isomorphism" class="headerlink" title="C - Graph Isomorphism"></a>C - Graph Isomorphism</h3><p>给出两张 $n$ 个结点 $m$ 条边的图，问在不考虑结点编号的情况下两张图是否相同，即问两张图是否同构。($1\le n\le 8,0\le m\le \frac{n(n-1)}{2}$)</p>
<p>$n$ 非常小，所以我们可以直接按照题目中给出的图的同构定义模拟：</p>
<blockquote>
<p>两张图 $G=(V,E),G’=(V’,E’)$ 同构，当且仅当 $|V|=|V’|,|E|=|E’|$，且满足 $\exist \mathcal{P}$ 为 $1\sim |V|$ 的一个排列，有 $(i,j)\in E$，当且仅当 $(\mathcal{P}_i,\mathcal{P}_j)\in E’$。</p>
</blockquote>
<p>直接以 $\mathcal{O}(n!)$ 时间复杂度暴力枚举全排列即可。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> p[<span class="number">10</span>], a[<span class="number">200</span>], b[<span class="number">200</span>], c[<span class="number">200</span>], d[<span class="number">200</span>];</span><br><span class="line"><span class="keyword">int</span> E[<span class="number">10</span>][<span class="number">10</span>], G[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a[i], &amp;b[i]), E[a[i]][b[i]] = E[b[i]][a[i]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;c[i], &amp;d[i]), G[c[i]][d[i]] = G[d[i]][c[i]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) p[i] = i;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n &amp;&amp; flag; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n &amp;&amp; flag; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == j) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> ((!E[i][j] &amp;&amp; G[p[i]][p[j]]) || (!G[p[i]][p[j]] &amp;&amp; E[i][j])) flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123; <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (std::<span class="built_in">next_permutation</span>(p + <span class="number">1</span>, p + n + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="D-Weak-Takahashi"><a href="#D-Weak-Takahashi" class="headerlink" title="D - Weak Takahashi"></a>D - Weak Takahashi</h3><p>给出一张 $h\times w$ 的网格，其中一些格子有障碍。求出从 $(1,1)$ 出发只向下走或向右走最多能到达多少格子。($1\le h,w\le 100$，$(1,1)$ 没有障碍)</p>
<p>显然的暴力是指数级别枚举每次走的方向，而又注意到其实在每个相同的地方能走到的格子个数是一样的，所以考虑记忆化搜索。这样每个格子最多到达一次，时间复杂度降低至 $\mathcal{O}(hw)$，足以通过本题。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> mp[<span class="number">200</span>][<span class="number">200</span>]; <span class="keyword">int</span> f[<span class="number">200</span>][<span class="number">200</span>], ans, n, m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> nxt[<span class="number">2</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f[x][y] != <span class="number">-1</span>) <span class="keyword">return</span> f[x][y];</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tx = x + nxt[i][<span class="number">0</span>], ty = y + nxt[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (mp[tx][ty] == <span class="string">&#x27;#&#x27;</span> || tx &lt; <span class="number">1</span> || ty &lt; <span class="number">1</span> || tx &gt; n || ty &gt; m) <span class="keyword">continue</span>;</span><br><span class="line">        ret = std::<span class="built_in">max</span>(<span class="built_in">dfs</span>(tx, ty), ret);</span><br><span class="line">    &#125;</span><br><span class="line">    f[x][y] = ++ret; ans = std::<span class="built_in">max</span>(ans, f[x][y]);</span><br><span class="line">    <span class="keyword">return</span> f[x][y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span> (f));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, mp[i] + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">1</span>)); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="E-Rook-Path"><a href="#E-Rook-Path" class="headerlink" title="E - Rook Path"></a>E - Rook Path</h3><p>有一个 $h\times w$ 的棋盘，在 $(x_1,y_1)$ 处有一个车。车的移动规则是能到达任意一个和它同列或同行的格子，但不能留在原地，问移动恰好 $k$ 次最终到达 $(x_2,y_2)$ 的方案数有多少种，答案对 $998,244,353$ 取模。($2\le h,w\le 10^9,1\le k\le 10^6$)</p>
<p>计数问题可以直接往 $\rm dp$ 方向或者推式子方向想，显然这玩意不能直接在棋盘上 $\rm dp$，且因为车的移动比较复杂，所以如果推式子也会非常复杂。所以我们要考虑巧妙设计一下 $\rm dp$ 状态。注意到车每次移动会且仅会改变行或列的其中一个，所以关键在于车的行是否为 $x_2$，列是否为 $y_2$。这样我们就可以设 $f_{i,0/1,0/1}$ 表示 $i$ 次移动后，车在不在 $x_2$ 行，在不在 $y_2$ 列的方案数。边界条件是 $f_{0,[x_1=x_2],[y_1=y_2]}=1$。转移就比较显然了：</p>
<ul>
<li>$f_{i,0,0}$：<ul>
<li>$f_{i,0,0}\leftarrow f_{i-1,0,0}$，这个表示原来都不在现在还是都不在，转移方案数是不能留在原地和到达 $x_2,y_2$，即 $h+w-4$。</li>
<li>$f_{i,0,0}\leftarrow f_{i-1,1,0}$，这个表示原来在 $x_2$ 这次跑走了，转移方案数是不能留在原地（不考虑到达 $y_2$，因为只能动行），即 $h-1$。</li>
<li>$f_{i,0,0}\leftarrow f_{i-1,0,1}$，这个表示原来在 $x_2$ 这次跑走了，转移方案类似上一种，即 $w-1$。</li>
</ul>
</li>
<li>$f_{i,0,1}$：<ul>
<li>$f_{i,0,1}\leftarrow f_{i,0,0}$，这个表示原来不在 $y_2$ 现在跑到 $y_2$ 了，只有 $1$ 种方案。</li>
<li>$f_{i,0,1}\leftarrow f_{i,0,1}$，这个表示原来不在 $x_2$ 现在还是不在，且不能动列，方案数是不能留在原地和到达 $x_2$，即 $h-2$。</li>
<li>$f_{i,0,1}\leftarrow f_{i,1,1}$，这个表示原来在 $x_2$ 现在走了，方案数是不能留在原地，即 $h-1$。</li>
</ul>
</li>
<li>$f_{i,1,0}$<ul>
<li>$f_{i,1,0}\leftarrow f_{i,0,0}$，类似 $f_{i,0,1}$ 的转移，方案数只有 $1$ 种。</li>
<li>$f_{i,1,0}\leftarrow f_{i,1,0}$，类似 $f_{i,0,1}$ 的转移，方案数是 $w-2$。</li>
<li>$f_{i,1,0}\leftarrow f_{i,1,1}$，类似 $f_{i,0,1}$ 的转移，方案数是 $w-1$.</li>
</ul>
</li>
<li>$f_{i,1,1}$：<ul>
<li>$f_{i,1,1}\leftarrow f_{i,1,0}$，这个表示原来不在 $y_2$ 现在走到了，方案数只有 $1$ 种。</li>
<li>$f_{i,1,1}\leftarrow f_{i,0,1}$，这个表示原来不在 $x_2$ 现在走到了，方案数只有 $1$ 种。</li>
</ul>
</li>
</ul>
<p>有了转移，就可以递推了，最终答案即为 $f_{k,1,1}$。时间复杂度 $\mathcal{O}(k)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>, mod = <span class="number">998244353</span>; <span class="keyword">int</span> f[N][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h, w, k; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;h, &amp;w, &amp;k);</span><br><span class="line">    <span class="keyword">int</span> x1, x2, y1, y2; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">    f[<span class="number">0</span>][x1 == x2][y1 == y2] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i][<span class="number">0</span>][<span class="number">0</span>] = (<span class="number">1ll</span> * f[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] * (h + w - <span class="number">4</span>) + <span class="number">1ll</span> * f[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>] * (w - <span class="number">1</span>) + <span class="number">1ll</span> * f[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>] * (h - <span class="number">1</span>)) % mod;</span><br><span class="line">        f[i][<span class="number">0</span>][<span class="number">1</span>] = (<span class="number">1ll</span> * f[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] + <span class="number">1ll</span> * f[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>] * (h - <span class="number">2</span>) + <span class="number">1ll</span> * f[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] * (h - <span class="number">1</span>)) % mod;</span><br><span class="line">        f[i][<span class="number">1</span>][<span class="number">0</span>] = (<span class="number">1ll</span> * f[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] + <span class="number">1ll</span> * f[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>] * (w - <span class="number">2</span>) + <span class="number">1ll</span> * f[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] * (w - <span class="number">1</span>)) % mod;</span><br><span class="line">        f[i][<span class="number">1</span>][<span class="number">1</span>] = (f[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>] + f[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>]) % mod; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[k][<span class="number">1</span>][<span class="number">1</span>]); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="F-Simple-Operations-on-Sequence"><a href="#F-Simple-Operations-on-Sequence" class="headerlink" title="F - Simple Operations on Sequence"></a>F - Simple Operations on Sequence</h3><p>有一个长为 $n$ 的序列 $a$，可以进行以下两种操作：</p>
<ul>
<li>选择一个满足 $1\le i\le n$ 的 $i$，并把 $a_i$ 加上 $1$，代价为 $x$。</li>
<li>选择一个满足 $1\le i&lt;n$ 的 $i$，并交换 $a_i,a_{i+1}$，代价为 $y$。</li>
</ul>
<p>给出一个长为 $n$ 的序列 $b$，求通过以上两种操作使 $a,b$ 相等的最小代价。($2\le n\le 18,1\le x\le 10^8,1\le y\le10^{16},1\le a_i,b_i\le10^8$)</p>
<p>注意到其实一次交换是改变了 $a,b$ 数组之间下标的对应关系，而一次加 $1$ 其实是尝试把当前匹配上的 $a,b$ 变的相等。再结合 $n$ 很小的条件，我们可以考虑状压 $\rm dp$。考虑设 $f_{S}$ 表示当前考虑过的 $a$ 与 $b$ 的匹配情况。具体来讲，$S_i=1$ 当且仅当 $a_i$ 有匹配上的 $b_j$。那转移思路就比较显然了，就是每次新增加一个 $a_i$ 的匹配，给它分配当前匹配到的 $b_j$，并计算它俩匹配需要的交换次数和加和次数。具体来讲，转移式子如下：</p>
<script type="math/tex; mode=display">f_{S\operatorname{or}2^i}=\min_{0\le i<n,S\operatorname{and}2^i=0}\{f_S+x|a_{i+1}-b_{cnt+1}|+y\mathbf{g}(S,i)\}</script><p>我们转移的思路是顺次匹配 $b_i$，每次选择一个 $a_i$ 和它匹配。其中我们定义 $cnt$ 为 $S$ 中 $1$ 的个数，定义 $\mathbf{g}(S,x)$ 为满足 $S\operatorname{and}2^i=0,i<x$ 的 $i$ 个数。这个就是如果想让 $a_{i+1},b_{cnt+1}$ 匹配上需要的交换次数。最终答案即为 $f_{2^n-1}$，边界为 $f_{0}=0$。时间复杂度 $\mathcal{O}(n2^n)$。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>; <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll a[N], b[N], f[<span class="number">1</span> &lt;&lt; N], x, y; <span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">if</span> ((S &amp; (<span class="number">1</span> &lt;&lt; i)) == <span class="number">0</span> &amp;&amp; i &lt; x) ++ret;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld%lld&quot;</span>, &amp;n, &amp;x, &amp;y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;b[i]);</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span> (f)); f[<span class="number">0</span>] = <span class="number">0</span>; <span class="keyword">int</span> all = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> S = <span class="number">0</span>; S &lt;= all; ++S)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (S &amp; (<span class="number">1</span> &lt;&lt; i)) ++cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (S &amp; (<span class="number">1</span> &lt;&lt; i)) <span class="keyword">continue</span>;</span><br><span class="line">            f[S | (<span class="number">1</span> &lt;&lt; i)] = std::<span class="built_in">min</span>(f[S | (<span class="number">1</span> &lt;&lt; i)], f[S] + x * std::<span class="built_in">abs</span>(a[i + <span class="number">1</span>] - b[cnt + <span class="number">1</span>]) + y * <span class="built_in">calc</span>(S, i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, f[all]); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="G-Modulo-Shortest-Path"><a href="#G-Modulo-Shortest-Path" class="headerlink" title="G - Modulo Shortest Path"></a>G - Modulo Shortest Path</h3><p>给出一个有 $n$ 个结点的图，结点 $i$ 到结点 $j$ 有一条权值为 $(a_i+b_j)\bmod{m}$ 的有向边，求 $1$ 到 $n$ 的最短路。($2\le n\le 2\times10^5,2\le m\le 10^9$)</p>
<p>显然直接建图是不可能的，面对这种边很多的题我们一般的思路都是去掉一些没用的边，使边的级别到达合理的程度。但这道题原图并没有什么可以比较好的减边思路，所以我们考虑转化一下原图。注意到权值是在模 $m$ 意义下的，所以我们考虑建立一个模 $m$ 的剩余系构成的圈，并在这上面连一些边来达到相同的效果。</p>
<p>具体来讲，我们在原题的点集上新增一个点集 $\mathcal{A}=(\overline{0},\overline{1},\overline{2},\cdot\cdot\cdot,\overline{m-1})$ 用来构造边对应的值，其中为了和原来的点区分，我们在新加入的点上面标上横线。所以有 $\overline{i}\rightarrow\overline{(i+1)\bmod{m}}$ 权值为 $1$ 的边。这样会构成一个圈，以下是 $m=8$ 的情况：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/4fdbao2l.png" alt=""></p>
<p>然后对于原来的点，其中一种可能的构造方式是：</p>
<ul>
<li>对于所有的 $1\le i\le n$，有 $i\rightarrow\overline{(-a_i)\bmod{m}}$ 权值为 $0$ 的边。</li>
<li>对于所有的 $1\le i\le n$，有 $\overline{b_i}\rightarrow i$ 权值为 $0$ 的边。</li>
</ul>
<p>这样从 $i$ 到 $j$ 就是从 $\overline{(-a_i)\bmod{m}}$ 走到 $\overline{b_j}$，距离即为 $(a_i+b_j)\bmod{m}$。比如对于图 $G,a=(1,2,3,4),b=(2,3,4,5),m=8$，对应的新图为：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/gxzsg72z.png" alt=""></p>
<p>其中为了表示区分，原图的点我标记为 $\tt(a,b,c,d)$。可以自己试试，这个确实是成立的。</p>
<p>但这还不够，边的级别仍然是 $\mathcal{O}(n+m)$ 这样一个很大的级别。不过我们注意到，其实有很多边可以合并（比如上图中的 $5\rightarrow 6,6\rightarrow 7$ 其实就可以合并为一个权值为 $2$ 的边）那如果我们把能合并的边都合并了，则其实原图的边数就仅有 $\mathcal{O}(n)$ 级别了。因为外层圈仅有 $n$ 个点是关键点，其余的点都会被压缩，得到的边也就只有 $n$ 个。具体实现见代码，总之跑 $\rm Dijkstra$ 最短路的时间复杂度是 $\mathcal{O}(n\log n)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>; <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll; std::map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; id;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span> <span class="keyword">int</span> v, next, w; &#125;E[N &lt;&lt; <span class="number">3</span>]; <span class="keyword">int</span> p[N &lt;&lt; <span class="number">3</span>], cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(p, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span> (p)); cnt = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123; E[cnt].w = w; E[cnt].v = v; E[cnt].next = p[u]; p[u] = cnt++; &#125;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N], st[N], vis[N], tn, tp; ll dis[N]; std::priority_queue&lt;std::pair&lt;ll, <span class="keyword">int</span>&gt; &gt; pq;</span><br><span class="line"><span class="function">ll <span class="title">Dij</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span> (dis)); dis[s] = <span class="number">0</span>;</span><br><span class="line">    pq.<span class="built_in">emplace</span>(-dis[s], s);</span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> r = pq.<span class="built_in">top</span>(); pq.<span class="built_in">pop</span>(); <span class="keyword">int</span> u = r.second;</span><br><span class="line">        <span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>; vis[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = p[u], v; i + <span class="number">1</span>; i = E[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            v = E[i].v; </span><br><span class="line">            <span class="keyword">if</span> (dis[v] &gt; dis[u] + E[i].w) </span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = dis[u] + E[i].w;</span><br><span class="line">                pq.<span class="built_in">emplace</span>(-dis[v], v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>(); <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m); tn = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        <span class="keyword">if</span> (!id[m - a[i]]) id[m - a[i]] = ++tn, st[++tp] = m - a[i];</span><br><span class="line">        <span class="built_in">insert</span>(i, id[m - a[i]], <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[i]);</span><br><span class="line">        <span class="keyword">if</span> (!id[b[i]]) id[b[i]] = ++tn, st[++tp] = b[i];</span><br><span class="line">        <span class="built_in">insert</span>(id[b[i]], i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">sort</span>(st + <span class="number">1</span>, st + tp + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; tp; ++i) <span class="built_in">insert</span>(id[st[i]], id[st[i + <span class="number">1</span>]], (st[i + <span class="number">1</span>] - st[i]) % m);</span><br><span class="line">    <span class="built_in">insert</span>(id[st[tp]], id[st[<span class="number">1</span>]], (m + st[<span class="number">1</span>] - st[tp]) % m);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">Dij</span>(<span class="number">1</span>, n)); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="H-King’s-Tour"><a href="#H-King’s-Tour" class="headerlink" title="H - King’s Tour"></a>H - King’s Tour</h3><p>有一块 $h\times w$ 的棋盘，在 $(1,1)$ 处有一个王。王的移动规则是可以横，竖或斜着走，但一次只能走一格。构造出王在到达每个格子恰好一次后停留在 $(a,b)$ 的方案。($2\le h,w\le 100$)</p>
<p>最水的 H 题了，真应该跟 F 题换换。本题图片来自 AT 题解。首先考虑平凡情况，当 $h=2$ 时，我们可以通过如下的方式移动：</p>
<p><img src="https://img.atcoder.jp/ghi/45d400563f38eb01ffea2e66239b9664.png" alt=""></p>
<p>具体来讲，我们构造如下的序列：</p>
<ul>
<li>$(1,1)\rightarrow(2,1)\rightarrow(1,2)\rightarrow(2,2)\rightarrow(1,3)\rightarrow(2,3)\rightarrow\cdot\cdot\cdot\rightarrow(1,b-1)\rightarrow(2,b-1)\rightarrow(3-a,b)\rightarrow$</li>
<li>$(1,b+1)\rightarrow(1,b+2)\rightarrow\cdot\cdot\cdot\rightarrow(1,w)\rightarrow(2,w)\rightarrow(2,w-1)\cdot\cdot\cdot\rightarrow(2,b+1)\rightarrow(a,b)$</li>
</ul>
<p>然后是另一种平凡情况。当 $w=2$ 时，我们可以通过交换行和列来把它变成 $h=2$ 的情况。</p>
<p>最后是一般情况。当 $h&gt;2,w&gt;2$ 时，我们考虑通过走这个 $S$ 区域来达到缩小棋盘的目的：</p>
<p><img src="https://img.atcoder.jp/ghi/6a11b9fe7eebca4ddd44a12826580c99.png" alt=""></p>
<p>如果 $(a,b)$ 不在 $S$ 区域内，我们就可以走完 $S$，这样问题就变为了行颠倒一下，列数减少 $1$ 的子问题。</p>
<p>如果 $(a,b)$ 在 $S$ 区域内，简单通过交换行和列就可以让 $(a,b)$ 不在 $S$ 区域内了。</p>
<p>这样我们就把原问题变为了两个平凡情况和两个可以变为子问题的情况。每次缩小规模会缩小一行或一列（取决于当前交换了一次行和列的意义），所以总共递归的次数级别为 $\mathcal{O}(h+w)$。因为最终答案是 $\mathcal{O}(hw)$ 级别的，所以时间复杂度为 $\mathcal{O}(hw)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="function">std::vector&lt;pii&gt; <span class="title">solve</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> w, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;pii&gt; ret;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= b - <span class="number">1</span>; ++i)</span><br><span class="line">            ret.<span class="built_in">emplace_back</span>(<span class="number">1</span>, i), ret.<span class="built_in">emplace_back</span>(<span class="number">2</span>, i);</span><br><span class="line">        ret.<span class="built_in">emplace_back</span>(<span class="number">3</span> - a, b);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = b + <span class="number">1</span>; i &lt;= w; ++i) ret.<span class="built_in">emplace_back</span>(<span class="number">1</span>, i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &gt; b; --i) ret.<span class="built_in">emplace_back</span>(<span class="number">2</span>, i);</span><br><span class="line">        ret.<span class="built_in">emplace_back</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((h &gt; <span class="number">2</span> &amp;&amp; w == <span class="number">2</span>) || (b == <span class="number">1</span>) || (a == h &amp;&amp; b == <span class="number">2</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        ret = <span class="built_in">solve</span>(w, h, b, a);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : ret) std::<span class="built_in">swap</span>(p.first, p.second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= h; ++i) ret.<span class="built_in">emplace_back</span>(i, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">auto</span> t = <span class="built_in">solve</span>(h, w - <span class="number">1</span>, h + <span class="number">1</span> - a, b - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : t) </span><br><span class="line">        &#123;</span><br><span class="line">            ++p.second; p.first = h + <span class="number">1</span> - p.first;</span><br><span class="line">            ret.<span class="built_in">push_back</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h, w, a, b; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;h, &amp;w, &amp;a, &amp;b);</span><br><span class="line">    <span class="keyword">auto</span> ans = <span class="built_in">solve</span>(h, w, a, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : ans) <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, p.first, p.second);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhiyangfan1234.github.io/2022/01/24/AtCoder%20Beginner%20Contest%20236/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhiyangfan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhiyangfan 的博客小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/24/AtCoder%20Beginner%20Contest%20236/" class="post-title-link" itemprop="url">AtCoder Beginner Contest 236</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-01-24 17:00:23 / 修改时间：17:10:58" itemprop="dateCreated datePublished" datetime="2022-01-24T17:00:23+08:00">2022-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="AtCoder-Beginner-Contest-236"><a href="#AtCoder-Beginner-Contest-236" class="headerlink" title="AtCoder Beginner Contest 236"></a>AtCoder Beginner Contest 236</h2><p>实现了新年前上蓝的 flag</p>
<h3 id="A-chukodai"><a href="#A-chukodai" class="headerlink" title="A - chukodai"></a>A - chukodai</h3><blockquote>
<p>给出一个只含有小写字母的字符串 $S$，交换第 $a$ 个和第 $b$ 个字符后输出。($2\le |S|\le 10$)</p>
</blockquote>
<p>直接上 <code>std::swap</code> 函数，没什么好说的。时间复杂度 $\mathcal{O}(1)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>; <span class="keyword">char</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a, b; <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, s + <span class="number">1</span>, &amp;a, &amp;b); std::<span class="built_in">swap</span>(s[a], s[b]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s + <span class="number">1</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="B-Who-is-missing"><a href="#B-Who-is-missing" class="headerlink" title="B - Who is missing?"></a>B - Who is missing?</h3><blockquote>
<p>有 $4n$ 张卡片，数字 $i(1\le i\le n)$ 对应的卡片恰有 $4$ 张。现在拿走了一张，给出剩下的 $4n-1$ 张卡片，求出拿走了哪张。($1\le n\le 10^5$)</p>
</blockquote>
<p>开个桶记录一下哪个数字出现了 $3$ 次就好，唯一的坑点是数组要开 $4$ 倍。时间复杂度 $\mathcal{O}(n)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">10</span>; <span class="keyword">int</span> a[N], cnt[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span> * n - <span class="number">1</span>; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]), ++cnt[a[i]];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (cnt[i] == <span class="number">3</span>) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i), <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="C-Route-Map"><a href="#C-Route-Map" class="headerlink" title="C - Route Map"></a>C - Route Map</h3><blockquote>
<p>给出 $n$ 个字符串 $S$ 和 $m$ 个字符串 $T$，对于所有的 $S_i(1\le i\le n)$，求它是否在 $T$ 中出现过。($2\le m\le n\le 10^5,\sum=\{\mathtt{a\sim z}\}$)</p>
</blockquote>
<p>直接 <code>std::map</code> 记录就行。时间复杂度 $\mathcal{O}(n\log n)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; map&lt;string, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>; std::string s[N], t[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> n, m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; s[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) cin &gt;&gt; t[i], mp[t[i]] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">puts</span>(mp[s[i]] ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="D-Dance"><a href="#D-Dance" class="headerlink" title="D - Dance"></a>D - Dance</h3><blockquote>
<p>$2n$ 个人，第 $i$ 个人和第 $j$ 个人组合会得到 $a_{i,j}(i&lt;j)$ 的权值。如果第 $i$ 组得到的权值是 $b_i$，则一个分组方案的权值是 $\bigoplus_{i=1}^n b_i$，其中 $\oplus$ 表示按位异或。求分组方案中最大的权值。($1\le n\le 8,1\le a_{ij}&lt;2^{30}$)</p>
</blockquote>
<p>写了个 $(2n)!$ 的暴力交上去才想起来复杂度不对。不过这题正解确实是暴力 $\rm dfs$ 哈，但不能太暴力，直接枚举 $2n$ 个人的全排列是不行的。正确的复杂度是每次选俩人，其中一个是根据 $\rm dfs$ 状态钦定的，另一个是枚举的，这样大概的状态总数只有 $15\times13\times11\cdot\cdot\cdot\times 3=2,027,025$ 足以通过本题。时间复杂度 $\mathcal{O}(?)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">17</span>; <span class="keyword">int</span> n, ans, a[N][N], vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> c)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &gt; <span class="number">2</span> * n) <span class="keyword">return</span> ans = std::<span class="built_in">max</span>(ans, c), <span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">	<span class="keyword">if</span> (vis[x]) <span class="keyword">return</span> <span class="built_in">dfs</span>(x + <span class="number">1</span>, c);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = x + <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; ++i) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">		vis[x] = vis[i] = <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(x + <span class="number">1</span>, c ^ a[x][i]);</span><br><span class="line">		vis[x] = vis[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">2</span> * n; ++i) </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= <span class="number">2</span> * n; ++j) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>); <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="E-Average-and-Median"><a href="#E-Average-and-Median" class="headerlink" title="E - Average and Median"></a>E - Average and Median</h3><blockquote>
<p>给出一个长为 $n$ 的序列 $a$，现在从中选出若干项，满足对于所有的 $1\le i&lt;n$，第 $a_i$ 和 $a_{i+1}$ 至少有一个被选。求选出的数可能的最大平均数和中位数，题目允许平均数一定的精度误差。($2\le n\le 10^5,1\le a_i\le10^9$)</p>
</blockquote>
<p>考虑题目中给的条件——允许精度误差，可以想到二分答案。现在的问题是考虑怎么判断一个序列能否按照上面的规则形成平均数和中位数。</p>
<p>对于某个长为 $n$ 的序列 $b$，判断它的平均数与 $v$ 的关系可以用：</p>
<script type="math/tex; mode=display">\sum_{i=1}^{n}(b_i-v)</script><p>与 $0$ 的关系来判断。同理，判断它的中位数与 $v$ 的关系可以用：</p>
<script type="math/tex; mode=display">\sum_{i=1}^n(-1)^{[b_i<v]}</script><p>与 $0$ 的关系来判断。</p>
<p>所以我们考虑对于原序列 $a$ 找到一个满足题目条件的子序列，且使得上式最大，判断和 $0$ 的关系就能找到二分出来的答案是大了还是小了。显然可以通过 $\rm dp$ 实现，只需设 $f_{i,0/1}$ 表示当前选还是不选。时间复杂度 $\mathcal{O}(n\log a)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>; <span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[N]; <span class="keyword">double</span> dp[N][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">checkAve</span><span class="params">(<span class="keyword">double</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i][<span class="number">1</span>] = std::<span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>]) + a[i] - v;</span><br><span class="line">	<span class="keyword">return</span> std::<span class="built_in">max</span>(dp[n][<span class="number">0</span>], dp[n][<span class="number">1</span>]) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">checkMid</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i][<span class="number">1</span>] = std::<span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>]) + (a[i] &gt;= v ? <span class="number">1</span> : <span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span> std::<span class="built_in">max</span>(dp[n][<span class="number">0</span>], dp[n][<span class="number">1</span>]) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">	<span class="keyword">double</span> l = <span class="number">0</span>, r = <span class="number">1e9</span>, mid;</span><br><span class="line">	<span class="keyword">while</span> (r - l &gt; eps)</span><br><span class="line">	&#123;</span><br><span class="line">		mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">checkAve</span>(mid)) l = mid;</span><br><span class="line">		<span class="keyword">else</span> r = mid;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.9lf\n&quot;</span>, l);</span><br><span class="line">	<span class="keyword">int</span> L = <span class="number">0</span>, R = <span class="number">1e9</span>, MID, ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (L &lt;= R)</span><br><span class="line">	&#123;</span><br><span class="line">		MID = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">checkMid</span>(MID)) L = MID + <span class="number">1</span>, ans = MID;</span><br><span class="line">		<span class="keyword">else</span> R = MID - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="F-Spices"><a href="#F-Spices" class="headerlink" title="F - Spices"></a>F - Spices</h3><blockquote>
<p>有 $2^n-1$ 种香料，第 $i$ 种价格为 $c_i$。混合 $k$ 种香料，即第 $a_1$ 种，第 $a_2$ 种……第 $a_k$ 种，能获得的辣度是 $\bigoplus_{i=1}^k a_i$。求满足能组合出 $1\sim 2^n-1$ 中任意辣度最少需要花多少钱买香料。($2\le n\le 16,1\le c_i\le 10^9$)</p>
</blockquote>
<p>谢谢你 AT，被这题送上蓝了。线性基板子，考虑线性基一个性质，一个数 $x$ 插入完后，如果 $x=0$，就说明 $x$ 能被当前集合中的数表示出来。所以我们考虑贪心按照价格从小到大插入线性基，一个香料要购买，当且仅当它不能被当前集合的数表示出来。时间复杂度 $\mathcal{O}(2^nn)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>; <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll; <span class="keyword">int</span> p[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">insert</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> ((x &gt;&gt; i) == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> (p[i] == <span class="number">0</span>) &#123;p[i] = x; <span class="keyword">break</span>;&#125;</span><br><span class="line">		x ^= p[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> !x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span> <span class="keyword">int</span> x, id; &#125;a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n; <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i].x), a[i].id = i;</span><br><span class="line">	std::<span class="built_in">sort</span>(a + <span class="number">1</span>, a + (<span class="number">1</span> &lt;&lt; n), [](<span class="keyword">const</span> node&amp; x1, <span class="keyword">const</span> node&amp; x2) &#123; <span class="keyword">return</span> x1.x &lt; x2.x; &#125;);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++)</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">insert</span>(a[i].id)) ans += a[i].x;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="G-Good-Vertices"><a href="#G-Good-Vertices" class="headerlink" title="G - Good Vertices"></a>G - Good Vertices</h3><p>给出一个 $n$ 个点的有向图，点从 $1$ 到 $n$ 编号，初始时没有边。一共 $t$ 个时刻，第 $i$ 个时刻会加入一条 $a_i\rightarrow b_i$ 的有向边，有自环无重边。一个点是好的，当且仅当它能从 $1$ 出发经过恰好 $l$ 条边到达，求出每个点第一次成为好点的时间或报告无法成为好点。($2\le n\le 100,1\le t\le n^2,1\le l\le 10^9$)</p>
<p>考虑先把所有边加入，第 $i$ 时刻加入的边权值为 $i$，则原问题即从 $1$ 到 $u$ 经过恰好 $l$ 条边，且最小化这 $l$ 条边中权值的最大值。像有向图上走一步这种严格按阶段行进的操作，可以考虑 $\rm dp$，考虑设 $f_{i,j}$ 表示 $i$ 号结点经过恰好 $j$ 条边后经过边边权最大值的最小值，则显然有转移：</p>
<script type="math/tex; mode=display">f_{i,j}=\min_{v\rightarrow i\in E}\{\max(f_{v,j-1},w_{v,i})\}</script><p>其中 $w_{v,i}$ 是边 $v\rightarrow i$ 的权值。而如果我们对于所有不存在边 $u\rightarrow v$ 的 $w_{u,v}$ 都设置为 $\infty$，上式还能进一步化为：</p>
<script type="math/tex; mode=display">f_{i,j}=\min_{v=1}^n\{\max(f_{v,j-1},w_{v,i})\}</script><p>写到这儿我们已经得到了 $\mathcal{O}(nl)$ 的做法了，但显然还不够。</p>
<p>来看看上面的式子展开是什么样的：</p>
<script type="math/tex; mode=display">f_{i,j}=\min\{\max(f_{1,j-1},w_{1,i}),\max(f_{2,j-1},w_{2,i}),\cdot\cdot\cdot,\max(f_{n,j-1},w_{n,i})\}</script><p>好像隐隐约约能看到矩阵乘法的影子？考虑把 $\min$ 换为 $+$，$\max$ 换为 $\times$，就很清楚了：</p>
<script type="math/tex; mode=display">f_{i,j}=f_{1,j-1}w_{1,i}+f_{2,j-1}w_{2,i}+\cdot\cdot\cdot+f_{n,j-1}w_{n,i}</script><p>这不就是矩阵乘法的定义了嘛。那就很简单了，构造矩阵如下：</p>
<script type="math/tex; mode=display">\mathbf{A}=\begin{bmatrix}f_{1,0}&f_{2,0}&\cdots&f_{n,0}\end{bmatrix},\mathbf{B}=\begin{bmatrix}
w_{1,1}&w_{1,2}&\cdots&w_{1,n}\\w_{2,1}&w_{2,2}&\cdots&w_{2,n}\\\vdots&\vdots&\ddots&\vdots\\ w_{n,1}&w_{n,2}&\cdots&w_{n,n}\end{bmatrix}</script><p>则有：</p>
<script type="math/tex; mode=display">\begin{bmatrix}f_{1,l}&f_{2,l}&\cdots&f_{n,l}\end{bmatrix}=\mathbf{A}(\mathbf{B}^l)</script><p>而 $f_{i,l}$ 即为最终答案。这里做矩阵乘法的时候只需要把 $+$ 再换回 $\min$，$\times$ 换回 $\max$ 就好，而既然操作都变了，单位矩阵也会变：</p>
<script type="math/tex; mode=display">\mathbf{I}=\begin{bmatrix}0&\infty&\infty&\cdots&\infty\\\infty&0&\infty&\cdots&\infty\\\infty&\infty&0&\cdots&\infty\\\vdots&\vdots&\vdots&\ddots&\vdots\\\infty&\infty&\infty&\infty&0\end{bmatrix}</script><p>其实就是主对角线是 $\max$ 的单位元，其余是 $\min$ 的单位元。直接上矩阵快速幂就好，时间复杂度 $\mathcal{O}(n^3\log l)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>, inf = <span class="number">2e9</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> a[N][N], n, m;</span><br><span class="line">	Matrix <span class="keyword">operator</span>*(<span class="keyword">const</span> Matrix&amp; A)</span><br><span class="line">	&#123;</span><br><span class="line">		Matrix ret; ret.n = n; ret.m = A.m;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= A.m; ++j)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> minx = inf;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= m; ++k) minx = std::<span class="built_in">min</span>(minx, std::<span class="built_in">max</span>(a[i][k], A.a[k][j]));</span><br><span class="line">				ret.a[i][j] = minx;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;A, B, I;</span><br><span class="line"><span class="function">Matrix <span class="title">ksm</span><span class="params">(Matrix A, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Matrix ret = I;</span><br><span class="line">	<span class="keyword">while</span> (b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * A;</span><br><span class="line">		A = A * A; b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, t, l; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;t, &amp;l);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= t; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y), B.a[x][y] = i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">		<span class="keyword">if</span> (!B.a[i][j]) B.a[i][j] = inf;</span><br><span class="line">	B.n = n; B.m = n; A.n = <span class="number">1</span>; A.m = n; I.n = n; I.m = n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) I.a[i][j] = (i == j) ? <span class="number">0</span> : inf;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) A.a[<span class="number">1</span>][i] = (i != <span class="number">1</span>) * inf;</span><br><span class="line">	B = <span class="built_in">ksm</span>(B, l); A = A * B;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, A.a[<span class="number">1</span>][i] == inf ? <span class="number">-1</span> : A.a[<span class="number">1</span>][i]);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>看到这儿，你会不会有疑惑：</p>
<blockquote>
<p>为啥这运算符说变就变啊？难道任意两个二元操作符组合都可以替换 $+$ 和 $\times$ 吗？</p>
</blockquote>
<p>会用到一点群论的知识。这里就简化说了，考虑两个二元运算 $+$ 和 $\times$（这里的符号只是代指，并不是一般意义上我们所说的加法和乘法），则一个集合 $A$ 带上这俩运算 $(A,+,\times)$ 是半群的条件是：</p>
<ul>
<li>$(A,+)$ 满足以下条件：<ul>
<li>$+$ 满足结合律，即 $\forall a,b,c\in A$，都有 $(a+b)+c=a+(b+c)$。</li>
<li>存在一个 $+$ 的的单位元 $0$，即 $\exist 0\in A$，满足 $\forall a\in A$，都有 $0+a=a+0=a$。（$0$ 并不是一般意义上的自然数 $0$，而是一个符号代表单位元，下文中 $\times$ 单位元 $1$ 也是同理）</li>
<li>$+$ 满足交换律，即 $\forall a,b\in A$，都有 $a+b=b+a$。</li>
</ul>
</li>
<li>$(A,\times)$ 满足以下条件：<ul>
<li>$\times$ 满足结合律，即 $\forall a,b,c\in A$，都有 $(a\times b)\times c=a\times(b\times c)$。</li>
<li>存在一个 $\times$ 的单位元 $1$，即 即 $\exist 0\in A$，满足 $\forall 1\in A$，都有 $1\times a=a\times 1=a$。</li>
</ul>
</li>
<li>$+,\times$ 满足以下条件：<ul>
<li>满足 $\times$ 对 $+$ 的分配律，即 $\forall a,b,c\in A$，都有 $a\times(b+c)=a\times b+a\times c$。</li>
<li>$\forall a\in A$，都有 $a\times 0=0\times a = 0$，其中 $0$ 指加法单位元。</li>
</ul>
</li>
</ul>
<p>而满足是半群的 $(A,+,\times)$ 就可以类比一般的矩阵乘法定义新的矩阵乘法，并满足一般意义上矩阵乘法优化 $\rm dp$ 所需要的所有性质。</p>
<p>举点半群的例子吧。</p>
<ul>
<li>$A=\mathbb{R}\cup\{-\infty\}$（有人可能会说：“啊你这个就有问题，$-\infty$ 都不是个数怎么能包含进数集呢？”但在这里 $-\infty$ 只是充当单位元的作用，你就当是一个极小数吧），$+$ 是 $\max$，$\times$ 是一般的加法。</li>
<li>对于一个正数 $n$，$A=\{x\in\mathbb{N}|x&lt;2^n\}$，$+$ 是按位或，$\times$ 是按位与。</li>
<li>对于一个正数 $n$，$A=\{x\in\mathbb{N}|x&lt;2^n\}$，$+$ 是按位异或，$\times$ 是按位与。</li>
</ul>
<h3 id="Ex-Distinct-Multiples"><a href="#Ex-Distinct-Multiples" class="headerlink" title="Ex - Distinct Multiples"></a>Ex - Distinct Multiples</h3><blockquote>
<p>给出两个整数 $n,m$，和一个长为 $n$ 的序列 $d$。找出满足以下条件的长为 $n$ 的序列 $a$ 个数：</p>
<ul>
<li>$\forall 1\le i\le n$，都有 $1\le a_i\le m$。</li>
<li>$\forall i\ne j$，都有 $a_i\ne a_j$。</li>
<li>$\forall 1\le i\le n$，都有 $d_i|a_i$。</li>
</ul>
<p>答案对 $998,244,353$ 取模。($2\le n\le 16,1\le d_i\le m\le 10^{18}$)</p>
</blockquote>
<p>考虑原问题并不好做，好做的问题是对于一个序列，所有数都相同，且满足都是 $d_i$ 的倍数的方案数。而从这里入手的话，我们考虑容斥。构造一个 $n$ 个点的无向图，其中边集为 $S\subseteq \{(i,j)|1\le i&lt;j\le n,i,j\in\mathbb{Z}\}$，所有连通块内的 $a_i$ 都相同。边集 $S$ 对应的方案为 $f(S)$，则最终答案即为：</p>
<script type="math/tex; mode=display">\sum_{S}f(S)(-1)^{|S|}</script><p>对于一个点集 $T$，考虑设 $g(T)$ 为：</p>
<script type="math/tex; mode=display">g(T)=\left\lfloor\dfrac{m}{\operatorname{lcm}_{i\in T}d_i}\right\rfloor</script><p>则连通块 $T$ 的填数方案数即为 $g(T)$。对于一个正整数 $n$，考虑设 $h(n)$ 表示：</p>
<script type="math/tex; mode=display">h(n)=\sum_{S\in E}[P(S,n)](-1)^{|S|},E=\{(i,j)|1\le i<j\le n,i,j\in\mathbb{Z}\}</script><p>其中 $P(S,n)$ 表示边集 $S$ 能否使 $n$ 个点的图连通。则如果把 $S$ 分成 $k$ 个连通块 $T_1,T_2,\cdots,T_k$，得到的方案数即：</p>
<script type="math/tex; mode=display">\prod_{i=1}^k g(T_i)h(|T_i|)</script><p>现在的问题基本就剩求出来这个 $h,g$ 的值了，$g$ 显然可以 $\mathcal{O}(2^n)$ 乱求，但 $h$ 就稍微有点难了。</p>
<p>题解的思路比较长，我没看懂，所以去学了 $\tt \color{black}F\color{red}roggy$ 的 GF 方法。</p>
<p>考虑去掉 $P(S,n)$ 的限制，则形成的图就变为了一般无向图，设这时的 $h(n)$ 对应的 EGF 为 $\hat{F}(x)$，设原来的 $h(n)$ 对应的 EGF 为 $\hat{G}(x)$。而我们好求的是 $\hat{F}(x)$：</p>
<script type="math/tex; mode=display">\hat{F}(x)=\sum_{n\ge 0}\sum_{i\ge 0}\dbinom{\binom{n}{2}}{i}(-1)^i\dfrac{x^n}{n!}=(1-1)^{\binom{n}{2}}\dfrac{x^n}{n!}=[n\le 1]\dfrac{x^n}{n!}=1+x</script><p>接下来由于一般无向图和连通无向图对应 EGF 的联系，我们有：</p>
<script type="math/tex; mode=display">\mathrm{exp}\ \hat{G}(x)=\hat{F}(x)=1+x</script><p>所以有：</p>
<script type="math/tex; mode=display">\hat{G}(x)=\ln(1+x)</script><p>这样，我们 $h(n)$ 的通项就出来了：</p>
<script type="math/tex; mode=display">h(n)=[x^n]\ln(1+x)=(-1)^{n-1}(n-1)!</script><p>更多资料可以参考：<a target="_blank" rel="noopener" href="https://ctp314.github.io/2022/01/24/%E5%85%B3%E4%BA%8E%E4%B8%80%E7%B1%BB%E5%AE%B9%E6%96%A5%E7%9A%84%E6%80%9D%E8%80%83/">卢神的博客</a>。</p>
<p>好，现在我们求完了 $h(n),g(T)$ 现在就是要把它们组合起来了。延续上面的思路，我们设 $f_{T}$ 表示把点集 $T$ 中的点分成</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhiyangfan1234.github.io/2022/01/24/AtCoder%20Grand%20Contest%20003/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhiyangfan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhiyangfan 的博客小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/24/AtCoder%20Grand%20Contest%20003/" class="post-title-link" itemprop="url">AtCoder Grand Contest 003</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-01-24 17:00:23 / 修改时间：17:11:31" itemprop="dateCreated datePublished" datetime="2022-01-24T17:00:23+08:00">2022-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="AtCoder-Grand-Contest-003"><a href="#AtCoder-Grand-Contest-003" class="headerlink" title="AtCoder Grand Contest 003"></a>AtCoder Grand Contest 003</h2><p>xs D题想出来一个图论做法（应该是假的），结果把匈牙利的复杂度记成了 $\mathcal{O}(|V|+|E|)$ ，然后其他啥都写完了就剩匈牙利的时候发现复杂度其实是  $\mathcal{O}(|V||E|)$ ，然后就寄了。</p>
<p>upd. 把 D,E 题总结中混乱，错误的部分纠正了，放上 F 题说明和 E,F 题代码，放上总的总结。</p>
<h4 id="A-Wanna-go-back-home"><a href="#A-Wanna-go-back-home" class="headerlink" title="A - Wanna go back home"></a>A - Wanna go back home</h4><p>一个人在二维平面上行走 $n$ 天，每天会朝东南西北中给定的一个方向前进，问能否通过恰当安排每天前进的距离来使得在 $n$ 天后回到起点。( $1\le n\le1000$ )</p>
<p>注意到如果每天的距离是可以随意安排的，则行进相同方向的若干天可以被合并为一天，这样 $n$ 天就被转化为最多 $4$ 天。只要向东走而不向西走或者向南走而不向北走，就无法回到起点，反之亦然。读入时记录一下，然后 $\mathcal{O}(1)$ 判断即可，最终复杂度就是读入的复杂度，$\mathcal{O}(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> s[N]; <span class="keyword">int</span> book[<span class="string">&#x27;Z&#x27;</span> + <span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>); <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        book[s[i]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((book[<span class="string">&#x27;W&#x27;</span>] ^ book[<span class="string">&#x27;E&#x27;</span>]) || (book[<span class="string">&#x27;S&#x27;</span>] ^ book[<span class="string">&#x27;N&#x27;</span>]))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="B-Simplified-mahjong"><a href="#B-Simplified-mahjong" class="headerlink" title="B - Simplified mahjong"></a>B - Simplified mahjong</h4><p>给出一些卡片，每张卡片上有 $1$ 到 $n$ 之间的整数，写有整数 $i$ 的卡片有 $a_i$ 张。两张卡片可以被合并为一对，当且仅当两张卡片上写的数字差的绝对值小于 $2$ 。求所有卡片最多能组成多少对。( $1\le n\le10^5,0\le a_i\le10^9$ )</p>
<p>如果原题条件改为 $0&lt;a_i\le10^9$ ，则答案应该为 $\left\lfloor\dfrac{S}{2}\right\rfloor$ ，其中 $S=\sum_{i=1}^n a_i$ 。证明的话，首先肯定不可能配对出比 $\left\lfloor\dfrac{S}{2}\right\rfloor$ 更多的对数了，所以要证明的是一定可以找到 $\left\lfloor\dfrac{S}{2}\right\rfloor$ 对。如果我们把所有的牌按照上面写的整数排列成一个不下降序列，$x_1,x_2,\cdot\cdot\cdot,x_{S}$ （其中 $x_i$ 是卡片上写的数字），则一定有 $x_{i+1}-x_i&lt;2$ （否则与  $a_i\neq0$ 矛盾），所以我们可以找到 $\left\lfloor\dfrac{S}{2}\right\rfloor$ 对卡片——$(x_1,x_2),(x_3,x_4),\cdot\cdot\cdot$ 。而如果 $0\le a_i\le10^9$ ，则可能存在一些地方使得 $x_{i+1}-x_i\ge 2$ ，那我就把 $a_i=0$ 的位置当成分割线，把原序列分成若干个满足 $a_i\neq0$ 的子序列。分别求解后相加即可，时间复杂度 $\mathcal{O}(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n); <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!a[i]) &#123; ans += cnt / <span class="number">2</span>; cnt = <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="keyword">else</span> cnt += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ans += cnt / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="C-BBuBBBlesort"><a href="#C-BBuBBBlesort" class="headerlink" title="C - BBuBBBlesort!"></a>C - BBuBBBlesort!</h4><p>给出一个有 $n$ 个整数的序列 $a$ ，满足 $a_i$ 之间互不相同 。我们可以进行两种操作：</p>
<ul>
<li><p>操作 $1$ ：选择两个连续的元素，反转它们的顺序。</p>
</li>
<li><p>操作 $2$ ：选择三个连续的元素，反转它们的顺序。</p>
</li>
</ul>
<p>问最少需要多少次操作 $1$ 才能使原序列从小到大排序。( $1\le n\le10^5,0\le a_i\le10^9,\forall i\neq j,a_i\neq a_j$ )</p>
<p>注意到操作 $2$ 相当于交换两个相隔一位的元素，操作 $1$ 相当于交换两个相邻一位的元素。一个很重要的想法是注意下标奇偶性。对于操作 $2$ ，它是不会改变元素在序列中下标奇偶性的，也就是说，如果一个元素在排序后下标是偶数，但在原序列中下标是奇数，就不可能只通过操作 $2$ 达到使它到该到的位置。</p>
<p>那么一个想法就是排序后统计所有下标奇偶性与原来不同的元素个数，除以 $2$ 后就是答案（因为一次操作 $1$ 可以改变两个元素下标的奇偶性）。证明就以给出构造方法来证明吧。首先我们注意到，如果把原序列分为下标为奇数的和下标为偶数的两个子序列，只使用操作$2$ 的话，对于每个子序列都可以随意交换相邻的元素，而这样就可以达到随意排列这两个序列的目的。那我们就可以通过恰当的操作把需要改变奇偶性的元素成对排到相邻位置然后用操作 $1$ 交换。接着所有的元素都在它该在的子序列中了，接着就可以只用操作 $2$ 使每个元素到达排序后的位置了。时间复杂度就是排序的复杂度，$\mathcal{O}(n\log n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val, pos;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node&amp; x) &#123; <span class="keyword">return</span> val &lt; x.val; &#125;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, ans = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i].val), a[i].pos = i;</span><br><span class="line">    std::<span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//这里只找奇-&gt;偶的，是因为一定会有一个偶-&gt;奇与它形成一对</span></span><br><span class="line">    <span class="comment">//只找一边就不用除以2了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> ((a[i].pos &amp; <span class="number">1</span>) &amp;&amp; !(i &amp; <span class="number">1</span>)) ++ans;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="D-Anticube"><a href="#D-Anticube" class="headerlink" title="D - Anticube"></a>D - Anticube</h4><p>给出有 $n$ 个正整数的序列 $s$ 。现在想从中选取一个子序列 $S$ ，使得 $\forall i,j,S_i\times S_j$ 不是立方数。问 $S$ 中最多能有多少元素。( $1\le n\le 10^5,1\le s_i\le10^{10}$ )</p>
<p>我想的图论做法是最大点独立集….显然不行，这还是一道根正苗红的数论题啊。我们对于每个整数 $x$ ，定义 $norm_x$ 为 $x$ 去掉所有立方因子的正整数，$pair_x$ 为与 $x$ 相乘后为立方数的最小正整数。则我们注意到，如果 $norm_x=pair_y$ ，则 $x,y$ 就不能被同时选取。所以我们统计一下对于所有的 $s_i$ ，$norm_{s_i}$ 出现了多少次，然后对于正整数 $x$ ，如果 $norm_x=norm_y$ ，则 $x=y$ ，如果 $norm_y=pair_x$ ，则 $x,y$ 不能同时选取，所以 $x$ 带来的贡献应该是 $\max(cnt_{norm_x},cnt_{pair_x})$ ，其中 $cnt_t$ 表示 $t$ 在 $norm_{s_i}$ 中的出现次数，因为是选取，所以加上贡献后要把 $cnt_{norm_x},cnt_{pair_x}$ 清 $0$。</p>
<p>问题转化为了如何对于每个 $x$ 快速求解 $norm_x,pair_x$ 。首先直接分解质因数是 $\mathcal{O}(n\sqrt{\max_{s_i}})$ 级别的，会 $\tt TLE$ 。注意到我们要的是立方因子，所以可以只分解到 $\sqrt[3]{\max_{s_i}}$ 的质数，其余算成大质数直接扔到 $norm_x$ 里面就好。分解的时候如果一个质数 $p$ 在 $x$ 中出现了 $c$ 次，则 $norm_x$ 应该乘 $p^{c\operatorname{mod} 3}$ （ $\operatorname{mod}3$ 就是去掉立方因子 ），$pair_x$ 应该乘 $p^{(3-c)\operatorname{mod}3}$ （补上不够立方的部分）。最终剩余的 $x$ 对于 $norm_x$ 的贡献上文提到了，而对于 $pair_x$ 的贡献，如果 $x$ 不是平方数，则还得再乘 $x^2$ 才能构成立方数，否则只需要再乘 $\sqrt{x}$ 就好。算出来 $norm_x$ 和 $pair_x$ 后直接计算就好，筛质数的复杂度为 $\mathcal{O}(\sqrt[3]{s_i})$ ，分解质因数的复杂度为 $\mathcal{O}(\dfrac{\sqrt[3]{s_i}}{\log(\sqrt[3]{s_i})})$ （ 小于等于 $x$ 的质数量级在 $\dfrac{x}{\log x}$ 级别） ，最终计算的复杂度为 $\mathcal{O}(n\log n)$ （带个 $\log$ 是因为需要用 $\rm map$），所以最终复杂度 $\mathcal{O}(\dfrac{\sqrt[3]{s_i}}{\log(\sqrt[3]{s_i})}+n\log n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>; <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> p[N], vis[N], tp; ll norm[N], pair[N]; </span><br><span class="line">std::map&lt;ll, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">getP</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) p[++tp] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; i * p[j] &lt;= n &amp;&amp; j &lt;= tp; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[i * p[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">getP</span>(<span class="number">5e3</span>); <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    ll cnt, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ll x, now = <span class="number">1</span>, y = <span class="number">1</span>; </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;x); </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tp; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (x % p[j] == <span class="number">0</span>) x /= p[j], ++cnt;</span><br><span class="line">            cnt %= <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">if</span> (cnt)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= cnt; ++k)</span><br><span class="line">                    now *= p[j];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = cnt + <span class="number">1</span>; k &lt;= <span class="number">3</span>; ++k)</span><br><span class="line">                    y *= p[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        now *= x; </span><br><span class="line">        <span class="keyword">if</span> ((ll)<span class="built_in">sqrt</span>(x) * (ll)<span class="built_in">sqrt</span>(x) == x) y *= <span class="built_in">sqrt</span>(x);</span><br><span class="line">        <span class="keyword">else</span> y *= x * x;</span><br><span class="line">        ++mp[now]; norm[i] = now; pair[i] = y; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (norm[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        ans += std::<span class="built_in">max</span>(mp[norm[i]], mp[pair[i]]);</span><br><span class="line">        mp[norm[i]] = mp[pair[i]] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans + !!mp[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="E-Sequential-operations-on-Sequence"><a href="#E-Sequential-operations-on-Sequence" class="headerlink" title="E - Sequential operations on Sequence"></a>E - Sequential operations on Sequence</h4><p>给出一个有 $n$ 个整数的序列，初始时第 $i$ 位上的值就是 $i$ 。给出 $Q$ 次操作，每次操作有一个参数 $q_i$ ，然后对原序列进行以下操作：</p>
<ul>
<li>从把当前序列无限复制延伸得到的序列中（如 $1,2,3,4,5$ 就对应着 $1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,\cdot\cdot\cdot$），取出前 $q_i$ 位作为新的序列。</li>
</ul>
<p>在 $Q$ 次操作后，询问 $1$ 到  $n$ 每个数在最终序列中出现了多少次。( $1\le n\le 10^5,0\le Q\le10^5,1\le q_i\le10^{18}$ )</p>
<p>ps. 这个算法比较难理解，不好描述，如果感到困惑的话可以按照算法流程手玩几组数据基本就明白了。</p>
<p>首先我们注意到，如果 $q_i\ge q_{i+1}$ ，则我们就可以忽略 $q_i$ ，因为 $q_i,q_{i+1}$ 和 $q_{i+1}$ 是等价的。所以我们可以通过单调栈，把原修改序列 $q$ 转化为一个上升序列 $b$ 。我们设 $l$ 表示 $b$ 的长度。则我们可以考虑从 $b_l$ 到 $b_1$ 执行操作。</p>
<ul>
<li>首先建一个有 $b_l$ 个元素的序列，每个元素都为 $1$ 。</li>
<li>如果我们当前正在执行操作参数为 $x$ ，则我们把原序列换为一个有 $x$ 元素的序列，新序列的第 $i$ 个元素的值为原序列的所有下标在模 $x$ 意义下等于 $i$ 的元素之和。</li>
<li>最后输出最终序列就是答案。</li>
</ul>
<p>这个过程相当于从最终状态（不考虑本质不同的话，每个数都出现一次），一点点合并成答案状态（考虑本质不同，每个数出现的次数），显然这个复杂度为 $\mathcal{O}(n+Qq_i)$ 级别的，不能接受。所以考虑改进算法。不仅仅是按照 $b_l$ 到 $b_1$ 的顺序单独处理每个操作，考虑以下算法：</p>
<ul>
<li>定义两个数组：$a,t$ ，其中 $t_l=1$ 。</li>
<li><p>我们依然是按照 $b_l$ 到 $b_1$ 的顺序，然后进行到 $b_i$ 时，执行以下操作：</p>
<ul>
<li>令 $k=b_i$ 。</li>
<li><p>对于 $b_{i-1},\cdot\cdot\cdot,b_1$ 我们分别处理，每个执行以下操作：</p>
<ol>
<li><p>假如我们正在处理 $b_j$ 。</p>
</li>
<li><p>如果 $k\ge b_j$ ，则我们给 $t_j$ 加上 $t_i\times \left\lfloor\dfrac{k}{b_j}\right\rfloor$ ，然后把 $k$ 替换为 $k\mod{b_j}$ </p>
</li>
</ol>
</li>
<li>给  $a_1,a_2,\cdot\cdot\cdot,a_{k}$ 加上 $t_i$ 。</li>
</ul>
</li>
<li>最后输出 $a$ 序列就是答案。</li>
</ul>
<p>在这个算法中，$t_i$ 是第 $i$ 次操作后对应的序列在最终序列中出现的次数（也就是循环节），$k$ 的值是除了 $t_i$ 次的出现外在最终序列中元素出现的次数（也就是除了循环以外的余数部分）。而这个算法还需要更进一步优化，注意到 $k$ 的值会有变化，当且仅当 $k\ge b_j$ 。在取模操作下 $k$ 至少减少减少了两倍，所以 $k$ 至多改变 $\mathcal{O}(\log a_i)$ 次。所以我们用二分找到最大的 $j$ ，使得 $k\ge b_j$ ，这样我们就可以对每个 $i$ 做到 $\mathcal{O}(\log Q\log a_i)$ 的复杂度。而用差分我们就可以做到 $\mathcal{O}(1)$ 的区间加 $t$ 。所以最终复杂度为 $\mathcal{O}(Q\log Q\log a_i+n)$ 。</p>
<p>一个小细节是，如果所有的 $b_i$ 都很大，那  $k$ 就会超过 $n$ 的范围从而 $\tt RE$ 。但单纯的把 $k$ 换成 $\min(n,k)$ 只会让 $\tt RE$ 变成 $\tt WA$ ，真正正确的做法是在所有的 $b_i$ 前面加上一个 $b_0=n$ ，这样 $k$ 就保证 $k&lt;n$ ，且不影响正确性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll a[N], t[N], q[N], b[N], stk[N]; <span class="keyword">int</span> tp;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; x, <span class="keyword">const</span> ll&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> x &lt; y ? x : y; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getpos</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, ll val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (r - l &gt; <span class="number">1</span>) mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> mid = r;</span><br><span class="line">        <span class="keyword">if</span> (b[mid] &lt; val) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, Q; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;Q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= Q + <span class="number">1</span>; ++i) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;q[i]);</span><br><span class="line">    q[<span class="number">1</span>] = n; stk[++tp] = q[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= Q + <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (tp &amp;&amp; q[i] &lt;= stk[tp]) --tp;</span><br><span class="line">        stk[++tp] = q[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tp; ++i) b[i] = stk[i];</span><br><span class="line">    t[tp] = <span class="number">1</span>; ll k, x = <span class="number">0</span>; <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = tp; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        k = b[i]; j = i; <span class="keyword">if</span> (!k) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &amp;&amp; (j = <span class="built_in">getpos</span>(<span class="number">0</span>, tp, k)))</span><br><span class="line">            t[j] += t[i] * (k / b[j]), k %= b[j];</span><br><span class="line">        a[<span class="number">1</span>] += t[i]; a[k + <span class="number">1</span>] -= t[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        x += a[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="F-Fraction-of-Fractal"><a href="#F-Fraction-of-Fractal" class="headerlink" title="F - Fraction of Fractal"></a>F - Fraction of Fractal</h4><p>给出一个 $H\times W$ 的网格图，每一格都是黑色或白色，所有的黑色是格子是四连通的，也就是说只横平竖直的移动可以使任意黑色格子之间相互到达。本题中， $\rm fractals$ 分形的定义如下：</p>
<ul>
<li>$0$ 级分形是一个 $1\times 1$ 的网格，其中唯一的格子为黑色。</li>
<li>$k+1$ 级分形是由 $H\times W$ 个 $k$ 级分形大小的网格图组成的，如果在题目中给出的网格图中，对应的位置为黑色，则该位置放上 $k$ 级分形，如果为白色，则该位置全部格子都是白色。</li>
</ul>
<p>给出整数 $k$ ，求 $k$ 级分形中，黑色格子的连通块个数，答案对 $10^9+7$ 取模。( $1\le H,W\le1000,0\le k\le10^{18}$ ，给出的网格图中至少有一个黑色格子)</p>
<p>我们称一个网格是水平连通的，当它存在一行使得这一行最左边和最右边的的格子均为黑色，称一个网格是竖直连通的当它存在一列使得这一列最上边和最下边的格子均为黑色。那当一个网格既水平连通又竖直连通，显然不管 $k$ 等于多少，所有的黑色格子一定是全部连通的，所以这种情况下答案一定是 $1$ 。当一个网格既不水平连通也不竖直连通，则每当分形等级增长时，连通块个数都会乘以 $a$ ，其中 $a$ 是题目给出的网格图中黑色格子的数量，所以答案为 $a^{k-1}$ 。</p>
<p>而对于只水平连通或者只竖直连通的情况，就比较复杂了。不失一般性，我们假设这个网格是水平连通的，但不竖直连通。对于在每个 $k-1$ 级分形中的黑色格子，我们要放一个题目中给定的网格图（分形定义的另一种表述方法），这样黑色格子的连通块个数就会 $+1$ 。但如果 $k-1$ 级分形中有两个黑色格子水平相邻的话，这两个格子对应的网格就会在同一个连通块内了。所以答案就是 $a-b$ ，其中 $a$ 是题目给出的网格图中黑色格子的数量，$b$ 是水平相邻的黑色格子对数。</p>
<p>但注意到 $k$ 非常大，加上这个递推的形式，可以想到列出  $\rm dp$ 式子，然后用矩阵快速幂来优化一下。我们设 $f_i$ 表示 $i$ 级分形的答案，$s_i$ 表示 $i$ 级分形最左列和最右列的连通块个数。则 $f_i=af_i-bs_{i-1}$ ，$s_i=cs_{i-1}$ （其中 $a$ 是题目给出的网格图中黑色格子的数量，$b$ 是水平相邻的黑色格子对数，$c$ 是满足最左端和最右端均为黑色的行数）。根据这个状态转移方程，我们有 $\begin{pmatrix}a&amp;-b\\0&amp;c\end{pmatrix}\begin{pmatrix}f_i\\s_i\end{pmatrix}=\begin{pmatrix}f_{i+1}\\s_{i+1}\end{pmatrix}$ ，所以最终答案就是 $\begin{pmatrix}f_k\\s_k\end{pmatrix}=\begin{pmatrix}a&amp;-b\\0&amp;c\end{pmatrix}^{k-1}\begin{pmatrix}f_1\\s_1\end{pmatrix}$ ，其中 $f_1=s_1=1$ 。</p>
<p>对于只竖直连通的情况，只需要把所有定义倒转一下就好，最终时间复杂度为统计的 $\mathcal{O}(HW)$ ，加上计算的 $\mathcal{O}(\log k)$ ，即 $\mathcal{O}(\log k+HW)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">10</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> n, m; ll a[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line">    Matrix <span class="keyword">operator</span>*(<span class="keyword">const</span> Matrix&amp; X)</span><br><span class="line">    &#123;</span><br><span class="line">        Matrix ret;</span><br><span class="line">        ret.n = n; ret.m = X.m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ret.n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= ret.m; ++j)</span><br><span class="line">                ret.a[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= X.m; ++j)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= m; ++k)</span><br><span class="line">                    ret.a[i][j] = </span><br><span class="line">                    ((ret.a[i][j] + a[i][k] * X.a[k][j] % mod)</span><br><span class="line">                    % mod + mod) % mod;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;A, B, I;</span><br><span class="line"><span class="function">Matrix <span class="title">fpow</span><span class="params">(Matrix A, ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Matrix ret = I;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) ret = ret * A;</span><br><span class="line">        A = A * A;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpow</span><span class="params">(<span class="keyword">int</span> a, ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) ret = <span class="number">1ll</span> * ret * a % mod;</span><br><span class="line">        a = <span class="number">1ll</span> * a * a % mod;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//0:vertically connected, 1:horizontally connected</span></span><br><span class="line"><span class="keyword">char</span> mp[N][N]; <span class="keyword">int</span> a, b[<span class="number">2</span>], c[<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> tag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A.n = A.m = I.n = I.m = <span class="number">2</span>;</span><br><span class="line">    I.a[<span class="number">1</span>][<span class="number">1</span>] = I.a[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    A.a[<span class="number">1</span>][<span class="number">1</span>] = a; A.a[<span class="number">1</span>][<span class="number">2</span>] = -b[tag];</span><br><span class="line">    A.a[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">0</span>; A.a[<span class="number">2</span>][<span class="number">2</span>] = c[tag];</span><br><span class="line">    B.n = <span class="number">2</span>; B.m = <span class="number">1</span>;</span><br><span class="line">    B.a[<span class="number">1</span>][<span class="number">1</span>] = B.a[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; ll k; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, mp[i] + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            <span class="keyword">if</span> (mp[i][j] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ++a;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">1</span>) b[<span class="number">0</span>] += (mp[i][j - <span class="number">1</span>] == <span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">1</span>) b[<span class="number">1</span>] += (mp[i - <span class="number">1</span>][j] == <span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        c[<span class="number">0</span>] += (mp[i][<span class="number">1</span>] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; mp[i][m] == <span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        c[<span class="number">1</span>] += (mp[<span class="number">1</span>][i] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; mp[n][i] == <span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">    <span class="comment">//vertically connected and horizontally connected</span></span><br><span class="line">    <span class="keyword">if</span> (c[<span class="number">0</span>] &amp;&amp; c[<span class="number">1</span>]) &#123; <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="comment">//not vertically connected and not horizontally connected</span></span><br><span class="line">    <span class="keyword">if</span> (!c[<span class="number">0</span>] &amp;&amp; !c[<span class="number">1</span>])</span><br><span class="line">    &#123; <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">fpow</span>(a, k - <span class="number">1</span>)); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="comment">//tag = 1 if c[1]&gt;0, 0 if c[1]=0</span></span><br><span class="line">    <span class="keyword">int</span> tag = !!c[<span class="number">1</span>]; <span class="built_in">init</span>(tag);</span><br><span class="line">    B = <span class="built_in">fpow</span>(A, k - <span class="number">1</span>) * B;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, B.a[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="知识经验总结"><a href="#知识经验总结" class="headerlink" title="知识经验总结"></a>知识经验总结</h3><ol>
<li>题目中如果给出了一些不寻常的操作，考虑把不寻常的操作转化为熟悉的样子，比如反转相邻的 $3$ 个元素就可以视为交换相隔的 $2$ 个元素，还可以视为在下标奇偶性相同的子序列中交换相邻元素。</li>
<li>对于子序列选取问题，除了 $\rm dp$ 枚举选或者不选，如果条件是两两冲突，可以考虑对于每个数，找到与它权值相同的数，和与该权值冲突的数，二者取较大的集合就可以。</li>
<li>对于满足明显递推关系，且递推层数较大的题目，想到找规律或者矩阵快速幂优化。</li>
</ol>
<p>ps. 这套题目思维难度较大（尤其是 E 题那道神仙题），很难总结出较多的经验，只能说锻炼思维了吧。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhiyangfan1234.github.io/2022/01/24/AtCoder%20Grand%20Contest%20002/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhiyangfan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhiyangfan 的博客小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/24/AtCoder%20Grand%20Contest%20002/" class="post-title-link" itemprop="url">AtCoder Grand Contest 002</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-01-24 17:00:23 / 修改时间：17:11:00" itemprop="dateCreated datePublished" datetime="2022-01-24T17:00:23+08:00">2022-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="AtCoder-Grand-Contest-002"><a href="#AtCoder-Grand-Contest-002" class="headerlink" title="AtCoder Grand Contest 002"></a>AtCoder Grand Contest 002</h2><p>xs 刚开始打的时候脑子不太清晰，A 题 $\tt WA$ 了 $\tt 3$ 发，心态直接爆炸。不过后来 D 题整体二分做出来了害挺开心。$\rm RK$ 的话大概是 $85/662$ 。</p>
<h4 id="A-Range-Product"><a href="#A-Range-Product" class="headerlink" title="A - Range Product"></a>A - Range Product</h4><p>给出两个整数 $a,b$ ，问 $\prod_{i=a}^b i$ 是正数，还是负数，还是 $0$ 。( $-10^9\le a\le b\le10^9$ )</p>
<p>简单的观察就可以知道（下面的式子中令 $\dfrac{0}{0}=0$）：</p>
<p>$\dfrac{|\prod_{i=a}^b i|}{\prod_{i=a}^b i}=\begin{cases}-1&amp;a<0\and b<0\and (b-a+1)\equiv 1\pmod{2}\\1&(a>0\and b&gt;0)\or(a&lt;0\and b&lt;0\and (b-a+1)\equiv0\pmod{2}\\0&amp;ab\le0\end{cases}$ </p>
<p>$\mathcal{O}(1)$ 计算即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> a, b; <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="keyword">if</span> (a * b &lt;= <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;Zero\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;Positive\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((b - a + <span class="number">1</span>) &amp; <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Negative\n&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Positive\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="B-Box-and-Ball"><a href="#B-Box-and-Ball" class="headerlink" title="B - Box and Ball"></a><strong>B - Box and Ball</strong></h4><p>有 $n$ 个盒子，把它们从 $1$ 到 $n$ 编号。开始时，$1$ 盒子有一个红球，而其余的盒子有一个白球。现在依次进行 $m$ 次操作，在第 $i$ 次操作中，从 $x_i$ 盒子中随机拿一个球放入 $y_i$ 盒子中。问最终可能含有红球的盒子个数。( $2\le n\le 10^5,1\le m\le10^5,x_i\neq y_i$ ，保证操作合法 )</p>
<p>我们可以这样理解原问题：有 $n$ 个水杯，初始时第 $1$ 个水杯里有 $10\text{mL}$ 红墨水，而其余的水杯有 $10\text{mL}$ 纯净水，每次操作是把 $x_i$ 水杯内的水倒 $10\text{mL}$ 进入 $y_i$ 水杯中（如果倒完了，假设水的颜色不会残留在原水杯中） ，最后在 $m$ 次操作后问有多少个水杯内的水是红色的。因为一旦红球进入过某个盒子，除非把这个盒子的球全部拿完（水全部倒完），否则都有可能红球还留在这个盒子（水如果不全部倒完就会一直是红色的），而除非红球就没可能在这个盒子内，否则在拿到其他盒子时都有可能拿到红球（红水倒进其他水杯会染色）。</p>
<p>那问题就简单了，对于每个盒子维护一个 $cnt$ 表示里面有多少球，一个 $hr$ 表示是否可能有红球。每次操作，如果 $hr_{x_i}=1$ 答案才有可能变化：如果 $cnt_{x_i}&gt;1$ ，$x_i$ 中的球没有全部拿完，依然是红色，而 $y_i$ 被染色，如果 $hr_{y_i}=0$， 答案 $+1$ 就好，记得记录一下 $hr_{y_i}=1$ ；如果 $cnt_{x_i}=1$ ，$x_i$ 中的球拿完了，不可能再有红球了，即 $hr_{x_i}=0$ ，答案 $-1$ ， $y_i$ 被染色，如果 $hr_{y_i}=0$， 答案 $+1$ 就好，记得记录一下 $hr_{y_i}=1$ 。时间复杂度 $\mathcal{O}(n+m)$  。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> cnt[N], hr[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cnt[i] = <span class="number">1</span>;</span><br><span class="line">    hr[<span class="number">1</span>] = <span class="number">1</span>; <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span> (hr[x] &amp;&amp; cnt[x] &gt; <span class="number">1</span>)</span><br><span class="line">        &#123; <span class="keyword">if</span> (!hr[y]) &#123; ++ans; hr[y] = <span class="number">1</span>; &#125; &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (hr[x] &amp;&amp; cnt[x] == <span class="number">1</span>)</span><br><span class="line">        &#123; hr[x] = <span class="number">0</span>; --ans; <span class="keyword">if</span> (!hr[y]) &#123; ++ans; hr[y] = <span class="number">1</span>; &#125; &#125;</span><br><span class="line">        --cnt[x]; ++cnt[y];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="C-Knot-Puzzle"><a href="#C-Knot-Puzzle" class="headerlink" title="C - Knot Puzzle"></a>C - Knot Puzzle</h4><p>有 $n$ 个绳子，把它们从 $1$ 到 $n$ 编号，$i$ 号绳子的长度为 $a_i$ 。初始时，我们对于每个 $i(1\le i\le n-1)$ ，都把 $i$ 号绳子和 $i+1$ 号绳子打个绳结连起来，形成一个上面有 $n-1$ 个绳结的长绳子。接下来我们尝试不断用以下操作来解开所有的绳结：</p>
<ul>
<li>选择一个长度至少为 $L$ 的绳子，解开这个绳子上的一个绳结。</li>
</ul>
<p>如果可能全解开，输出 <code>possible</code> ，然后找到一种解绳结的方案，按解开的顺序输出绳结编号（如果一个绳结连接了 $i$ 和 $i+1$ ，则它的编号是 $i$ ），否则输出 <code>Impossible</code> 。( $2\le n\le 10^5,1\le L\le 10^9,1\le a_i\le 10^9$ )</p>
<p>我们发现，如果一个方案可行，则最终剩下来的 $a_i$ 和 $a_{i+1}$ 一定满足 $a_i+a_{i+1}\le L$ 。所以我们可以找到满足这个条件的一个 $i$ （如果找不到就是无解情况），接着依次解开 $1,2,3,\cdot\cdot\cdot,i-1$ 号绳结，然后再依次解开 $n-1,n-2,n-3,\cdot\cdot\cdot,i+1$ 号绳结，最后解开 $i$ 号绳结。因为每次操作会把整个绳子分为两个部分，一部分只有一个绳子不需要再管了，而另一部分包含 $a_i,a{i+1}$ ，和一定 $\ge L$ ，可以继续操作，所以这样的方案一定合法。时间复杂度 $\mathcal{O}(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum; <span class="keyword">int</span> cut[N], a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, L, pos = <span class="number">-1</span>; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;L);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (a[i] + a[i + <span class="number">1</span>] &gt;= L) </span><br><span class="line">        &#123; pos = i; <span class="keyword">break</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (pos == <span class="number">-1</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;Impossible\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Possible\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; pos; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= pos + <span class="number">1</span>; --i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, pos);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="D-Stamp-Rally"><a href="#D-Stamp-Rally" class="headerlink" title="D - Stamp Rally"></a>D - Stamp Rally</h4><p>给出一个 $n$ 个节点和 $m$ 条边（边从 $1$ 到 $m$ 编号）的连通无向图和 $Q$ 组询问。对于每组询问，给出 $x_i,y_i,z_i$ ，询问两个人分别从 $x_i$ 和 $y_i$ 出发，恰好经过 $z_i$ 个节点（不管是一个人经过多次还是两个人都经过，一个点都只算一次）的情况下，经过边的编号最大值最小可能是多少。( $3\le n\le10^5,n-1\le m\le10^5,1\le Q\le 10^5,x_i\neq y_i,3\le z_i\le n$ ，无自环 )</p>
<p>首先看到 “最大值最小” ，立马想到二分。接着一个 naive 的想法就出来了，对于每组询问，在 $[1,m]$ 范围内二分，<code>check()</code> 函数中，我们用并查集加入前 $mid$ 条边，看 $x_i,y_i$ 能到达的点集合大小是大于 $z_i$ 还是小于 $z_i$ 。这样做的时间复杂度是 $\mathcal{O}(Qm\log m)$ 显然会超时。我们注意到一次 $mid$ 的计算可以决定所有询问的范围，没必要每组询问都建一次图，所以可以考虑整体二分。</p>
<p>可以递归实现，但这里采用了模拟，用队列实现。队列中的节点是三元组 $(L,R,\{\cdot\cdot\cdot\})$ ，其中 $L,R$ 表示当前答案区间为 $(L,R]$ ，$\{\cdot\cdot\cdot\}$ 表示这些询问的答案在前面的答案区间中。初始时我们把 $(0,m,\{1,2,3,\cdot\cdot\cdot,Q\})$ 加入队列。每次取出队首，如果 $L+1=R$ ，直接把 $\{\cdot\cdot\cdot\}$ 内所有询问的答案设为 $R$ 就好。如果 $L+1&lt;R$ ，则令 $MID = \left\lfloor\dfrac{L+R}{2}\right\rfloor$ ，如果并查集内的边小于 $MID$ 个，就把边加到 $MID$ 个；如果大于 $MID$ 个，就清空再加 $MID$ 个（应该可以可持久化一下然后回撤，不过没必要，反正这样暴力搞最多 $\log m$ 次，瓶颈不在这儿），接着对于 $\{\cdot\cdot\cdot\}$ 里面所有的询问判断，如果答案区间在 $(L,MID]$ 中，就加入 $v1$ ，如果答案区间在 $(MID,R]$ ，就加入 $v2$ 。最终把 $(L,MID, v1)$ 和 $(MID, R,v2)$ 入队就好。时间复杂度 $\mathcal{O}(m\log m)$  。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DSU</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> f[N], size[N], maxn;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxn; ++i) f[i] = i, size[i] = <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123; <span class="keyword">return</span> f[u] == u ? u : f[u] = <span class="built_in">getf</span>(f[u]); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t1 = <span class="built_in">getf</span>(u), t2 = <span class="built_in">getf</span>(v);</span><br><span class="line">        <span class="keyword">if</span> (t1 != t2) f[t1] = t2, size[t2] += size[t1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;dsu;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span>&#123;</span> <span class="keyword">int</span> x, y, z; &#125;q[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">int</span> l, r; std::vector&lt;<span class="keyword">int</span>&gt; vec; </span><br><span class="line">    <span class="built_in">node</span>(<span class="keyword">int</span> l = <span class="number">0</span>, <span class="keyword">int</span> r = <span class="number">0</span>, std::vector&lt;<span class="keyword">int</span>&gt; vec = std::vector&lt;<span class="keyword">int</span>&gt;()) :</span><br><span class="line">        <span class="built_in">l</span>(l), <span class="built_in">r</span>(r), <span class="built_in">vec</span>(vec) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N], ans[N]; std::queue&lt;node&gt; tq;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, cnt = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    dsu.maxn = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a[i], &amp;b[i]);</span><br><span class="line">    <span class="keyword">int</span> Q; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;Q); dsu.<span class="built_in">init</span>();</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; ve;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;q[i].x, &amp;q[i].y, &amp;q[i].z), ve.<span class="built_in">push_back</span>(i);</span><br><span class="line">    tq.<span class="built_in">push</span>(<span class="built_in">node</span>(<span class="number">0</span>, m, ve));</span><br><span class="line">    <span class="keyword">while</span> (!tq.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        node u = tq.<span class="built_in">front</span>(); tq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (u.l + <span class="number">1</span> == u.r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; u.vec.<span class="built_in">size</span>(); ++i)</span><br><span class="line">                ans[u.vec[i]] = u.r;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::vector&lt;<span class="keyword">int</span>&gt; v1, v2;</span><br><span class="line">        <span class="keyword">int</span> mid = (u.l + u.r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (cnt &lt; mid)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = cnt + <span class="number">1</span>; i &lt;= mid; ++i)</span><br><span class="line">                dsu.<span class="built_in">merge</span>(a[i], b[i]);</span><br><span class="line">            cnt = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cnt &gt; mid)</span><br><span class="line">        &#123;</span><br><span class="line">            dsu.<span class="built_in">init</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= mid; ++i)</span><br><span class="line">                dsu.<span class="built_in">merge</span>(a[i], b[i]);</span><br><span class="line">            cnt = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, x, y, siz, t1, t2; i &lt; u.vec.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            x = q[u.vec[i]].x, y = q[u.vec[i]].y; siz = <span class="number">0</span>;</span><br><span class="line">            t1 = dsu.<span class="built_in">getf</span>(x), t2 = dsu.<span class="built_in">getf</span>(y);</span><br><span class="line">            <span class="keyword">if</span> (t1 == t2) siz = dsu.size[t1];</span><br><span class="line">            <span class="keyword">else</span> siz = dsu.size[t1] + dsu.size[t2];</span><br><span class="line">            <span class="keyword">if</span> (siz &gt;= q[u.vec[i]].z) v1.<span class="built_in">push_back</span>(u.vec[i]);</span><br><span class="line">            <span class="keyword">else</span> v2.<span class="built_in">push_back</span>(u.vec[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        tq.<span class="built_in">push</span>(<span class="built_in">node</span>(u.l, mid, v1)); </span><br><span class="line">        tq.<span class="built_in">push</span>(<span class="built_in">node</span>(mid, u.r, v2));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="E-Candy-Piles"><a href="#E-Candy-Piles" class="headerlink" title="E - Candy Piles"></a>E - Candy Piles</h4><p>有 $n$ 堆石子，每堆有 $a_i$ 个石子。现在 Alice 和 Bob 在玩游戏，每轮玩家可以执行以下两种操作：</p>
<ol>
<li>选取数量最多的那堆石子全部拿走；</li>
<li>从每堆石子拿走一个。</li>
</ol>
<p>拿走最后一个石子的人输。现在两人都采用最优策略，问先手必胜还是后手必胜。( $1\le n\le10^5,1\le a_i\le10^9$ )</p>
<p>ps. 这个题需要用图，我不可避免的要从 AtCoder 找一些图qwq。</p>
<p>人类智慧神仙题Orz</p>
<p>如果把石子从大到小排序 ，我们就得到了这样一张图:</p>
<p><img src="https://s2.ax1x.com/2019/10/13/uxC5ND.png" alt="ex1"></p>
<p>注意到操作1相当于从最左端拿走一列，而操作2相当于从最底下抽走一行。这样如果我们把上图看为一个表格，那可以把问题抽象为从表格左下角出发，轮流行走，一次可以向左走一格（操作1）或向上走一个（操作2），先碰到边界线的失败。也就是这张图：</p>
<p><img src="https://s2.ax1x.com/2019/10/13/uxiGyn.png" alt=""></p>
<p>那转化为这个模型后，就要找必胜和必败点了，最终答案就是左下角点的状态。首先注意到边界上的点一定是先手必胜点，因为后手刚刚走到了边界。最 naive 的想法是根据这个结论一点点递推，但这样复杂度高达 $\sum_{i=1}^n a_i$ ，不能接受。接着我们发现，如果我们设左下角的点是 $(0,0)$ ，则如果 $(x,y)$ 是必败态，则 $(x-1,y),(x,y-1)$ 应该是必胜态，相应地，$(x-1,y-1)$ 是必败态。类似地，我们可以证明如果 $(x+2,y+2),(x+1,y+1)$ 均为必胜态，则 $(x,y)$ 也应该是必胜态，这样我们得出了一个结论，除去边界上的点，所有的对角线上的点状态相同。这样我们就可以把求 $(0,0)$ 的状态转化为求 $(0,0)$ 所在对角线上任意一点的状态，通过这张图可以看得更直观一点：</p>
<p><img src="https://s2.ax1x.com/2019/10/13/uxite0.png" alt=""></p>
<p>为了尽可能简化计算，待求的点应该尽可能接近边界，这样需要递推的内容就尽可能少。换句话说，就是找最大的以 $(0,0)$ 为左下顶点的正方形，且其他顶点不碰到边界。在上面的例子中，这个正方形的右上角应该是 $(3,3)$ ，如图：</p>
<p><img src="https://s2.ax1x.com/2019/10/13/uxiNwV.png" alt=""></p>
<p>一个结论是，从右上角这个点开始往上和往右走，在碰到边界前走的步数，如果全为偶数，则这个点为必败态，否则为必胜态，原因得大概是在这个过程上必胜态和必败态是交替出现的。 $\mathcal{O}(n)$ 找到这个正方形后 $\mathcal{O}(n)$ 计算就好，总复杂度 $\mathcal{O}(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>; <span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; x, <span class="keyword">const</span> <span class="keyword">int</span>&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> x &gt; y; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    std::<span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &gt; a[i + <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (a[j + i + <span class="number">1</span>] == i) ++j;</span><br><span class="line">            <span class="keyword">if</span> (((a[i] - i) &amp; <span class="number">1</span>) || (j &amp; <span class="number">1</span>)) <span class="built_in">printf</span>(<span class="string">&quot;First\n&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Second\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="F-Leftmost-Ball"><a href="#F-Leftmost-Ball" class="headerlink" title="F - Leftmost Ball"></a>F - Leftmost Ball</h4><p>给出 $n\times k$ 个球，一共 $n$ 种颜色，每种 $k$ 个。现在将这些球随意地从左至右摆放成一行，然后对于这 $n$ 种颜色，把每种颜色的最左端的球涂成不同于这 $n$ 种颜色的其他颜色。求最终能形成多少颜色序列，答案对 $10^9+7$ 取模。( $1\le n,k\le 2000$ )</p>
<p>题解的求拓扑序个数的方法没怎么看懂（摊手），所以这里给出一个 $\mathcal{O}(n^2)$ 的 $\rm dp$ 吧，不知道算不算一个思路。</p>
<p>我们发现正着想不好想，我们反着考虑，求出所有可能的合法的最终序列。假设题目中描述的不同的颜色是白色，则对于某一个序列，它是合法的当且仅当对于所有的 $1\le i\le n$ ，从左往右数第 $i$ 个白球在第 $i$ 种颜色的最左端的球的左边。</p>
<p>则我们设 $f_{i,j}$ 表示放了 $i$ 个白球和 $j$ 种非白球的方案数。因为一个白球要对应一种非白球，所以 $j\le i$ 。$f_{i,j}$ 可以从两个地方转移过来，一个是新加入一个白球，也就是 $f_{i-1,j}$ ，一个是新加入一种颜色，也就是 $f_{i,j-1}$ 。为了避免重复算的情况，我们每次加入球都要放在所有可能位置中的最左端。对于放入一个白球，就只有一种情况——放在最左边的空位；而对于新加入一种颜色，首先我们有 $n-(j-1)$ 种剩余颜色可以放，把其中一个放到最左端之后之后还剩 $k-2$ 个球需要放，一共有 $n\times k-i-(j-1)(k-1)-1$ 空位，所以有 $\dbinom{n\times k-i-(j-1)(k-1)-1}{k-2}$ 种方案数。最终的转移方程就是： $f_{i,j}=f_{i-1,j}+f_{i,j-1}(n-j+1)\dbinom{n\times k-i-(j-1)(k-1)-1}{k-2}$</p>
<p>边界条件是 $f_{i,0}=1(0\le i\le n)$ ，这个表示只有白球，肯定只有一种方案。最终答案就为 $f_{n,n}$ 。时间复杂度 $\mathcal{O}(n^2)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e3</span> + <span class="number">10</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> fac[N * N], ifac[N * N], f[N][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ksm</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="number">1ll</span> * a * ret % mod;</span><br><span class="line">        a = <span class="number">1ll</span> * a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="number">1ll</span> * fac[n] * ifac[m] % mod * ifac[n - m] % mod; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">1</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    fac[<span class="number">0</span>] = ifac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * k; ++i)</span><br><span class="line">        fac[i] = <span class="number">1ll</span> * fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    ifac[n * k] = <span class="built_in">ksm</span>(fac[n * k], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n * k - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        ifac[i] = <span class="number">1ll</span> * ifac[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) f[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span> (j)</span><br><span class="line">                f[i][j] = (f[i][j] + (<span class="number">1ll</span> * f[i][j - <span class="number">1</span>] * (n - j + <span class="number">1</span>) % mod</span><br><span class="line">                * <span class="built_in">C</span>(n * k - i - (j - <span class="number">1</span>) * (k - <span class="number">1</span>) - <span class="number">1</span>, k - <span class="number">2</span>) % mod)) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[n][n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="知识经验总结"><a href="#知识经验总结" class="headerlink" title="知识经验总结"></a>知识经验总结</h3><ol>
<li>对于一次二分 <code>check()</code> 函数可以判断所有询问的取值范围的题目，可以考虑整体二分，一般就是维护一个三元组 $(L,R,\{\cdot\cdot\cdot\})$ 表示询问 $\{\cdot\cdot\cdot\}$ 的答案范围为 $(L,R]$ ，之后 $\rm bfs$ 或者 $\rm dfs$ 递归二分计算；</li>
<li>博弈论的题有时候要把题目中的描述换一种表示方法才能更容易利用博弈论相关算法计算，当常规方法无法直接计算时，要注意找题目中的规律，利用规律加速计算；</li>
<li>正难则反，如果一个题目问的是有多少种不同的结果，则可以考虑找所有可能的合法结果数。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhiyangfan1234.github.io/2022/01/24/AtCoder%20Grand%20Contest%20006/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhiyangfan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhiyangfan 的博客小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/24/AtCoder%20Grand%20Contest%20006/" class="post-title-link" itemprop="url">AtCoder Grand Contest 006</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-01-24 17:00:23 / 修改时间：17:11:23" itemprop="dateCreated datePublished" datetime="2022-01-24T17:00:23+08:00">2022-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="AtCoder-Grand-Contest-006补题总结"><a href="#AtCoder-Grand-Contest-006补题总结" class="headerlink" title="AtCoder Grand Contest 006补题总结"></a>AtCoder Grand Contest 006补题总结</h2><p><del>突然发现 AGC004,AGC005 不知道为啥被我跳过去了，还得回头补。</del>  这把的难度就感觉比之前的 CODE FESITIVAL 要大，我只做到 C 题。</p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="A-Prefix-and-Suffix"><a href="#A-Prefix-and-Suffix" class="headerlink" title="A - Prefix and Suffix"></a>A - Prefix and Suffix</h4><p>给出两个长为 $n$ 的字符串 $s,t$，求出满足前 $n$ 个字符为 $s$，后 $n$ 个字符为 $t$ 的字符串中长度最小的字符串长为多少。($1\le n\le100$)</p>
<p>设这个字符串为 $S$，则一定有 $|S|\le 2n$，其中小于的部分是 $s,t$ 共用了一些字符。所以我们只需要求出 $s,t$ 能共用字符的最大值即可。直接枚举长度然后判断即可，时间复杂度 $\mathcal{O}(n^2)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">110</span>], t[<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, flag, cnt; <span class="built_in">scanf</span>(<span class="string">&quot;%d%s%s&quot;</span>, &amp;n, s + <span class="number">1</span>, t + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        flag = <span class="number">1</span>; cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n - i + <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            <span class="keyword">if</span> (s[j] != t[j + i - n]) &#123; flag = <span class="number">0</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123; <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n + n - i); <span class="keyword">break</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="B-Median-Pyramid-Easy"><a href="#B-Median-Pyramid-Easy" class="headerlink" title="B - Median Pyramid Easy"></a>B - Median Pyramid Easy</h4><p>给出一个 $n$ 层的方格金字塔，其中从上到下分别为第 $1$ 到 $n$ 层。第 $i$ 层有 $2i-1$ 个方格，具体形态如下：</p>
<p><img src="https://cdn.luogu.com.cn/upload/vjudge_pic/AT2163/a992c42b0e9b0597f104bf82a0adc1131324bb4f.png" alt=""></p>
<p>第 $n$ 层有一个 $1$ 到 $2n-1$ 的排列，其余位置的数字是它正下方，右下方和左下方方格中的三个数字里排名第二的数。现在给出一个数字 $x$，求出第 $n$ 层一个可能的排列方式，使得第一层的数字是 $x$。($2\le n\le10^5$)</p>
<p>首先能注意到的是，当 $x=1$ 或 $x=2n-1$ 时，显然无解，因为它们是排列里面的极小，极大值，在除了第 $n$ 层之外的地方都不可能出现。而对于有解的 $x$，考虑在这两个位置为 $x$：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/rmo7jvaf.png" alt=""></p>
<p>则画图可以发现，这些位置均为 $x$：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/5wa47hit.png" alt=""></p>
<p>所以如果我们想构造出来最上面一层为 $x$ 的情况，只需要让第 $n-1$ 层的中间和右边一格为 $x$ 即可。这个可以通过令第 $n$ 层的排列为 $(\cdot\cdot\cdot,x-1,x,x+1,x-2,\cdot\cdot\cdot)$ 轻松构造，注意当 $x=2$ 时，排列应为 $(\cdot\cdot\cdot,x-1,x,x+1,x+2,\cdot\cdot\cdot)$。时间复杂度 $\mathcal{O}(n)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>; <span class="keyword">int</span> a[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, x; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;x);</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1</span> || x == <span class="number">2</span> * n - <span class="number">1</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">    a[n] = x; a[n - <span class="number">1</span>] = x - <span class="number">1</span>; a[n + <span class="number">1</span>] = x + <span class="number">1</span>; <span class="keyword">int</span> now = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">2</span>) now = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n - <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i]) <span class="keyword">continue</span>;</span><br><span class="line">        a[i] = now; ++now; </span><br><span class="line">        <span class="keyword">if</span> (now + <span class="number">1</span> == x) now += <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n - <span class="number">1</span>; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="C-Rabbit-Exercise"><a href="#C-Rabbit-Exercise" class="headerlink" title="C - Rabbit Exercise"></a>C - Rabbit Exercise</h4><p>一行上面有 $n$ 只兔子，分别从 $1$ 到 $n$ 编号，编号为 $i$ 的兔子初始位置为 $x_i$。兔子们要执行一段操作。一段操作以一个长为 $m$ 的操作序列 $a$ 描述，其中 $a_i(2\le a_i\le n-1)$ 表示这次操作由兔子 $a_i$ 执行，它会等概率选择兔子 $a_i-1$ 和 $a_i+1$ 中的一个，并跳到以它为对称中心和现在的位置中心对称的位置。现在给出初始位置和兔子们执行这段操作的次数 $k$，求出所有兔子最终的期望位置。($3\le n\le10^5,|x_i|\in\{x\in \mathbf{Z}||x|\le10^9\},1\le m\le10^5,1\le k\le10^{18}$)</p>
<p>首先有一个显然的结论，也就是执行完一个操作后，$a_i$ 号兔子所在期望位置就会变为：</p>
<script type="math/tex; mode=display">E(a_i)=\dfrac{1}{2}(2E(a_i-1)-E(a_i))+\dfrac{1}{2}(2E(a_i+1)-E(a_i))</script><p>但如果直接按照这个式子递推，您将会收获一个 $\tt TLE$ 和 5 分钟的罚时。所以我们考虑变一变这个式子，稍微合并一下有：</p>
<script type="math/tex; mode=display">E(a_i)=E(a_i-1)+E(a_i+1)-E(a_i)</script><p>好了如果你没有灵光乍现这题也就到此为止了，但如果你发现原序列的差分序列在这样一次操作后会有很神奇的变化，这题也就到此为止了，如果我们令 $d_i=E(a_i)-E(a_i-1)$，则有：</p>
<script type="math/tex; mode=display">d_i=E(a_i)-E(a_i-1)=E(a_i+1)-E(a_i)</script><script type="math/tex; mode=display">d_{i+1}=E(a_i+1)-E(a_i)=E(a_i)-E(a_i-1)</script><p>可以观察到，$d_i$ 和 $d_{i+1}$ 在一次操作的前后交换了位置，利用这个性质，我们可以求出一段操作后，差分序列的每个位置会跑到哪去，注意到执行 $k$ 次其实是个循环的过程，所以我们就可以找到循环节直接做了。这个循环节其实可以理解为置换环的大小，比如每次操作有 $1\rightarrow2,2\rightarrow4,4\rightarrow1$，则置换环如下图：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/oult3tr1.png" alt=""></p>
<p>每次操作其实就是在置换环上走一步。求置换环的部分用个栈记录一下就好了，具体实现见代码，时间复杂度 $\mathcal{O}(m+n)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> id[N], vis[N], st[N], tp; <span class="keyword">double</span> x[N], d[N], dd[N]; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;x[i]), d[i] = x[i] - x[i - <span class="number">1</span>], id[i] = i;</span><br><span class="line">    <span class="keyword">int</span> m; <span class="keyword">long</span> <span class="keyword">long</span> k; <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>, &amp;m, &amp;k); <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a; i &lt;= m; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a), std::<span class="built_in">swap</span>(id[a], id[a + <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>; tp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; !vis[j]; j = id[j]) vis[j] = <span class="number">1</span>, st[++tp] = j;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tp; ++j) dd[st[j]] = d[st[(k + j - <span class="number">1</span>) % tp + <span class="number">1</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) dd[i] += dd[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%.1lf\n&quot;</span>, dd[i]); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="D-Median-Pyramid-Hard"><a href="#D-Median-Pyramid-Hard" class="headerlink" title="D - Median Pyramid Hard"></a>D - Median Pyramid Hard</h4><p>题目背景同 B。只不过这一次给出了 $1$ 到 $2n-1$ 的排列，需要求出第 $1$ 层的数 $x$。($2\le n\le10^5$)</p>
<p><del>总觉得最近至少做了三道这种类型的题，但这次还是没做出来</del></p>
<p>非常妙的思想，我甚至不知道怎么才能恰当的引入二分这个思想。只能说朴素的算法是 $\mathcal{O}(n^2)$ 而很难再优化，所以考虑转化为判断性问题，并尝试在 $\mathcal{O}(n)$ 的时间复杂度内判断可行性，这样就可以做到最终 $\mathcal{O}(n\log n)$ 的复杂度了。考虑判断最终答案与 $x$ 的大小关系，注意到题目关心的是数的大小关系而不是实际的数，所以我们把排列中所有小于 $x$ 的数变为 $0$，所有大于等于 $x$ 的数变为 $1$。这样一个格子里面填入的数就是它的下面三格中数量比较多的那个数，具体来讲，见下图：</p>
<p><img src="https://cdn.luogu.com.cn/upload/pic/28097.png" alt=""></p>
<p>我们最终的目标就是判断最上面的数是 $0$ 还是 $1$，通过这个来找到最终答案和 $x$ 的大小关系。注意到图中的连续 $0$ 和连续 $1$ 会把每一层的这一部分变成连续 $0$ 或连续 $1$，而交替 $1,0$ 会形成一个 V 字结构。而当不同的结构两两相遇时，它们就会停下。根据这个性质，我们可以发现第 $1$ 层的元素其实是连续 $0$ 和连续 $1$ “比赛”谁先到顶端的结果，换句话说，也就是哪个离中心近顶端就是哪个。那有没有可能一样近呢，<del>显然没有</del> 因为底端的长度是奇数，如果连续段距离中心一样近，中间的交替段长度一定是奇数，也就是说交替段的两边一定相同，总会有一边和相邻的连续段形成更长的连续段从而导致距离不同的。这样这题就做完了，注意特判两位选手都不在的情况，即底端是全交替的情况，此时顶层的元素即为底层最左右端的元素。最终时间复杂度 $\mathcal{O}(n\log n)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>; <span class="keyword">int</span> a[N &lt;&lt; <span class="number">1</span>], b[N &lt;&lt; <span class="number">1</span>], n;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (n &lt;&lt; <span class="number">1</span>); ++i) b[i] = (a[i] &gt;= x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b[n + i] == b[n + i + <span class="number">1</span>]) <span class="keyword">return</span> b[n + i];</span><br><span class="line">        <span class="keyword">if</span> (b[n - i] == b[n - i - <span class="number">1</span>]) <span class="keyword">return</span> b[n - i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b[(n &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (n &lt;&lt; <span class="number">1</span>); ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = (n &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>, mid, ans;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) ans = mid, l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="E-Rotate-3x3"><a href="#E-Rotate-3x3" class="headerlink" title="E - Rotate 3x3"></a>E - Rotate 3x3</h4><p>给出一个 $3$ 行 $n$ 列的表格，其中 $(i,j)$ 位置的初始值为 $i+3\times j-3$。可以把其中任意的 $3\times 3$ 的格子旋转 $180^\circ$。给出一个 $3\times n$ 的表格，求是否能通过初始表格执行任意上述旋转操作得到这个表格。($5\le n\le10^5$)</p>
<p>思维神题orz，不知道为啥学长之前写的写法比我照着题解写的少一个 $\log$。首先我们把旋转操作转化一下就是交换相隔的两列，并把这两列和它们中间的那一列上下颠倒。我们可以通过这个性质排除掉一些很傻的情况，首先这么交换每一列的数跟初始时不会有变化，只是可能会颠倒顺序，其次因为交换是相隔交换，所以每一列所在的列奇偶性不会变化。具体来讲，对于任意非负整数 $l$，$6l+1,6l+2,6l+3$ 一定一直在奇数列中，$6l+4,6l+5,6l+6$ 一定一直在偶数列中。显然这个条件是必要条件，但它充分吗？打表 <del>（或者随便猜一下这题不可能这么简单）</del> 可以发现，对于 $n=10$ 的情况，通过初始状态一共可以得到 $368,6400$ 种情况，而通过上述过程的计算，我们能得到 $120 \times 120 \times 2^{10} = 1474,5600$ 种情况（数据来自 AT 题解），容易发现多了 $4$ 倍，说明我们刚刚讨论出来的条件只是必要不充分条件。</p>
<p>我们重新审视一下刚刚操作的过程。对于奇数列而言，我们考虑两种操作：交换两个相邻的奇数列，颠倒一个奇数列。显然如果不能通过这两种操作达到最终情况，答案一定是不可能。如果能通过这两种操作达到最终情况，我们就设 $inv_o$ 表示第一种操作操作的次数，$flip_o$ 表示第二种操作操作的次数。注意到我们虽然不能准确确定它们的值，但可以确定奇偶性。考虑第一种操作，如果我们把奇数列按顺序依次从 $1$ 到 $\dfrac{n}{2}$ 编号，则一次操作要么减少一个逆序对，要么增加一个逆序对，均会导致逆序对奇偶性的改变，而同时这一次操作也会改变 $inv_o$ 的奇偶性，所以我们能用最终逆序对的个数奇偶性反映 $inv_o$ 的奇偶性。对于第二种操作，一次操作要么增加一个（与初始状态比较）颠倒的列，要么减少一个颠倒的列，均会导致颠倒列数奇偶性的改变，所以类似地，我们可以用最终颠倒列的数目的奇偶性反映 $flp_o$ 的奇偶性。我们用类似的操作，求出对于偶数列的 $inv_e$ 和 $flp_e$。</p>
<p>求出来之后有什么用呢？注意到每次旋转操作，会导致一下两种结果之一：</p>
<ul>
<li>$inv_o$ 和 $flp_e$ 的奇偶性改变了。</li>
<li>$flp_o$ 和 $inv_e$ 的奇偶性改变了。</li>
</ul>
<p>取决于在哪旋转的。所以最终 $inv_o$ 和 $flp_e$，$flp_o$ 和 $inv_e$ 的奇偶性一定相同。那么这是不是充分条件呢？考虑以下构造（小写字母表示初始顺序，大写字母表示逆序）：</p>
<ul>
<li>$\tt a\ b\ c\ d\ e$ </li>
<li>$\tt c\ B\ a\ d\ e$</li>
<li>$\tt c\ B\ e\ D\ a$</li>
<li>$\tt e\ b\ c\ D\ a$</li>
<li>$\tt e\ b\ a\ d\ c$</li>
<li>$\tt a\ B\ e\ d\ c$</li>
<li>$\color{red}{\tt a\ B\ c\ D\ e}$</li>
<li>$\tt a\ D\ C\ B\ e$</li>
<li>$\tt C\ d\ a\ B\ e$</li>
<li>$\tt C\ B\ A\ d\ e$</li>
<li>$\color{red}{\tt A\ b\ C\ d\ e}$</li>
</ul>
<p>注意到红色的两列，我们可以通过交换和颠倒改变相邻的奇数列或相邻的偶数列的颠倒情况，再加上我们可以交换相邻的两列，所以只要满足以上条件，一定可以构造出相应的方案，充分性得证。最终时间复杂度就是判逆序对的复杂度 $\mathcal{O}(n\log n)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>; <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>][N], b[N], c[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BIT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ll c[N]; <span class="keyword">int</span> len;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>&#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= len; i += <span class="built_in">lowbit</span>(i)) c[i] += v; &#125;</span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; ll ans = <span class="number">0</span>; <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i; i -= <span class="built_in">lowbit</span>(i)) ans += c[i]; <span class="keyword">return</span> ans; &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> lowbit</span></span><br><span class="line">&#125;bit[<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> d[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++i) d[i] = a[i][j] % <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">if</span> (j &amp; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (d[<span class="number">1</span>] == <span class="number">1</span> &amp;&amp; d[<span class="number">2</span>] == <span class="number">2</span> &amp;&amp; d[<span class="number">3</span>] == <span class="number">3</span>)</span><br><span class="line">                b[j] = (a[<span class="number">1</span>][j] - <span class="number">1</span>) / <span class="number">6</span> + <span class="number">1</span>, c[j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (d[<span class="number">1</span>] == <span class="number">3</span> &amp;&amp; d[<span class="number">2</span>] == <span class="number">2</span> &amp;&amp; d[<span class="number">3</span>] == <span class="number">1</span>)</span><br><span class="line">                b[j] = (a[<span class="number">1</span>][j] - <span class="number">3</span>) / <span class="number">6</span> + <span class="number">1</span>, c[j] = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (d[<span class="number">1</span>] == <span class="number">4</span> &amp;&amp; d[<span class="number">2</span>] == <span class="number">5</span> &amp;&amp; d[<span class="number">3</span>] == <span class="number">0</span>)</span><br><span class="line">                b[j] = (a[<span class="number">1</span>][j] - <span class="number">4</span>) / <span class="number">6</span> + <span class="number">1</span>, c[j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (d[<span class="number">1</span>] == <span class="number">0</span> &amp;&amp; d[<span class="number">2</span>] == <span class="number">5</span> &amp;&amp; d[<span class="number">3</span>] == <span class="number">4</span>)</span><br><span class="line">                b[j] = (a[<span class="number">1</span>][j] - <span class="number">6</span>) / <span class="number">6</span> + <span class="number">1</span>, c[j] = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll inv[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;; <span class="keyword">int</span> flp[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;; bit[<span class="number">0</span>].len = bit[<span class="number">1</span>].len = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, d; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        d = i &amp; <span class="number">1</span>; bit[d].<span class="built_in">add</span>(b[i], <span class="number">1</span>);</span><br><span class="line">        inv[d] += bit[d].<span class="built_in">query</span>(n) - bit[d].<span class="built_in">query</span>(b[i]), flp[d] += (c[i] == <span class="number">-1</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    inv[<span class="number">0</span>] %= <span class="number">2</span>; inv[<span class="number">1</span>] %= <span class="number">2</span>; flp[<span class="number">0</span>] %= <span class="number">2</span>; flp[<span class="number">1</span>] %= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (inv[<span class="number">1</span>] == flp[<span class="number">0</span>] &amp;&amp; inv[<span class="number">0</span>] == flp[<span class="number">1</span>]) <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="F-Blackout"><a href="#F-Blackout" class="headerlink" title="F - Blackout"></a>F - Blackout</h4><p>有一个 $n\times n$ 的表格，其中第 $i$ 行第 $j$ 列为 $(i,j)$，其中有 $m$ 个格子为黑色。接下来想根据以下规则把表格里面更多格子涂上黑色：</p>
<ul>
<li>如果格子 $(x,y),(y,z)$ 均为黑色且 $(z,x)$ 为白色，则把 $(z,x)$ 涂上黑色。</li>
</ul>
<p>现在给出初始的 $m$ 个黑色格子，求出最终会有多少格子被涂上黑色。($1\le n,m\le10^5$)</p>
<p>神仙题面，如果直接出图论可能就没这么难了。<del>根据我的吐槽</del>我们考虑把原题面转化成图论问题：</p>
<blockquote>
<p>给出一个 $n$ 个点 $m$ 条边的有向图，如果存在边 $x\rightarrow y,y\rightarrow z$，则加上边 $z\rightarrow x$，可以加边就一直加边，最终图里面会有多少条边？</p>
</blockquote>
<p>显然，不同的弱连通块（也就是不考虑边的方向连通）之间不会相互影响，所以我们可以对每个弱连通块分别统计。以下讨论假设原图弱连通。</p>
<p>（这里是原题解对正解放的引入，虽然我不是很理解为什么要这么引入）我们首先考虑一些特殊情况，比如图是一条链，如果对这张图做上述操作，则我们会发现，最终得到的图上存在一条边 $s\rightarrow t$，当且仅当 $s\equiv t\pmod{3}$。这启发我们这道题肯定跟路径长模 $3$ 有关。</p>
<p>考虑在原图上给每个点打上一个 $\tt A,B,C$ 的其中一个的标记，使得原图满足：</p>
<ul>
<li>对于每一条边 $x\rightarrow y$，对于它端点的标记都有 $\tt A\rightarrow B$，$\tt B\rightarrow C$ 或 $\tt C\rightarrow A$。</li>
</ul>
<p>这样的标记有可能不存在（比如四元环），但一旦存在就是唯一的（排除循环的情况的话）。不管怎么说，我们都可以用 $\rm dfs$ 在 $\mathcal{O}(m)$ 的时间复杂度下打出标记或声明矛盾。接下来根据我们得到的结果会有三种结论，证明下附：</p>
<ul>
<li>当这样的标记不存在时，可以在任意点对直接连边，包括自环</li>
<li>当这样的标记存在，且 $\tt A,B,C$ 标记全部出现了，可以在所有满足 $\tt A\rightarrow B$，$\tt B\rightarrow C$ 和 $\tt C\rightarrow A$ 的点对之间连边，且不能再连其他边。</li>
<li>当这样的标记存在，且 $\tt A,B,C$ 标记没有全部出现，不能在原图的基础上连任何边。</li>
</ul>
<p>根据这些结论我们就可以直接得到结果了，最终时间复杂度即为 $\rm dfs$ 的复杂度 $\mathcal{O}(m)$。</p>
<p>证明（感性理解罢）：</p>
<ol>
<li><strong>当这样的标记存在，且 A,B,C 标记没有全部出现</strong>  如果边 $x\rightarrow y$ 和边 $y\rightarrow z$ 同时存在的话，所有标记应该会全部出现，所以在这种情况下不存在这样的边，你也就无法做任何操作了。</li>
<li><p><strong>当这样的标记存在，且 A,B,C 标记全部出现了</strong>  这种情况下，存在 $x,y,z$ 满足边 $x\rightarrow y$ 和 $y\rightarrow z$ 存在，自然我们可以加 $z\rightarrow x$ 这条边，这样 $x,y,z$ 就会形成一个三角形。假设 $x,y,z$ 的标记分别是 $\tt A,B,C$，则考虑一个点 $v$ 与 $x,y,z$ 中的一个相邻，比如存在边 $v\rightarrow x$，则显然又会形成一个三角形 $v,x,y$。而画图可以发现，$v$ 至少会和 $x,y,z$ 中的两个相邻：</p>
<p> <img src="https://cdn.luogu.com.cn/upload/image_hosting/ihf7ua2y.png" alt=""></p>
<p> 如果我们再考虑一个与 $v$ 相邻的 $w$，我们也能证明 $w$ 至少和 $x,y,z$ 中的两个相邻：</p>
<p> <img src="https://cdn.luogu.com.cn/upload/image_hosting/p2ey80s0.png" alt=""></p>
<p> 一直重复这个过程我们就可以证明任意点都和 $x,y,z$ 中的两个相邻，这样我们就可以在所有满足 $\tt A\rightarrow B$，$\tt B\rightarrow C$ 和 $\tt C\rightarrow A$ 的点对之间连边，且显然不能再连其他边。</p>
</li>
<li><strong>这样的标记不存在时，可以在任意点对直接连边，包括自环</strong>  我们首先证明至少一个自环存在且满足条件，这样剩余的证明跟这个证明就几乎相同了。首先考虑找到一个会引起矛盾的环，这个环一定存在边 $x\rightarrow y$ 和边 $y \rightarrow z$，而我们可以通过加边 $z\rightarrow x$ 来缩小这个环，且这个小的环也会引起矛盾。一直重复这个过程，我们就可以得到一个自环。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span> <span class="keyword">int</span> v, next, w; &#125;E[N &lt;&lt; <span class="number">1</span>]; <span class="keyword">int</span> p[N], cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(p, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span> (p)); cnt = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123; E[cnt].w = w; E[cnt].v = v; E[cnt].next = p[u]; p[u] = cnt++; &#125;</span><br><span class="line"><span class="keyword">int</span> vis[N], tag[N], c[N], col[N], sum, ok, tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[u] = <span class="number">1</span>; ++c[col[u]]; ++sum; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = p[u], v; i + <span class="number">1</span>; i = E[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        v = E[i].v; tot += (E[i].w == <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (!vis[v]) col[v] = (col[u] + E[i].w + <span class="number">3</span>) % <span class="number">3</span>, <span class="built_in">dfs</span>(v);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (col[v] != (col[u] + E[i].w + <span class="number">3</span>) % <span class="number">3</span>) ok = <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>(); <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= m; ++i) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y), <span class="built_in">insert</span>(x, y, <span class="number">1</span>), <span class="built_in">insert</span>(y, x, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>; sum = tot = <span class="number">0</span>; ok = <span class="number">1</span>;</span><br><span class="line">        c[<span class="number">0</span>] = c[<span class="number">1</span>] = c[<span class="number">2</span>] = <span class="number">0</span>; <span class="built_in">dfs</span>(i); </span><br><span class="line">        <span class="keyword">if</span> (!ok) ans += <span class="number">1ll</span> * sum * sum;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c[<span class="number">0</span>] &amp;&amp; c[<span class="number">1</span>] &amp;&amp; c[<span class="number">2</span>]) </span><br><span class="line">            ans += <span class="number">1ll</span> * c[<span class="number">0</span>] * c[<span class="number">1</span>] + <span class="number">1ll</span> * c[<span class="number">0</span>] * c[<span class="number">2</span>] + <span class="number">1ll</span> * c[<span class="number">1</span>] * c[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">else</span> ans += tot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这一把很大程度上运用了转化的思想，比如 C 题中对差分序列的转化（有时候推出来一个式子无从下手可以考虑从差分或前缀和的思想讨论）， D 题中二分后转化为判定性问题的 $0,1$ 转化，E 题中对原操作的转化（对于不熟悉的操作运用这种转化通常是有效的），F 题中对原题目的转化（这种 $10^5\times10^5$ 的表格一看就不是什么应该正常做的题目）。在之后的题目中，如果遇到无从下手的问题，不放发散一下思维，想想有没有熟悉的题目能跟它联系起来或者原题面有没有另一种表述方法 <del>（然后还是不会）</del> ，说不定就茅塞顿开了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhiyangfan1234.github.io/2022/01/24/AtCoder%20Grand%20Contest%20004/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhiyangfan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhiyangfan 的博客小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/24/AtCoder%20Grand%20Contest%20004/" class="post-title-link" itemprop="url">AtCoder Grand Contest 004</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-01-24 17:00:23 / 修改时间：17:11:28" itemprop="dateCreated datePublished" datetime="2022-01-24T17:00:23+08:00">2022-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="AtCoder-Grand-Contest-004"><a href="#AtCoder-Grand-Contest-004" class="headerlink" title="AtCoder Grand Contest 004"></a>AtCoder Grand Contest 004</h2><p>之前做的，忘了订题写总结，所以现在也没啥印象写个开头吐槽了。</p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="Divide-a-Cuboid"><a href="#Divide-a-Cuboid" class="headerlink" title="Divide a Cuboid"></a>Divide a Cuboid</h4><p>有一个由 $1\times1\times1$ 的小正方体组成的 $A\times B\times C$ 的大长方体，现在想把这 $A\times B\times C$ 个小正方体染成红色或蓝色，使得以下条件成立：</p>
<ul>
<li>至少有一个红色正方体和至少一个蓝色正方体。</li>
<li>所有红色正方体的集合会组成一个长方体。</li>
<li>所有蓝色正方体的集合会组成一个长方体。</li>
</ul>
<p>问如何染色能使得红蓝正方体的个数之差最小。($2\le A,B,C\le10^9$)</p>
<p>显然较优的分割方式是沿着大长方体的某一面把原长方体分成两半，一半红一半蓝。如果 $A,B,C$ 其中有一个为偶数，则存在一种方法把长方体恰分成两个大小相同的长方体，答案为 $0$。否则答案为割的那一面正方体的个数，即 $\min\{AB,BC,AC\}$。时间复杂度 $\mathcal{O}(1)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> a, b, c; <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">    <span class="keyword">if</span> (!(a &amp; <span class="number">1</span>) || !(b &amp; <span class="number">1</span>) || !(c &amp; <span class="number">1</span>))</span><br><span class="line">    &#123; <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, std::<span class="built_in">min</span>(std::<span class="built_in">min</span>(a * c, a * b), b * c));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="B-Colorful-Slimes"><a href="#B-Colorful-Slimes" class="headerlink" title="B - Colorful Slimes"></a>B - Colorful Slimes</h4><p>现在一共有 $n$ 种颜色的史莱姆。初始时一个史莱姆都没有，现在想通过以下两种操作得到全部的 $n$ 中史莱姆： </p>
<ul>
<li>选择一个当前没有的颜色 $i$ 并花费 $a_i$ 时间抓一只颜色为 $i$ 的史莱姆。</li>
<li>花费 $x$ 的时间施法将拥有的所有史莱姆的颜色从 $i$ 变为 $i+1$，注意颜色 $n$ 会变为 $1$。</li>
</ul>
<p>求得到全部史莱姆的最小时间。($2\le n\le2\times10^3,1\le a_i,x\le10^9$)</p>
<p>注意到题目的难点在于施法的处理，但观察到 $n$ 比较小，所以考虑枚举施法的次数。假设当前枚举到施法 $k$ 次，则得到颜色为 $i$ 的史莱姆需要获得颜色为 $i,i-1,\cdot\cdot\cdot,i-k$ 的史莱姆其中一个（注意这里和下文中所有涉及到下标减法的都是在模意义下的），对应抓史莱姆时已经施法过的次数为 $k,k-1,\cdot\cdot\cdot,0$。所以如果想获得第 $i$ 种颜色，除去施法的时间还需要 $\min_{j=i-k}^i\{a_j\}$ 的时间。记 $b_{i,k}=\min_{j=i-k}^i\{a_j\}$，则最终答案即为 $k\times x+\sum_{i=1}^n b_{i,k}$。直接枚举 $k,i$ 并对于每个 $i$ 暴力计算 $b$ 的时间复杂度为 $\mathcal{O}(n^3)$，不足以通过本题。不过有个很显然的优化，$b_{i,k}=\min(b_{i,k-1},a_{i,k})$，这样就可以每次 $\mathcal{O}(1)$ 算出 $b$ 了，时间复杂度 $\mathcal{O}(n^2)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N]; <span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, x; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]), </span><br><span class="line">        b[i] = a[i], ans += a[i];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            b[i] = std::<span class="built_in">min</span>(b[i], a[(i - k + n) % n]);</span><br><span class="line">            ret += b[i];</span><br><span class="line">        &#125;</span><br><span class="line">        ret += <span class="number">1ll</span> * k * x;</span><br><span class="line">        ans = std::<span class="built_in">min</span>(ans, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="C-AND-Grid"><a href="#C-AND-Grid" class="headerlink" title="C - AND Grid"></a>C - AND Grid</h4><p>有两个 $n\times m$ 的网格图。第一个被人涂上了若干 <strong>四连通</strong> 的红色格子，第二个被另一个人涂上了若干 <strong>四连通</strong> 的蓝色格子。现在把这两个网格图按同一方向重叠，如果格子上既有蓝色也有红色，则显示为紫色。现在给出所有显示紫色的格子，<strong>保证网格图的边缘不为紫色</strong>，构造出一组可能的原网格图。($3\le n,m\le500$)</p>
<p>考虑构建一组模板网格图，然后对于不同的询问我们都在这组模板上修改得到答案。这组模板应该满足以下条件：</p>
<ul>
<li>两个网格图重叠后，每个格子都显示为要么蓝要么红，换句话说，蓝色格子是红色格子的补集。</li>
<li>红蓝格子都是四连通的。</li>
<li>在这组网格图中的任意一个上的任意非边界点涂上对应的颜色原图仍然四连通。</li>
</ul>
<p>比如，这两张图就符合条件：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/38uyafcn.png" alt=""></p>
<p>对于任意询问上的某个紫色结点，在模板图上该补充颜色的位置补充颜色即可。时间复杂度 $\mathcal{O}(nm)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">600</span>;</span><br><span class="line"><span class="keyword">int</span> mp[N][N]; <span class="keyword">char</span> req[N][N];</span><br><span class="line"><span class="keyword">int</span> res[N][N][<span class="number">2</span>]; <span class="keyword">char</span> ans[<span class="number">2</span>][N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h, w; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;h, &amp;w);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= h; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= w; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>) &#123; mp[i][j] = <span class="number">1</span>; <span class="keyword">continue</span>; &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == h) &#123; mp[i][j] = <span class="number">0</span>; <span class="keyword">continue</span>; &#125;</span><br><span class="line">            mp[i][j] = (j &amp; <span class="number">1</span>);</span><br><span class="line">        &#125; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= h; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, req[i] + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= h; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= w; ++j)</span><br><span class="line">            <span class="keyword">if</span> (req[i][j] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                res[i][j][mp[i][j] ^ <span class="number">1</span>] = res[i][j][mp[i][j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> res[i][j][mp[i][j]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= h; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= w; ++j)</span><br><span class="line">            ans[<span class="number">0</span>][i][j] = res[i][j][<span class="number">0</span>] ? <span class="string">&#x27;#&#x27;</span> : <span class="string">&#x27;.&#x27;</span>,</span><br><span class="line">            ans[<span class="number">1</span>][i][j] = res[i][j][<span class="number">1</span>] ? <span class="string">&#x27;#&#x27;</span> : <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        ans[<span class="number">0</span>][i][w + <span class="number">1</span>] = ans[<span class="number">1</span>][i][w + <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= h; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, ans[<span class="number">0</span>][i] + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= h; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, ans[<span class="number">1</span>][i] + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="D-Teleporter"><a href="#D-Teleporter" class="headerlink" title="D - Teleporter"></a>D - Teleporter</h4><p>有一张有 $n$ 个结点的图，其中每个结点 $i$ 都能通过传送门到达 $a_i$ 结点，保证每个点都能通过若干次传送到达 $1$ 号结点。现在给定一个整数 $k$。需要把一些 $a_i$ 的值改变，保证从任意结点出发经过 <strong>恰好</strong> $k$ 次传送都能到达 $1$ 号结点。求最少需要改变多少 $a_i$ 的值。($2\le n\le10^5,1\le a_i\le n,1\le k\le10^9$)</p>
<p>首先根据题目描述，我们能很轻松建立起一个图论模型。给出一张 $n$ 个结点 $n$ 条边的有向图，对于每个点 $i$ 都有一条到 $a_i$ 的有向边。注意到原题中给出的条件说明这张图是弱连通的，问题即为最少改变多少个有向边的终点能使得从任意结点出发经过恰好 $k$ 条边都能到达 $1$。</p>
<p>能猜测到的一个结论是，改变完边之后，一定有 $a_1=1$，即在 $1$ 处存在自环。证明也不难，因为从 $1$ 出发走 $k$ 步能到达 $1$，说明 $1$ 被包含在一个大小是 $k$ 的因数的环上。假设 $a_1=r\ne 1$，则 $r$ 应该也在上述环上，而 $r$ 走恰好 $k$ 步会回到 $r$。又由于任意点走 $k$ 步会到 $1$，所以 $r=1$，假设不成立。所以 $a_1=1$ 成立。</p>
<p>$1$ 处有个自环，那我们就不管那条边了。这样边的总数就变为了 $n-1$ 个，又因为所有点都能到达 $1$，我们可以把原图改为一棵以 $1$ 为根的树：（如下图，来自 AT 原题解）</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/cwgpmn4l.png" alt=""></p>
<p>又因为 $1$ 处的自环可以消耗次数，所以原问题就变为了从任意点出发，经过 <strong>至多</strong> $k$ 条边都能到达 $1$。来看一个当 $k=2$ 时的可能解法（同来自 AT 原题解）：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/rcnqsd7t.png" alt=""></p>
<p>即把一些边改到连向 $1$ 来缩短距离。这样看，原题面又可以转化为：</p>
<blockquote>
<p>给出一棵有根树，你要删掉最少的边，使得对于每个连通块都有：</p>
<ul>
<li>以根节点为根的子树深度最多为 $k$。</li>
<li>不以根节点为根的子树深度最多为 $k-1$。</li>
</ul>
</blockquote>
<p>删边就是把原边改为指向 $1$，这样不以根节点为根的子树还需要一次机会走一条边到 $1$，所以最多为 $k-1$。这样就简单了，可以用 $\rm dfs$ 轻松实现。具体来讲，对于一个点 $x$，如果它有一个儿子 $y$ 满足以 $y$ 为根的子树深度为 $k-1$ 且 $x$ 不为根，就割掉 $x,y$ 之间的边，最终答案即为割掉的边数。时间复杂度 $\mathcal{O}(n)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span> <span class="keyword">int</span> v, next; &#125;E[N]; <span class="keyword">int</span> p[N], cnt, a, k, ans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(p, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span> (p)); cnt = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123; E[cnt].v = v; E[cnt].next = p[u]; p[u] = cnt++; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> dep = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = p[u], v; i + <span class="number">1</span>; i = E[i].next)	</span><br><span class="line">		v = E[i].v, dep = std::<span class="built_in">max</span>(dep, <span class="built_in">dfs</span>(v, u));</span><br><span class="line">	ans += ((++dep) &gt;= k &amp;&amp; (fa &gt; <span class="number">1</span>)); <span class="keyword">return</span> dep % k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">init</span>(); <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;k, &amp;a); ans += (a != <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a), <span class="built_in">insert</span>(a, i);</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>); <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="E-Salvage-Robots"><a href="#E-Salvage-Robots" class="headerlink" title="E - Salvage Robots"></a>E - Salvage Robots</h4><p>有一个 $n\times m$ 的网格图，其中每个格子可能有以下三种状态：</p>
<ul>
<li>这个格子是空的。</li>
<li>这个格子是出口，整个网格图中出口有且仅有一个。</li>
<li>这个格子里有一个机器人。</li>
</ul>
<p>现在想通过以下操作把尽可能多的机器人送到出口：</p>
<ul>
<li>选择上下左右四个方向的一个，然后所有机器人沿着这个方向行进一步。如果一个机器人在到达出口前走到了边界外，它就会爆炸消失。</li>
</ul>
<p>问最多能把多少机器人送到出口。($2\le n,m\le100$)</p>
<p>发现一堆机器人的状态不好描述，所以我们反向考虑，不移动机器人，而是去移动整个网格图和出口，并描述出口的移动情况。注意到描述出口移动情况的关键在于它移动的最远端。具体来讲，我们用一个四元组 $(l,r,d,u)$ 表示出口往左最多移动了 $l$ 格，往右 $r$，往下 $d$，往上 $u$。而这样的话，从上边界往下 $d$ 格，从下边界往上 $u$ 格，从左边界往右 $r$ 格，从右边界往左 $l$ 格都是已经出界过的地方，里面不可能有机器人了，有可能是爆炸了，有可能在爆炸前到出口了。当然，出口经过的地方也没有机器人了，因为它们出去了。总的来说，如下图（又来自 AT），黄色部分是出口到达的地方，红色部分是没有机器人的地方：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/jqucrd3s.png" alt=""></p>
<p>换句话说，上图中所有带颜色的格子都不会有机器人，白色格子里面机器人还是原来的样子。考虑设 $f_{l,r,u,d}$ 表示当前状态用 $(l,r,u,d)$ 描述时能救出多少机器人。则转移即为尝试拓展这个黄色的部分并计算贡献。具体来讲，我们分别尝试把黄色部分往四个方向拓展一格，则新救下的机器人即为新拓展的黄色部分和原来白色部分的交集。如下图（还是来自 AT），当往下拓展一格，可以救下紫色部分的机器人，当往右拓展一格可以救下绿色部分的机器人，往其他方向拓展不能救下新机器人：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/xpa7yai7.png" alt=""></p>
<p>直接 $\mathcal{O}(n^2m^2)$ 转移即可，具体细节见代码。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>; <span class="keyword">int</span> f[N][N][N][N], v[N][N][<span class="number">2</span>]; <span class="keyword">char</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m, x, y, ans = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>); <span class="comment">//计算列/行机器人的前缀和方便计算转移</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (s[j] == <span class="string">&#x27;E&#x27;</span>) x = i, y = j;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				v[i][j][<span class="number">0</span>] = v[i - <span class="number">1</span>][j][<span class="number">0</span>] + (s[j] == <span class="string">&#x27;o&#x27;</span>);</span><br><span class="line">				v[i][j][<span class="number">1</span>] = v[i][j - <span class="number">1</span>][<span class="number">1</span>] + (s[j] == <span class="string">&#x27;o&#x27;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//这里底下转移的时候取 min/max 其实就是计算白色部分。具体来讲就是红色边界和黄色边界取一个 min/max。</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; y; ++l)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt;= m - y; ++r)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; x; ++u)</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>, s; d &lt;= n - x; ++d)</span><br><span class="line">				&#123;</span><br><span class="line">                                        <span class="comment">//最终答案即为所有状态取 max</span></span><br><span class="line">					ans = std::<span class="built_in">max</span>(ans, s = f[l][r][u][d]);</span><br><span class="line">					<span class="keyword">if</span> (l + r &lt; y - <span class="number">1</span>)</span><br><span class="line">						f[l + <span class="number">1</span>][r][u][d] = std::<span class="built_in">max</span>(f[l + <span class="number">1</span>][r][u][d], </span><br><span class="line">						s + v[std::<span class="built_in">min</span>(x + d, n - u)][y - l - <span class="number">1</span>][<span class="number">0</span>] - </span><br><span class="line">						v[std::<span class="built_in">max</span>(x - u - <span class="number">1</span>, d)][y - l - <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">					<span class="keyword">if</span> (l + r &lt; m - y)</span><br><span class="line">						f[l][r + <span class="number">1</span>][u][d] = std::<span class="built_in">max</span>(f[l][r + <span class="number">1</span>][u][d],</span><br><span class="line">						s + v[std::<span class="built_in">min</span>(x + d, n - u)][y + r + <span class="number">1</span>][<span class="number">0</span>] - </span><br><span class="line">						v[std::<span class="built_in">max</span>(x - u - <span class="number">1</span>, d)][y + r + <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">					<span class="keyword">if</span> (u + d &lt; x - <span class="number">1</span>)</span><br><span class="line">						f[l][r][u + <span class="number">1</span>][d] = std::<span class="built_in">max</span>(f[l][r][u + <span class="number">1</span>][d],</span><br><span class="line">						s + v[x - u - <span class="number">1</span>][std::<span class="built_in">min</span>(y + r, m - l)][<span class="number">1</span>] -</span><br><span class="line">						v[x - u - <span class="number">1</span>][std::<span class="built_in">max</span>(y - l - <span class="number">1</span>, r)][<span class="number">1</span>]);</span><br><span class="line">					<span class="keyword">if</span> (u + d &lt; n - x)</span><br><span class="line">						f[l][r][u][d + <span class="number">1</span>] = std::<span class="built_in">max</span>(f[l][r][u][d + <span class="number">1</span>],</span><br><span class="line">						s + v[x + d + <span class="number">1</span>][std::<span class="built_in">min</span>(y + r, m - l)][<span class="number">1</span>] - </span><br><span class="line">						v[x + d + <span class="number">1</span>][std::<span class="built_in">max</span>(y - l - <span class="number">1</span>, r)][<span class="number">1</span>]);</span><br><span class="line">				&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="F-Namori"><a href="#F-Namori" class="headerlink" title="F - Namori"></a>F - Namori</h4><p>给出一张 $n$ 个点 $m$ 条边的连通无向图，初始时所有结点颜色均为白色。我们定义一次操作为：</p>
<ul>
<li>选择两个相邻同色结点，把它们的颜色翻转，也就是黑变白，白变黑。</li>
</ul>
<p>问能否通过若干次操作使得原图所有结点变为黑色。($2\le n\le m,n-1\le m\le n$)</p>
<p>这道题看起来非常难下手，所以我们先来考虑数据范围里面比较简单的那一档 $m=n-1$。但即使在树上，原问题依然很棘手，所以我们要想到一个转化。注意到树一定是二分图，那我们把原图黑白染色后，原题即变为：</p>
<blockquote>
<p>能选择两个相邻异色结点，把它们的颜色翻转，问能否通过若干次操作使得原图从初始状态变为所有结点都颜色翻转的状态。</p>
</blockquote>
<p>以样例 1 为例。原题的操作是这样：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/1o8qshyq.png" alt=""></p>
<p>而经过黑白染色后的操作就变为了：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/qpfftqit.png" alt=""></p>
<p>我们还可以通过棋子的模型把原题的题意进一步解释：</p>
<blockquote>
<p>现在有一棵树，一些结点上有棋子，每次操作可以把棋子推到相邻的空位上，给出初始状态和结束状态，问能否通过若干次操作使原图从初始状态到结束状态。</p>
</blockquote>
<p>这看起来就可做多了，下文中我们称初始状态为 $S$，结束状态为 $T$。首先当 $S$ 和 $T$ 状态下的棋子数目不一样时，显然不可能，否则一定存在一种方案。我们来对每条边分别考虑，显然一条边会把树分为两个连通块 $G_1,G_2$，则经过这条边的棋子数量即为 $S$ 下 $G_1$ 中的棋子数量与 $T$ 下 $G_1$ 中的棋子数量之差的绝对值。因为是最终操作是反色嘛，所以这个其实就是 $G_1$ 在 $S$ 下棋子数量和空位数量之差，我们钦定 $G_1$ 是那个子树连通块，这就可以一遍 $\rm dfs$ 求出来了，时间复杂度 $\mathcal{O}(n)$。</p>
<p>接下来我们来考虑 $m=n$ 的情况。这种情况显然是一棵基环树，但基环树也分种类。偶环基环树是二分图，情况跟树类似，我们先来考虑，而奇环基环树不是二分图，情况有所变化。对于偶环基环树，我们依然采用跟树一样的棋子模型。考虑环上的一条边 $e_i=(u,v)$，我们设在最终按方向 $u\rightarrow v$通过这条边的棋子数量为 $x$。（如果按照 $v\rightarrow u$ 通过则会做一个 $-1$ 的贡献）考虑割掉这条边之后，原图会变成一棵树，我们可以用上文所述算法算出这一部分的贡献 $a_{i}$，所以这条边的贡献为 $|a_i+x|$。所以最终答案即为 $\sum_{i=1}^c |a_i+x|$，其中 $c$ 表示偶环的大小。显然可以通过 $a_i$ 的中位数来找到答案的最小值（当然题解说也可以三分，我不是很会三分就不介绍了）。时间复杂度 $\mathcal{O}(n)$</p>
<p>然后是奇环基环树，这个东西不是二分图，也就是说如果我们依然对它进行黑白染色，会存在两个相邻的点颜色相同，考虑剪掉这条边，则情况又回到了树的情况。但不一样的是，我们可以对这条边相邻的两个点进行操作，可以同时放上一个棋子或同时拿掉一个棋子。这样我们就可以改变棋子数量了，但不能改变棋子数量的奇偶性，所以当 $S,T$ 内棋子数量奇偶性不同时，显然无解。否则我们可以通过若干次操作使得 $S,T$ 状态下棋子相同，然后按照树的方法做就好了。答案就是树的答案加上操作次数。时间复杂度 $\mathcal{O}(n)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>; <span class="keyword">int</span> fa[N], a[N], b[N], tp;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span> <span class="keyword">int</span> v, next; &#125;E[N &lt;&lt; <span class="number">1</span>]; <span class="keyword">int</span> p[N], cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(p, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span> (p)); cnt = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123; E[cnt].v = v; E[cnt].next = p[u]; p[u] = cnt++; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x == fa[x] ? x : fa[x] = <span class="built_in">getf</span>(fa[x]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> typ)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	a[u] = typ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = p[u], v; i + <span class="number">1</span>; i = E[i].next)</span><br><span class="line">	&#123;</span><br><span class="line">		v = E[i].v; <span class="keyword">if</span> (v == fa[u]) <span class="keyword">continue</span>;</span><br><span class="line">		fa[v] = u; <span class="built_in">dfs</span>(v, -typ); a[u] += a[v];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">init</span>(); <span class="keyword">int</span> n, m, rt = <span class="number">1</span>, rs = <span class="number">1</span>, ans = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fa[i] = i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= m; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">getf</span>(x) != <span class="built_in">getf</span>(y)) fa[fa[x]] = fa[y];</span><br><span class="line">		<span class="keyword">else</span> &#123; rt = x; rs = y; <span class="keyword">continue</span>; &#125;</span><br><span class="line">		<span class="built_in">insert</span>(x, y); <span class="built_in">insert</span>(y, x);</span><br><span class="line">	&#125;</span><br><span class="line">	fa[rt] = <span class="number">0</span>; <span class="built_in">dfs</span>(rt, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (n == m)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = rs; i; i = fa[i]) b[++tp] = a[i];</span><br><span class="line">		<span class="keyword">if</span> (tp &amp; <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (a[rt] &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>), <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = rs; i; i = fa[i]) a[i] -= a[rt] &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (a[rt]) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>), <span class="number">0</span>;</span><br><span class="line">			std::<span class="built_in">sort</span>(b + <span class="number">1</span>, b + tp + <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = rs; i; i = fa[i]) a[i] -= b[tp &gt;&gt; <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[rt]) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>), <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ans += std::<span class="built_in">abs</span>(a[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhiyangfan1234.github.io/2022/01/24/AtCoder%20Grand%20Contest%20001/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhiyangfan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhiyangfan 的博客小窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/24/AtCoder%20Grand%20Contest%20001/" class="post-title-link" itemprop="url">AtCoder Grand Contest 001</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-01-24 17:00:23 / 修改时间：17:11:03" itemprop="dateCreated datePublished" datetime="2022-01-24T17:00:23+08:00">2022-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="AtCoder-Grand-Contest-001"><a href="#AtCoder-Grand-Contest-001" class="headerlink" title="AtCoder Grand Contest 001"></a>AtCoder Grand Contest 001</h2><p>应老师的要求开始补AGC的题，AGC001的题没有想象中那么难，做出来了前三题 。后三题一看就是不可做题直接弃了吧（） 排名应该是rk103 / 934 。</p>
<h3 id="BBQ-Easy"><a href="#BBQ-Easy" class="headerlink" title="BBQ Easy"></a><strong>BBQ Easy</strong></h3><p>给出一个长 $2n$ 的整数序列 $a$ ，将它两两分组，求每组最小值之和的最大值。（ $1\le n\le100,1\le a_i\le100$​ ）</p>
<p>注意到最小值不管与谁分组得到的最小值都是它，另一个数无法做出贡献，所以无法做出贡献的那个数应该尽可能小。不妨令 $a_1\le a_2\le\cdot\cdot\cdot\le a_{2n}$​ ，则答案应该为 $\sum_{i=1}^n\min(a_{2i-1},a_{2i})=\sum_{i=1}^n a_{2i-1}$​ ，排序后直接求解即可。时间复杂度 $\mathcal{O}(n\log n)$​ 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> ai[<span class="number">300</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, ans = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;ai[i]);</span><br><span class="line">	std::<span class="built_in">sort</span>(ai + <span class="number">1</span>, ai + <span class="number">2</span> * n + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i += <span class="number">2</span>)</span><br><span class="line">		ans += ai[i];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Mysterious-Light"><a href="#Mysterious-Light" class="headerlink" title="Mysterious Light"></a><strong>Mysterious Light</strong></h3><p>有一个边长为 $n$ 的等边三角形 $ABC$ ，有一个点 $P$ 在边 $AB$ 上，且 $AP =x$ 。$P$ 沿平行于 $BC$ 边的方向开始运动，碰到 $\triangle ABC$ 的边或者 $P$ 之前的轨迹时会反弹（遵守物理规律，即入射角等于反射角），当 $P$ 点回到出发位置时停止运动。给出 $n,x$ ，求 $P$ 点的运动轨迹长，可以证明 $P$​ 点一定会停下。（ $2\le n\le 10^{12};1\le x\le n -1;n,x\in\mathbb{Z}$ ）</p>
<p>当 $n=5,x=2$ 时，运动轨迹如图（来自AtCoder原题）</p>
<p><img src="https://img.atcoder.jp/agc/001/Gg9pvPKw/btriangle.png" alt="triangle"></p>
<p>注意到从出发到第二次反弹前这段轨迹一定长为 $n$​​​ 。而第二，三次反弹时，$P$​​​ 点在一个边长为 $n-x$​​​ 和 $x$​​​ 的平行四边形的顶点上，轨迹为 $2x$​；第四，五次反弹时，$P$​​​ 点在一个边长为 $x$​​​ 和 $n-2x$​​​ （若 $n-x<x$​​​ ，则应该在边长为 $2x-n$​ 和 $n-x$​​​​ 的平行四边形上），轨迹为 $2n-4x$​；第六，七次反弹时，$P$​ 点在一个边长为 $3x-n$​ 和 $n-2x$​ 的平行四边形上，轨迹为 $2n-4x$​（若 $n-2x>x$​ ，则应该在边长为 $n-3x$​ 和 $x$​​ 的平行四边形上 ）；但该第八次反弹时，$P$​ 点在边长为 $0$​ 和 $n-2x$​​ 的平行四边形上，到达了终点。说明第七次反弹不存在，轨迹多算了一个 $n-2x$​ ，减去即可。</p>
<p>将上文所述的过程简述一下就是，令 $a=n-x,b=x,ans=n$​​​​​​ ，每轮操作不妨令 $a&gt;b$​​​​​​ ，则 $ans$​​​​​​ 加上 $2b$​​​​​​ ，然后，$a:=b-a$​​​​ ，不断重复这个过程直到 $a,b$​​​​ 其中一个为 $0$​​​​ 。此时会多算一个，不妨令 $a=0$​​​​ ，则 $ans$​​​​ 要减去 $b$​​​​ 。但这样慢慢减太慢了，当 $x$​​​​ 比较小， $n$​​​​ 特别大的时候会超时。所以我们不妨一步到位，不断 $a:=b-a$​​​ 直到 $a&lt;b$​​ ，其实相当于 $a:= a \bmod b$​​​ ​​​​，这样每次操作改为把 $ans$​​ 加上 $2\left\lfloor\dfrac{a}{b}\right\rfloor b$​ ，然后 $a:=a\bmod b$​​  即可。总复杂度类似​​辗转相除法，为 $\mathcal{O}(\log n)$​ 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(ll&amp; a, ll&amp; b)</span> </span>&#123; ll t = a; a = b; b = t; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll n, x, ans = <span class="number">0</span>, a, b; <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;x);</span><br><span class="line">	ans += n; a = x, b = n - x;</span><br><span class="line">	<span class="keyword">while</span> (a &amp;&amp; b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (a &lt; b) <span class="built_in">swap</span>(a, b);</span><br><span class="line">		ans += (a / b) * <span class="number">2</span> * b; a = a % b;</span><br><span class="line">	&#125;</span><br><span class="line">	ans -= a ? a : b;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Shorten-Diameter"><a href="#Shorten-Diameter" class="headerlink" title="Shorten Diameter"></a><strong>Shorten Diameter</strong></h3><p>给出一个有 $n$ 个顶点的树，删去若干个顶点（删去顶点时与顶点相连的边也会被删去）使得树的直径小于等于 $k$ 且依然连通，求删去顶点的最小数量。（ $1\le n\le 2000,1\le k\le n-1$ ）</p>
<p>不考虑删点，而是考虑选出一些点使直径小于等于 $k$​ （显然直径越长可选的点就越多）。考虑从直径的中心（如果 $k$​​ 为偶数中心是一个点，如果是奇数是一条边）开始扩展，选出所有到中心距离小于等于 $\left\lfloor\dfrac{k}{2}\right\rfloor$​ 的点（如果是边就当成两个点分别找一次）​，这样这些点和中心构成的树的直径一定小于等于 $k$​​ 。最终取所有可能的中心选出点的最大值就是不删的点，其余删掉即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp; b)</span> </span>&#123; <span class="keyword">return</span> a &lt; b ? a : b; &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span> <span class="keyword">int</span> v, u, next; &#125;E[N &lt;&lt; <span class="number">1</span>]; <span class="keyword">int</span> p[N], cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(p, <span class="number">-1</span>, <span class="keyword">sizeof</span> p); cnt = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123; E[cnt].u = u; E[cnt].v = v; E[cnt].next = p[u]; p[u] = cnt++; &#125;</span><br><span class="line"><span class="keyword">int</span> n, k, ret, ans = <span class="number">2e9</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (d &gt; k / <span class="number">2</span>) <span class="keyword">return</span> ; ++ret;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = p[u], v; i + <span class="number">1</span>; i = E[i].next)</span><br><span class="line">	&#123;</span><br><span class="line">		v = E[i].v; <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(v, u, d + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">init</span>(); <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt; n; i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y), <span class="built_in">insert</span>(x, y), <span class="built_in">insert</span>(y, x);</span><br><span class="line">	<span class="keyword">if</span> (k &amp; <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i += <span class="number">2</span>)</span><br><span class="line">			ret = <span class="number">0</span>, </span><br><span class="line">			<span class="built_in">dfs</span>(E[i].u, E[i].v, <span class="number">0</span>), <span class="built_in">dfs</span>(E[i].v, E[i].u, <span class="number">0</span>),</span><br><span class="line">			ans = <span class="built_in">min</span>(ans, n - ret);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			ret = <span class="number">0</span>, <span class="built_in">dfs</span>(i, <span class="number">0</span>, <span class="number">0</span>), ans = <span class="built_in">min</span>(ans, n - ret);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Arrays-and-Palindrome"><a href="#Arrays-and-Palindrome" class="headerlink" title="Arrays and Palindrome"></a>Arrays and Palindrome</h3><p>有两个数列 $a.b$ 满足以下条件：</p>
<p>  $\bullet$​​   $\sum_{i} a_i=n,\sum_{i} b_i=n$​​ ；</p>
<p>  $\bullet$​  $a_i,b_i\in\mathbb{N}_+$​ ；</p>
<p>  $\bullet$​​  满足下面两个条件的长为 $n$​ 的字符串所有元素必定相同：</p>
<p>​           $\bullet$   最开始的 $a_1$ 项，接下来的 $a_2$ 项，更后面的 $a_3$ 个等等都是回文；</p>
<p>​           $\bullet$  最开始的 $b_1$ 项，接下来的 $b_2$ 项，更后面的 $b_3$​​ 个等等都是回文。</p>
<p>已知 $a$ 是另一个长度为$m$ 的数列 $A$ 的一种排列，构造出一组 $a,b$ 满足以上性质。（ $1\le n\le 10^5;1\le m\le100;1\le A_i\le10^5,\sum_{i}^mA_i=n$ ）</p>
<p>人类智慧神仙题Orz。首先考虑抽象模型，对于回文串来说，对应的项都要相等，我们考虑在这些项之间连边，最终得到图的连通性就能对这个序列元素谁与谁相等提供信息。本题中，只有最终的图连通才能满足元素全部相同。而注意到，对于 $a_i$​​ ，如果它为偶数，则它构成的回文串会连 $\dfrac{a_i}{2}$​​ 条边，而如果 $a_i$​​ 为奇数，就只能连 $\dfrac{a_i-1}{2}$​​ 条边，出现一个孤立点。所以 $a$​​ 数列贡献的边个数为 $\dfrac{n-cnt}{2}$​​ ，其中$cnt$​​ 为 $a_i$​​ 为奇数的个数。又因为 $b$​​ 数列最多贡献 $\left\lfloor\dfrac{n}{2}\right\rfloor$​​ 条边，所以假如 $A$​​ 数列中出现的奇数大于等于三个，最终的边数就会小于等于 $\dfrac{n-1-n-3}{2}=n-2&lt;n-1$​​ 不满足构成一棵树的条件，所以无解。</p>
<p>判完无解后考虑构造 $a,b$​ 数列。与一般的构造题类似，我们首先从特殊情况入手。如果 $m=1$ ：如果 $n=1$ ，则显然 $b_1=1$ 就符合要求；如果 $n&gt;1$ ，则 $b_1=1,b_2=n-1$ 符合要求。可以自己画一张图试一下，这样会错位连边，最终连成一条链。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（0表示未连通，&gt;1表示连通）以 n=6 为例</span><br><span class="line">0 0 0 0 0 0 (---)  1 2 3 3 2 1 (a_1)  1 2 3 3 2 1 (b_1) </span><br><span class="line">1 1 3 3 2 1 (b_2)  1 1 2 3 2 1 (b_2)  1 1 1 3 1 1 (a_1)</span><br><span class="line">1 1 1 1 1 1 (a_1)   最终所有的都在一个连通块内</span><br></pre></td></tr></table></figure>
<p>接下来进入更一般的情况，我们假设 $a$​​​ 数列已经被恰当的排好了，这样可以借鉴 $m=1$​​​ 的经验，令 $b_1=a_1+1$​​​ ，这样可以使 $[1,a_1+1]$​​​ 的数均相同，接下来只要令 $b_i=a_i(2\le i&lt;m)$​​​  就行了，因为这时候 $b_i$​​​ 对应区间右端点的始终比 $a_i$​​​ 大一，也就是 $[a_{i-1}+1,a_i+1]$​​​ 的数均相同，这样一路顺下来就可以做到全部都相同了，最后为了 维护 $b$​​​ 的和等于 $n$​​​ ，$b_m=a_m-1$​​​ ，这样可以使 $[a_{m-1}+1,a_m]$​​​ 的数均相同，完美收尾。接下来考虑如何排列 $a$​​​​ 数列。注意到如果 $\exist i,a_i=b_i\equiv1 \pmod{2}$​​​ ，连边的情况就会变成下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（意义同上） 以 a_i=b_i=5 为例</span><br><span class="line">0 0 0 0 0 0 (---)  1 2 3 2 1 0 (a_i) 1 2 1 2 1 2 (a_i,b_i)</span><br><span class="line">注意到此时连通情况满足 a_i 和 b_i 的条件，但不在同一个连通块内，不符合条件</span><br></pre></td></tr></table></figure>
<p>所以我们只能把 $a_i$​​ 为奇数的值仍在数列的开头或结尾这样 $a_i,b_i$​​ 奇偶性不同的地方。注意到位置只有两个，这与我们推导出的 $cnt&gt;2$​​ 就无解的结论是一致的。总复杂度 $\mathcal{O}(m\log m)$​​ 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> ai[<span class="number">200</span>]; std::vector&lt;<span class="keyword">int</span>&gt; bi;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp; b)</span> </span>&#123; <span class="keyword">return</span> (a &amp; <span class="number">1</span>) &gt; (b &amp; <span class="number">1</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m, cnt = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;ai[i]), cnt += (ai[i] &amp; <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (m == <span class="number">1</span> &amp;&amp; ai[<span class="number">1</span>] == <span class="number">1</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;1\n1\n1&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (m == <span class="number">1</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;%d\n2\n1 %d&quot;</span>, ai[<span class="number">1</span>], ai[<span class="number">1</span>] - <span class="number">1</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">	<span class="keyword">if</span> (cnt &gt; <span class="number">2</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;Impossible&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">	std::<span class="built_in">sort</span>(ai + <span class="number">1</span>, ai + m + <span class="number">1</span>, cmp);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ai[<span class="number">1</span>]); <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= m; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ai[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ai[<span class="number">2</span>]); bi.<span class="built_in">push_back</span>(ai[<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= m; i++) bi.<span class="built_in">push_back</span>(ai[i]);</span><br><span class="line">	<span class="keyword">if</span> (ai[<span class="number">2</span>] &gt; <span class="number">1</span>) bi.<span class="built_in">push_back</span>(ai[<span class="number">2</span>] - <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%llu\n&quot;</span>, bi.<span class="built_in">size</span>());</span><br><span class="line">	<span class="keyword">for</span> (std::vector&lt;<span class="keyword">int</span>&gt;::iterator it = bi.<span class="built_in">begin</span>(); it != bi.<span class="built_in">end</span>(); it++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *it);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BBQ-Hard"><a href="#BBQ-Hard" class="headerlink" title="BBQ Hard"></a>BBQ Hard</h3><p>给出 $n$ 个数对 $(a_i,b_i)$ ，求 </p>
<script type="math/tex; mode=display">\boxed{\sum_{i=1}^n\sum_{j=i+1}^n\dbinom{a_i+b_i+a_j+b_j}{a_i+a_j}}</script><p>答案对 $10^9+7$ 取模。（ $2\le n\le2\times10^5;1\le a_i,b_i\le 2000$ ）</p>
<p>从组合数的组合意义入手： $\dbinom{x+y}{x}$​ 表示从点 $(0,0)$ 到点 $(x,y)$​​ ，每次只能向上或者向右的不同走法的方案数，而原组合数就代表从 $(0,0)$ 到 $(a_i+a_j,b_i+b_j)$ 的方案数。这样我们就可以把组合数的计算转化为DP，即设 $f_{i,j}$ 表示 $(0,0)$ 到 $(i,j)$ 的路径条数，则显然有 $f_{i,j}=f_{i-1,j}+f_{i,j-1}$ ，即从下面过来还是从左边过来。因为 $a_i,b_i$ 范围较小，$\mathcal{O}(a^2)$ 枚举还是可以接受的。但处理好DP并不能降低原有的 $\mathcal{O}(n^2)$ 枚举的复杂度，依旧无法通过。我们发现这个需要求和的值与 $i,j$​​ 都有关，这很难优化至一个较低的复杂度。所以我们考虑消掉一维。</p>
<p>我们将原来的点平移一下，变成从 $(-a_i,-b_i)$​ 到 $(a_j,b_j)$​ 的方案数，容易发现与平移前的方案数相同。接下来我们发现，起点只与 $i$​ 有关，终点只与 $j$​ 有关，二者独立，所以我们计算 $f$​ 时就可以把所有的 $f_{-a_i,-b_i}$​​ 初始值设为 $1$ ，这样递推计算后 $f_{i,j}$​ 的意义就变为了 $(i,j)$ 到所有的 $(-a_i,-b_i)$ 的方案数之和。这样计算时就只需要枚举 $j$ 而不需要枚举 $i$ 了，成功消去一维。</p>
<p>然后是一些细节问题。首先因为 $i\neq j$​ ，所以要减去 $(-a_i,-b_i)$​ 到 $(a_i,b_i)$​ 的影响，即 $\dbinom{2a_i+2b_i}{2a_i}$​ ， $\mathcal{O}(1)$​ 计算后直接减去即可。又由于 $i&lt;j$​ ，全部计算完后的结果还需要除以二，才是最终的结果。总复杂度 $\mathcal{O}(a^2+n)$​ 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll N = <span class="number">3e3</span>, S = <span class="number">2e3</span> + <span class="number">50</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>, M = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line">ll f[N &lt;&lt; <span class="number">1</span>][N &lt;&lt; <span class="number">1</span>], fac[N &lt;&lt; <span class="number">2</span>], ifac[N &lt;&lt; <span class="number">2</span>], ai[M], bi[M]; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">ksm</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123; ll ret = <span class="number">1</span>; <span class="keyword">while</span> (b) &#123; <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * a % mod; a = a * a % mod; b &gt;&gt;= <span class="number">1</span>; &#125; <span class="keyword">return</span> ret; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">C</span><span class="params">(ll n, ll m)</span> </span>&#123; <span class="keyword">return</span> fac[n] * ifac[m] % mod * ifac[n - m] % mod; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll n, ans = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;ai[i], &amp;bi[i]), ++f[-ai[i] + S][-bi[i] + S];</span><br><span class="line">	fac[<span class="number">0</span>] = ifac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= <span class="number">8000</span>; i++) </span><br><span class="line">		fac[i] = fac[i - <span class="number">1</span>] * i % mod, ifac[i] = <span class="built_in">ksm</span>(fac[i], mod - <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= (S &lt;&lt; <span class="number">1</span>); i++)</span><br><span class="line">		<span class="keyword">for</span> (ll j = <span class="number">1</span>; j &lt;= (S &lt;&lt; <span class="number">1</span>); j++)</span><br><span class="line">			f[i][j] = (f[i][j] + (f[i - <span class="number">1</span>][j] + f[i][j - <span class="number">1</span>]) % mod) % mod;</span><br><span class="line">	<span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ans = (ans + f[S + ai[i]][S + bi[i]]) % mod;</span><br><span class="line">		ans = ((ans - <span class="built_in">C</span>((ai[i] &lt;&lt; <span class="number">1</span>) + (bi[i] &lt;&lt; <span class="number">1</span>), (ai[i] &lt;&lt; <span class="number">1</span>))) % mod + mod) % mod;</span><br><span class="line">	&#125;</span><br><span class="line">	ans = ans * <span class="built_in">ksm</span>(<span class="number">2</span>, mod - <span class="number">2</span>) % mod;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Wide-Swap"><a href="#Wide-Swap" class="headerlink" title="Wide Swap"></a>Wide Swap</h3><p>给出一个长为 $n$ 的排列 $P$ ，当 $i,j(1\le i&lt;j\le n)$ 满足 $j-i\ge k$ 且 $|P_i-P_j|=1$ 时，可以交换 $P_i,P_j$ 。问可能排列中字典序最小的排列。（ $1\le n\le 5\times10^5;1\le k\le n - 1$ ）</p>
<p>神仙题Orz，这一场唯一0人AC的题。考虑 $Q$ 为 $P$ 的逆置换（即如果 $P_i=x$ ，则 $Q_x=i$​​ ）， 那原条件就变为了如果 $|Q_i-Q_{i+1}|\ge k$ 就可以交换 $i,i+1$ 。我们发现，对于 $Q$ 中的两个值，如果它们的差小于 $k$ ，那就无法交换，顺序被定死了。形式化讲，对于所有满足 $|u-v|&lt;k$ 的 $(u,v)$ 它们在 $Q$​ 中出现的相对位置是固定的。所以我们只需要求满足 $(u,v)$​ 的限制关系的所有排列即可。了解了这个，我们再回到 $P$ ，条件就可以改写为对于所有满足 $|i-j|&lt;k$ 的下标 $(i,j)$  $P_i,P_j$ 之间的大小关系在交换前后不变。</p>
<p>我们发现，把上述必须满足的不等式写出来后，可以构造出一个DAG，而我们想让 $P_1$ 尽量小，在这基础上让 $P_2$ 尽量小，以此类推，其实就是给每个点一个恰当的拓扑序，使拓扑序的字典序尽量小。这就是经典问题了，我们的一般解法是把边反向后做拓扑排序，每次优先选取编号最大的点，拓扑序也从 $n$ 往 $1$ 编号。</p>
<p>注意到每一个点会连出去 $\mathcal{O}(k)$ 条边，所以总边数为 $\mathcal{O}(nk)$ ，显然无法直接做，所以自然想到用数据结构来优化。注意到任意时刻下，入度为 $0$ 的点是满足 $P_i$ 为在 $(i-k,i+k)$ 中最大值的 $i$ 。而删除一个点 $i$ 就相当于把 $P_i$ 改成 $-\infty$​ ，然后影响 $(i-k,i+k)$​​ 这个区间的连边情况。这样就可以用线段树维护了。初始时检查一遍每个点是否入度为 $0$ ，如果是加入一个大根堆中。然后每次取出堆顶，删除它后分别查询 $(i-k,i)$ 和 $(i,i+k)$ 这两个区间的最大值，检查入度是否为 $0$​ 后入堆。最后直接输出每个点的拓扑序即可，总复杂度 $\mathcal{O}(n\log n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">10</span>, inf = <span class="number">2e9</span>;</span><br><span class="line"><span class="keyword">int</span> h[N &lt;&lt; <span class="number">2</span>], P[N], topo[N], inq[N], n, k; std::priority_queue&lt;<span class="keyword">int</span>&gt; pq;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function"></span>&#123; h[k] = P[h[k &lt;&lt; <span class="number">1</span>]] &gt; P[h[k &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]] ? h[k &lt;&lt; <span class="number">1</span>] : h[k &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l == r) <span class="keyword">return</span> (<span class="keyword">void</span>)(h[k] = l);</span><br><span class="line">	<span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">build</span>(k &lt;&lt; <span class="number">1</span>, l, mid); <span class="built_in">build</span>(k &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">	<span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l == r) <span class="keyword">return</span> (<span class="keyword">void</span>)(h[k] = <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (x &lt;= mid) <span class="built_in">del</span>(k &lt;&lt; <span class="number">1</span>, l, mid, x);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">del</span>(k &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, x);</span><br><span class="line">	<span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (r &lt; x || l &gt; y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) <span class="keyword">return</span> h[k];</span><br><span class="line">	<span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> v1 = <span class="built_in">query</span>(k &lt;&lt; <span class="number">1</span>, l, mid, x, y),</span><br><span class="line">	    v2 = <span class="built_in">query</span>(k &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, x, y);</span><br><span class="line">	<span class="keyword">return</span> P[v1] &gt; P[v2] ? v1 : v2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (inq[u]) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, u - k + <span class="number">1</span>, u + k - <span class="number">1</span>) == u)</span><br><span class="line">		pq.<span class="built_in">push</span>(u), inq[u] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k); P[<span class="number">0</span>] = -inf;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;P[i]);</span><br><span class="line">	<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">check</span>(i);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n, pos; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> u = pq.<span class="built_in">top</span>(); pq.<span class="built_in">pop</span>();</span><br><span class="line">		topo[u] = i; <span class="built_in">del</span>(<span class="number">1</span>, <span class="number">1</span>, n, u);</span><br><span class="line">		<span class="keyword">if</span> ((pos = <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, u - k + <span class="number">1</span>, u - <span class="number">1</span>))) <span class="built_in">check</span>(pos);</span><br><span class="line">		<span class="keyword">if</span> ((pos = <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, u + <span class="number">1</span>, u + k - <span class="number">1</span>))) <span class="built_in">check</span>(pos);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, topo[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="经验知识总结"><a href="#经验知识总结" class="headerlink" title="经验知识总结"></a>经验知识总结</h3><ol>
<li>面对无从下手的数据范围较大，看起来规律性很强的题目，要先手玩小数据找规律。</li>
<li>有时候可以转化一下题意，比如不考虑删除而是考虑选取。</li>
<li>面对构造题可以先从特殊情况入手，发现一些特殊性质，再利用这些特殊性质为突破口突破至一般情况。</li>
<li>$\dbinom{x+y}{x}$ 的组合意义是从 $(0,0)$ 到 $(x,y)$ ，只能向上或向右的方案数。</li>
<li>如果面对 $\mathcal{O}(n^2)$ 的枚举 $i,j$​ 无从优化，可以考虑通过转化问题使两个变量分离。</li>
<li>对于排列的限制可以转化为逆置换（如果 $P_i=x,Q_x=i$​ ，则称 $Q$ 为 $P$ 的逆置换）再转化回来的形式加以边换。</li>
<li>给每个点一个恰当的拓扑序，使拓扑序的字典序尽量小这样的经典问题可以用把边反向后做拓扑排序，每次优先选取编号最大的点，拓扑序也从 $n$ 往 $1$ 编号的方式求解。</li>
<li>一些图论题无法直接显式连边求解时可以考虑用数据结构优化。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhiyangfan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhiyangfan</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
